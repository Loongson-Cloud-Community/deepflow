// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dfi.proto

package dfi

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RequestType int32

const (
	RequestType_FLOW_HEADER     RequestType = 1
	RequestType_OVS_TOPOLOGY    RequestType = 2
	RequestType_PACKET_HEADER   RequestType = 3
	RequestType_METERING_HEADER RequestType = 4
)

var RequestType_name = map[int32]string{
	1: "FLOW_HEADER",
	2: "OVS_TOPOLOGY",
	3: "PACKET_HEADER",
	4: "METERING_HEADER",
}

var RequestType_value = map[string]int32{
	"FLOW_HEADER":     1,
	"OVS_TOPOLOGY":    2,
	"PACKET_HEADER":   3,
	"METERING_HEADER": 4,
}

func (x RequestType) Enum() *RequestType {
	p := new(RequestType)
	*p = x
	return p
}

func (x RequestType) String() string {
	return proto.EnumName(RequestType_name, int32(x))
}

func (x *RequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RequestType_value, data, "RequestType")
	if err != nil {
		return err
	}
	*x = RequestType(value)
	return nil
}

func (RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{0}
}

type Direction int32

const (
	Direction_FORWARD Direction = 0
	Direction_REVERSE Direction = 1
)

var Direction_name = map[int32]string{
	0: "FORWARD",
	1: "REVERSE",
}

var Direction_value = map[string]int32{
	"FORWARD": 0,
	"REVERSE": 1,
}

func (x Direction) Enum() *Direction {
	p := new(Direction)
	*p = x
	return p
}

func (x Direction) String() string {
	return proto.EnumName(Direction_name, int32(x))
}

func (x *Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Direction_value, data, "Direction")
	if err != nil {
		return err
	}
	*x = Direction(value)
	return nil
}

func (Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{1}
}

type FlowHeader struct {
	Sequence             *uint64  `protobuf:"fixed64,1,req,name=sequence" json:"sequence,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowHeader) Reset()         { *m = FlowHeader{} }
func (m *FlowHeader) String() string { return proto.CompactTextString(m) }
func (*FlowHeader) ProtoMessage()    {}
func (*FlowHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{0}
}
func (m *FlowHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowHeader.Merge(m, src)
}
func (m *FlowHeader) XXX_Size() int {
	return m.Size()
}
func (m *FlowHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowHeader.DiscardUnknown(m)
}

var xxx_messageInfo_FlowHeader proto.InternalMessageInfo

func (m *FlowHeader) GetSequence() uint64 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

type OvsPort struct {
	Mac                  *string  `protobuf:"bytes,1,opt,name=mac" json:"mac,omitempty"`
	DpPort               *uint32  `protobuf:"varint,2,opt,name=dp_port,json=dpPort" json:"dp_port,omitempty"`
	InterfaceName        *string  `protobuf:"bytes,3,opt,name=interface_name,json=interfaceName" json:"interface_name,omitempty"`
	BridgeName           *string  `protobuf:"bytes,4,opt,name=bridge_name,json=bridgeName" json:"bridge_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OvsPort) Reset()         { *m = OvsPort{} }
func (m *OvsPort) String() string { return proto.CompactTextString(m) }
func (*OvsPort) ProtoMessage()    {}
func (*OvsPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{1}
}
func (m *OvsPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OvsPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OvsPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OvsPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OvsPort.Merge(m, src)
}
func (m *OvsPort) XXX_Size() int {
	return m.Size()
}
func (m *OvsPort) XXX_DiscardUnknown() {
	xxx_messageInfo_OvsPort.DiscardUnknown(m)
}

var xxx_messageInfo_OvsPort proto.InternalMessageInfo

func (m *OvsPort) GetMac() string {
	if m != nil && m.Mac != nil {
		return *m.Mac
	}
	return ""
}

func (m *OvsPort) GetDpPort() uint32 {
	if m != nil && m.DpPort != nil {
		return *m.DpPort
	}
	return 0
}

func (m *OvsPort) GetInterfaceName() string {
	if m != nil && m.InterfaceName != nil {
		return *m.InterfaceName
	}
	return ""
}

func (m *OvsPort) GetBridgeName() string {
	if m != nil && m.BridgeName != nil {
		return *m.BridgeName
	}
	return ""
}

type OvsTopology struct {
	Ports                []*OvsPort `protobuf:"bytes,1,rep,name=ports" json:"ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *OvsTopology) Reset()         { *m = OvsTopology{} }
func (m *OvsTopology) String() string { return proto.CompactTextString(m) }
func (*OvsTopology) ProtoMessage()    {}
func (*OvsTopology) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{2}
}
func (m *OvsTopology) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OvsTopology) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OvsTopology.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OvsTopology) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OvsTopology.Merge(m, src)
}
func (m *OvsTopology) XXX_Size() int {
	return m.Size()
}
func (m *OvsTopology) XXX_DiscardUnknown() {
	xxx_messageInfo_OvsTopology.DiscardUnknown(m)
}

var xxx_messageInfo_OvsTopology proto.InternalMessageInfo

func (m *OvsTopology) GetPorts() []*OvsPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

type Request struct {
	Type                 *RequestType `protobuf:"varint,1,opt,name=type,enum=DFI.RequestType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{3}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetType() RequestType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return RequestType_FLOW_HEADER
}

type StreamHeader struct {
	Timestamp            *uint32  `protobuf:"fixed32,1,req,name=timestamp" json:"timestamp,omitempty"`
	Sequence             *uint32  `protobuf:"fixed32,2,req,name=sequence" json:"sequence,omitempty"`
	ActionFlags          *uint32  `protobuf:"fixed32,3,req,name=action_flags,json=actionFlags" json:"action_flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamHeader) Reset()         { *m = StreamHeader{} }
func (m *StreamHeader) String() string { return proto.CompactTextString(m) }
func (*StreamHeader) ProtoMessage()    {}
func (*StreamHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{4}
}
func (m *StreamHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamHeader.Merge(m, src)
}
func (m *StreamHeader) XXX_Size() int {
	return m.Size()
}
func (m *StreamHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamHeader.DiscardUnknown(m)
}

var xxx_messageInfo_StreamHeader proto.InternalMessageInfo

func (m *StreamHeader) GetTimestamp() uint32 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *StreamHeader) GetSequence() uint32 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func (m *StreamHeader) GetActionFlags() uint32 {
	if m != nil && m.ActionFlags != nil {
		return *m.ActionFlags
	}
	return 0
}

// Evaluated in host byte order.
// If the value is the same as the default value, then the corresponding key
// is unnecessary to be evaluated, in other words, has_xxx = 0
type Flow struct {
	VtapId     *uint32 `protobuf:"varint,1,opt,name=vtap_id,json=vtapId" json:"vtap_id,omitempty"`
	Exporter   *uint32 `protobuf:"varint,2,opt,name=exporter" json:"exporter,omitempty"`
	CloseType  *uint32 `protobuf:"varint,7,opt,name=close_type,json=closeType" json:"close_type,omitempty"`
	FlowId     *uint64 `protobuf:"varint,8,opt,name=flow_id,json=flowId" json:"flow_id,omitempty"`
	FlowSource *uint32 `protobuf:"varint,9,opt,name=flow_source,json=flowSource" json:"flow_source,omitempty"`
	StartTime  *uint32 `protobuf:"varint,11,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	EndTime    *uint32 `protobuf:"varint,12,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	Duration   *uint64 `protobuf:"varint,13,opt,name=duration" json:"duration,omitempty"`
	// L1
	TapType *uint32 `protobuf:"varint,21,opt,name=tap_type,json=tapType,def=0" json:"tap_type,omitempty"`
	TapPort *uint32 `protobuf:"varint,22,opt,name=tap_port,json=tapPort,def=0" json:"tap_port,omitempty"`
	// L2
	Vlan    *uint32 `protobuf:"varint,31,opt,name=vlan,def=0" json:"vlan,omitempty"`
	EthType *uint32 `protobuf:"varint,32,opt,name=eth_type,json=ethType,def=0" json:"eth_type,omitempty"`
	MacSrc  *uint64 `protobuf:"varint,33,opt,name=mac_src,json=macSrc,def=0" json:"mac_src,omitempty"`
	MacDst  *uint64 `protobuf:"varint,34,opt,name=mac_dst,json=macDst,def=0" json:"mac_dst,omitempty"`
	// L3
	IpSrc  *uint32 `protobuf:"varint,41,opt,name=ip_src,json=ipSrc" json:"ip_src,omitempty"`
	IpDst  *uint32 `protobuf:"varint,42,opt,name=ip_dst,json=ipDst" json:"ip_dst,omitempty"`
	Ip6Src []byte  `protobuf:"bytes,45,opt,name=ip6_src,json=ip6Src" json:"ip6_src,omitempty"`
	Ip6Dst []byte  `protobuf:"bytes,46,opt,name=ip6_dst,json=ip6Dst" json:"ip6_dst,omitempty"`
	// L4
	Proto      *uint32 `protobuf:"varint,51,opt,name=proto,def=0" json:"proto,omitempty"`
	PortSrc    *uint32 `protobuf:"varint,52,opt,name=port_src,json=portSrc" json:"port_src,omitempty"`
	PortDst    *uint32 `protobuf:"varint,53,opt,name=port_dst,json=portDst" json:"port_dst,omitempty"`
	TcpFlags_0 *uint32 `protobuf:"varint,54,opt,name=tcp_flags_0,json=tcpFlags0,def=0" json:"tcp_flags_0,omitempty"`
	TcpFlags_1 *uint32 `protobuf:"varint,55,opt,name=tcp_flags_1,json=tcpFlags1,def=0" json:"tcp_flags_1,omitempty"`
	// Tunnel
	TunTxId   *uint32 `protobuf:"varint,61,opt,name=tun_tx_id,json=tunTxId,def=0" json:"tun_tx_id,omitempty"`
	TunTxIp_0 *uint32 `protobuf:"varint,62,opt,name=tun_tx_ip_0,json=tunTxIp0,def=0" json:"tun_tx_ip_0,omitempty"`
	TunTxIp_1 *uint32 `protobuf:"varint,63,opt,name=tun_tx_ip_1,json=tunTxIp1,def=0" json:"tun_tx_ip_1,omitempty"`
	TunType   *uint32 `protobuf:"varint,64,opt,name=tun_type,json=tunType,def=0" json:"tun_type,omitempty"`
	TunRxIp_0 *uint32 `protobuf:"varint,65,opt,name=tun_rx_ip_0,json=tunRxIp0,def=0" json:"tun_rx_ip_0,omitempty"`
	TunRxIp_1 *uint32 `protobuf:"varint,66,opt,name=tun_rx_ip_1,json=tunRxIp1,def=0" json:"tun_rx_ip_1,omitempty"`
	TunTier   *uint32 `protobuf:"varint,67,opt,name=tun_tier,json=tunTier,def=0" json:"tun_tier,omitempty"`
	TunRxId   *uint32 `protobuf:"varint,68,opt,name=tun_rx_id,json=tunRxId,def=0" json:"tun_rx_id,omitempty"`
	// Packet Counters
	ByteCnt_0      *uint64 `protobuf:"varint,71,opt,name=byte_cnt_0,json=byteCnt0,def=0" json:"byte_cnt_0,omitempty"`
	ByteCnt_1      *uint64 `protobuf:"varint,72,opt,name=byte_cnt_1,json=byteCnt1,def=0" json:"byte_cnt_1,omitempty"`
	PktCnt_0       *uint64 `protobuf:"varint,73,opt,name=pkt_cnt_0,json=pktCnt0,def=0" json:"pkt_cnt_0,omitempty"`
	PktCnt_1       *uint64 `protobuf:"varint,74,opt,name=pkt_cnt_1,json=pktCnt1,def=0" json:"pkt_cnt_1,omitempty"`
	TotalByteCnt_0 *uint64 `protobuf:"varint,75,opt,name=total_byte_cnt_0,json=totalByteCnt0,def=0" json:"total_byte_cnt_0,omitempty"`
	TotalByteCnt_1 *uint64 `protobuf:"varint,76,opt,name=total_byte_cnt_1,json=totalByteCnt1,def=0" json:"total_byte_cnt_1,omitempty"`
	TotalPktCnt_0  *uint64 `protobuf:"varint,77,opt,name=total_pkt_cnt_0,json=totalPktCnt0,def=0" json:"total_pkt_cnt_0,omitempty"`
	TotalPktCnt_1  *uint64 `protobuf:"varint,78,opt,name=total_pkt_cnt_1,json=totalPktCnt1,def=0" json:"total_pkt_cnt_1,omitempty"`
	// Platform Data
	SubnetId_0      *uint32 `protobuf:"varint,100,opt,name=subnet_id_0,json=subnetId0,def=0" json:"subnet_id_0,omitempty"`
	SubnetId_1      *uint32 `protobuf:"varint,101,opt,name=subnet_id_1,json=subnetId1,def=0" json:"subnet_id_1,omitempty"`
	L3DeviceType_0  *uint32 `protobuf:"varint,102,opt,name=l3_device_type_0,json=l3DeviceType0,def=0" json:"l3_device_type_0,omitempty"`
	L3DeviceType_1  *uint32 `protobuf:"varint,103,opt,name=l3_device_type_1,json=l3DeviceType1,def=0" json:"l3_device_type_1,omitempty"`
	L3DeviceId_0    *uint32 `protobuf:"varint,104,opt,name=l3_device_id_0,json=l3DeviceId0,def=0" json:"l3_device_id_0,omitempty"`
	L3DeviceId_1    *uint32 `protobuf:"varint,105,opt,name=l3_device_id_1,json=l3DeviceId1,def=0" json:"l3_device_id_1,omitempty"`
	L3EpcId_0       *uint32 `protobuf:"varint,106,opt,name=l3_epc_id_0,json=l3EpcId0,def=0" json:"l3_epc_id_0,omitempty"`
	L3EpcId_1       *uint32 `protobuf:"varint,107,opt,name=l3_epc_id_1,json=l3EpcId1,def=0" json:"l3_epc_id_1,omitempty"`
	Host_0          *uint32 `protobuf:"varint,108,opt,name=host_0,json=host0" json:"host_0,omitempty"`
	Host_1          *uint32 `protobuf:"varint,109,opt,name=host_1,json=host1" json:"host_1,omitempty"`
	EpcId_0         *uint32 `protobuf:"varint,120,opt,name=epc_id_0,json=epcId0,def=0" json:"epc_id_0,omitempty"`
	EpcId_1         *uint32 `protobuf:"varint,121,opt,name=epc_id_1,json=epcId1,def=0" json:"epc_id_1,omitempty"`
	DeviceType_0    *uint32 `protobuf:"varint,122,opt,name=device_type_0,json=deviceType0,def=0" json:"device_type_0,omitempty"`
	DeviceType_1    *uint32 `protobuf:"varint,123,opt,name=device_type_1,json=deviceType1,def=0" json:"device_type_1,omitempty"`
	DeviceId_0      *uint32 `protobuf:"varint,124,opt,name=device_id_0,json=deviceId0,def=0" json:"device_id_0,omitempty"`
	DeviceId_1      *uint32 `protobuf:"varint,125,opt,name=device_id_1,json=deviceId1,def=0" json:"device_id_1,omitempty"`
	IsL2End_0       *bool   `protobuf:"varint,130,opt,name=is_l2_end_0,json=isL2End0,def=0" json:"is_l2_end_0,omitempty"`
	IsL2End_1       *bool   `protobuf:"varint,131,opt,name=is_l2_end_1,json=isL2End1,def=0" json:"is_l2_end_1,omitempty"`
	IsL3End_0       *bool   `protobuf:"varint,132,opt,name=is_l3_end_0,json=isL3End0,def=0" json:"is_l3_end_0,omitempty"`
	IsL3End_1       *bool   `protobuf:"varint,133,opt,name=is_l3_end_1,json=isL3End1,def=0" json:"is_l3_end_1,omitempty"`
	RttAvg          *uint64 `protobuf:"varint,142,opt,name=rtt_avg,json=rttAvg,def=0" json:"rtt_avg,omitempty"`
	SrtAvg          *uint64 `protobuf:"varint,143,opt,name=srt_avg,json=srtAvg,def=0" json:"srt_avg,omitempty"`
	RetransCnt_0    *uint64 `protobuf:"varint,145,opt,name=retrans_cnt_0,json=retransCnt0,def=0" json:"retrans_cnt_0,omitempty"`
	RetransCnt_1    *uint64 `protobuf:"varint,146,opt,name=retrans_cnt_1,json=retransCnt1,def=0" json:"retrans_cnt_1,omitempty"`
	TotalRetransCnt *uint64 `protobuf:"varint,147,opt,name=total_retrans_cnt,json=totalRetransCnt,def=0" json:"total_retrans_cnt,omitempty"`
	ZeroWndCnt_0    *uint64 `protobuf:"varint,148,opt,name=zero_wnd_cnt_0,json=zeroWndCnt0,def=0" json:"zero_wnd_cnt_0,omitempty"`
	ZeroWndCnt_1    *uint64 `protobuf:"varint,149,opt,name=zero_wnd_cnt_1,json=zeroWndCnt1,def=0" json:"zero_wnd_cnt_1,omitempty"`
	ArtAvg          *uint64 `protobuf:"varint,157,opt,name=art_avg,json=artAvg,def=0" json:"art_avg,omitempty"`
	RttClientAvg    *uint64 `protobuf:"varint,165,opt,name=rtt_client_avg,json=rttClientAvg,def=0" json:"rtt_client_avg,omitempty"`
	RttServerAvg    *uint64 `protobuf:"varint,166,opt,name=rtt_server_avg,json=rttServerAvg,def=0" json:"rtt_server_avg,omitempty"`
	// Geo Info
	ProvinceSrc *uint32 `protobuf:"varint,174,opt,name=province_src,json=provinceSrc,def=0" json:"province_src,omitempty"`
	ProvinceDst *uint32 `protobuf:"varint,175,opt,name=province_dst,json=provinceDst,def=0" json:"province_dst,omitempty"`
	// Other
	CastTypeMap_0        *uint32  `protobuf:"varint,200,opt,name=cast_type_map_0,json=castTypeMap0,def=0" json:"cast_type_map_0,omitempty"`
	CastTypeMap_1        *uint32  `protobuf:"varint,201,opt,name=cast_type_map_1,json=castTypeMap1,def=0" json:"cast_type_map_1,omitempty"`
	TcpFlagsMap_0        *uint32  `protobuf:"varint,202,opt,name=tcp_flags_map_0,json=tcpFlagsMap0,def=0" json:"tcp_flags_map_0,omitempty"`
	TcpFlagsMap_1        *uint32  `protobuf:"varint,203,opt,name=tcp_flags_map_1,json=tcpFlagsMap1,def=0" json:"tcp_flags_map_1,omitempty"`
	TtlMap_0             *uint32  `protobuf:"varint,204,opt,name=ttl_map_0,json=ttlMap0,def=0" json:"ttl_map_0,omitempty"`
	TtlMap_1             *uint32  `protobuf:"varint,205,opt,name=ttl_map_1,json=ttlMap1,def=0" json:"ttl_map_1,omitempty"`
	PacketSizeMap_0      *uint32  `protobuf:"varint,206,opt,name=packet_size_map_0,json=packetSizeMap0,def=0" json:"packet_size_map_0,omitempty"`
	PacketSizeMap_1      *uint32  `protobuf:"varint,207,opt,name=packet_size_map_1,json=packetSizeMap1,def=0" json:"packet_size_map_1,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Flow) Reset()         { *m = Flow{} }
func (m *Flow) String() string { return proto.CompactTextString(m) }
func (*Flow) ProtoMessage()    {}
func (*Flow) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{5}
}
func (m *Flow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Flow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flow.Merge(m, src)
}
func (m *Flow) XXX_Size() int {
	return m.Size()
}
func (m *Flow) XXX_DiscardUnknown() {
	xxx_messageInfo_Flow.DiscardUnknown(m)
}

var xxx_messageInfo_Flow proto.InternalMessageInfo

const Default_Flow_TapType uint32 = 0
const Default_Flow_TapPort uint32 = 0
const Default_Flow_Vlan uint32 = 0
const Default_Flow_EthType uint32 = 0
const Default_Flow_MacSrc uint64 = 0
const Default_Flow_MacDst uint64 = 0
const Default_Flow_Proto uint32 = 0
const Default_Flow_TcpFlags_0 uint32 = 0
const Default_Flow_TcpFlags_1 uint32 = 0
const Default_Flow_TunTxId uint32 = 0
const Default_Flow_TunTxIp_0 uint32 = 0
const Default_Flow_TunTxIp_1 uint32 = 0
const Default_Flow_TunType uint32 = 0
const Default_Flow_TunRxIp_0 uint32 = 0
const Default_Flow_TunRxIp_1 uint32 = 0
const Default_Flow_TunTier uint32 = 0
const Default_Flow_TunRxId uint32 = 0
const Default_Flow_ByteCnt_0 uint64 = 0
const Default_Flow_ByteCnt_1 uint64 = 0
const Default_Flow_PktCnt_0 uint64 = 0
const Default_Flow_PktCnt_1 uint64 = 0
const Default_Flow_TotalByteCnt_0 uint64 = 0
const Default_Flow_TotalByteCnt_1 uint64 = 0
const Default_Flow_TotalPktCnt_0 uint64 = 0
const Default_Flow_TotalPktCnt_1 uint64 = 0
const Default_Flow_SubnetId_0 uint32 = 0
const Default_Flow_SubnetId_1 uint32 = 0
const Default_Flow_L3DeviceType_0 uint32 = 0
const Default_Flow_L3DeviceType_1 uint32 = 0
const Default_Flow_L3DeviceId_0 uint32 = 0
const Default_Flow_L3DeviceId_1 uint32 = 0
const Default_Flow_L3EpcId_0 uint32 = 0
const Default_Flow_L3EpcId_1 uint32 = 0
const Default_Flow_EpcId_0 uint32 = 0
const Default_Flow_EpcId_1 uint32 = 0
const Default_Flow_DeviceType_0 uint32 = 0
const Default_Flow_DeviceType_1 uint32 = 0
const Default_Flow_DeviceId_0 uint32 = 0
const Default_Flow_DeviceId_1 uint32 = 0
const Default_Flow_IsL2End_0 bool = false
const Default_Flow_IsL2End_1 bool = false
const Default_Flow_IsL3End_0 bool = false
const Default_Flow_IsL3End_1 bool = false
const Default_Flow_RttAvg uint64 = 0
const Default_Flow_SrtAvg uint64 = 0
const Default_Flow_RetransCnt_0 uint64 = 0
const Default_Flow_RetransCnt_1 uint64 = 0
const Default_Flow_TotalRetransCnt uint64 = 0
const Default_Flow_ZeroWndCnt_0 uint64 = 0
const Default_Flow_ZeroWndCnt_1 uint64 = 0
const Default_Flow_ArtAvg uint64 = 0
const Default_Flow_RttClientAvg uint64 = 0
const Default_Flow_RttServerAvg uint64 = 0
const Default_Flow_ProvinceSrc uint32 = 0
const Default_Flow_ProvinceDst uint32 = 0
const Default_Flow_CastTypeMap_0 uint32 = 0
const Default_Flow_CastTypeMap_1 uint32 = 0
const Default_Flow_TcpFlagsMap_0 uint32 = 0
const Default_Flow_TcpFlagsMap_1 uint32 = 0
const Default_Flow_TtlMap_0 uint32 = 0
const Default_Flow_TtlMap_1 uint32 = 0
const Default_Flow_PacketSizeMap_0 uint32 = 0
const Default_Flow_PacketSizeMap_1 uint32 = 0

func (m *Flow) GetVtapId() uint32 {
	if m != nil && m.VtapId != nil {
		return *m.VtapId
	}
	return 0
}

func (m *Flow) GetExporter() uint32 {
	if m != nil && m.Exporter != nil {
		return *m.Exporter
	}
	return 0
}

func (m *Flow) GetCloseType() uint32 {
	if m != nil && m.CloseType != nil {
		return *m.CloseType
	}
	return 0
}

func (m *Flow) GetFlowId() uint64 {
	if m != nil && m.FlowId != nil {
		return *m.FlowId
	}
	return 0
}

func (m *Flow) GetFlowSource() uint32 {
	if m != nil && m.FlowSource != nil {
		return *m.FlowSource
	}
	return 0
}

func (m *Flow) GetStartTime() uint32 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *Flow) GetEndTime() uint32 {
	if m != nil && m.EndTime != nil {
		return *m.EndTime
	}
	return 0
}

func (m *Flow) GetDuration() uint64 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

func (m *Flow) GetTapType() uint32 {
	if m != nil && m.TapType != nil {
		return *m.TapType
	}
	return Default_Flow_TapType
}

func (m *Flow) GetTapPort() uint32 {
	if m != nil && m.TapPort != nil {
		return *m.TapPort
	}
	return Default_Flow_TapPort
}

func (m *Flow) GetVlan() uint32 {
	if m != nil && m.Vlan != nil {
		return *m.Vlan
	}
	return Default_Flow_Vlan
}

func (m *Flow) GetEthType() uint32 {
	if m != nil && m.EthType != nil {
		return *m.EthType
	}
	return Default_Flow_EthType
}

func (m *Flow) GetMacSrc() uint64 {
	if m != nil && m.MacSrc != nil {
		return *m.MacSrc
	}
	return Default_Flow_MacSrc
}

func (m *Flow) GetMacDst() uint64 {
	if m != nil && m.MacDst != nil {
		return *m.MacDst
	}
	return Default_Flow_MacDst
}

func (m *Flow) GetIpSrc() uint32 {
	if m != nil && m.IpSrc != nil {
		return *m.IpSrc
	}
	return 0
}

func (m *Flow) GetIpDst() uint32 {
	if m != nil && m.IpDst != nil {
		return *m.IpDst
	}
	return 0
}

func (m *Flow) GetIp6Src() []byte {
	if m != nil {
		return m.Ip6Src
	}
	return nil
}

func (m *Flow) GetIp6Dst() []byte {
	if m != nil {
		return m.Ip6Dst
	}
	return nil
}

func (m *Flow) GetProto() uint32 {
	if m != nil && m.Proto != nil {
		return *m.Proto
	}
	return Default_Flow_Proto
}

func (m *Flow) GetPortSrc() uint32 {
	if m != nil && m.PortSrc != nil {
		return *m.PortSrc
	}
	return 0
}

func (m *Flow) GetPortDst() uint32 {
	if m != nil && m.PortDst != nil {
		return *m.PortDst
	}
	return 0
}

func (m *Flow) GetTcpFlags_0() uint32 {
	if m != nil && m.TcpFlags_0 != nil {
		return *m.TcpFlags_0
	}
	return Default_Flow_TcpFlags_0
}

func (m *Flow) GetTcpFlags_1() uint32 {
	if m != nil && m.TcpFlags_1 != nil {
		return *m.TcpFlags_1
	}
	return Default_Flow_TcpFlags_1
}

func (m *Flow) GetTunTxId() uint32 {
	if m != nil && m.TunTxId != nil {
		return *m.TunTxId
	}
	return Default_Flow_TunTxId
}

func (m *Flow) GetTunTxIp_0() uint32 {
	if m != nil && m.TunTxIp_0 != nil {
		return *m.TunTxIp_0
	}
	return Default_Flow_TunTxIp_0
}

func (m *Flow) GetTunTxIp_1() uint32 {
	if m != nil && m.TunTxIp_1 != nil {
		return *m.TunTxIp_1
	}
	return Default_Flow_TunTxIp_1
}

func (m *Flow) GetTunType() uint32 {
	if m != nil && m.TunType != nil {
		return *m.TunType
	}
	return Default_Flow_TunType
}

func (m *Flow) GetTunRxIp_0() uint32 {
	if m != nil && m.TunRxIp_0 != nil {
		return *m.TunRxIp_0
	}
	return Default_Flow_TunRxIp_0
}

func (m *Flow) GetTunRxIp_1() uint32 {
	if m != nil && m.TunRxIp_1 != nil {
		return *m.TunRxIp_1
	}
	return Default_Flow_TunRxIp_1
}

func (m *Flow) GetTunTier() uint32 {
	if m != nil && m.TunTier != nil {
		return *m.TunTier
	}
	return Default_Flow_TunTier
}

func (m *Flow) GetTunRxId() uint32 {
	if m != nil && m.TunRxId != nil {
		return *m.TunRxId
	}
	return Default_Flow_TunRxId
}

func (m *Flow) GetByteCnt_0() uint64 {
	if m != nil && m.ByteCnt_0 != nil {
		return *m.ByteCnt_0
	}
	return Default_Flow_ByteCnt_0
}

func (m *Flow) GetByteCnt_1() uint64 {
	if m != nil && m.ByteCnt_1 != nil {
		return *m.ByteCnt_1
	}
	return Default_Flow_ByteCnt_1
}

func (m *Flow) GetPktCnt_0() uint64 {
	if m != nil && m.PktCnt_0 != nil {
		return *m.PktCnt_0
	}
	return Default_Flow_PktCnt_0
}

func (m *Flow) GetPktCnt_1() uint64 {
	if m != nil && m.PktCnt_1 != nil {
		return *m.PktCnt_1
	}
	return Default_Flow_PktCnt_1
}

func (m *Flow) GetTotalByteCnt_0() uint64 {
	if m != nil && m.TotalByteCnt_0 != nil {
		return *m.TotalByteCnt_0
	}
	return Default_Flow_TotalByteCnt_0
}

func (m *Flow) GetTotalByteCnt_1() uint64 {
	if m != nil && m.TotalByteCnt_1 != nil {
		return *m.TotalByteCnt_1
	}
	return Default_Flow_TotalByteCnt_1
}

func (m *Flow) GetTotalPktCnt_0() uint64 {
	if m != nil && m.TotalPktCnt_0 != nil {
		return *m.TotalPktCnt_0
	}
	return Default_Flow_TotalPktCnt_0
}

func (m *Flow) GetTotalPktCnt_1() uint64 {
	if m != nil && m.TotalPktCnt_1 != nil {
		return *m.TotalPktCnt_1
	}
	return Default_Flow_TotalPktCnt_1
}

func (m *Flow) GetSubnetId_0() uint32 {
	if m != nil && m.SubnetId_0 != nil {
		return *m.SubnetId_0
	}
	return Default_Flow_SubnetId_0
}

func (m *Flow) GetSubnetId_1() uint32 {
	if m != nil && m.SubnetId_1 != nil {
		return *m.SubnetId_1
	}
	return Default_Flow_SubnetId_1
}

func (m *Flow) GetL3DeviceType_0() uint32 {
	if m != nil && m.L3DeviceType_0 != nil {
		return *m.L3DeviceType_0
	}
	return Default_Flow_L3DeviceType_0
}

func (m *Flow) GetL3DeviceType_1() uint32 {
	if m != nil && m.L3DeviceType_1 != nil {
		return *m.L3DeviceType_1
	}
	return Default_Flow_L3DeviceType_1
}

func (m *Flow) GetL3DeviceId_0() uint32 {
	if m != nil && m.L3DeviceId_0 != nil {
		return *m.L3DeviceId_0
	}
	return Default_Flow_L3DeviceId_0
}

func (m *Flow) GetL3DeviceId_1() uint32 {
	if m != nil && m.L3DeviceId_1 != nil {
		return *m.L3DeviceId_1
	}
	return Default_Flow_L3DeviceId_1
}

func (m *Flow) GetL3EpcId_0() uint32 {
	if m != nil && m.L3EpcId_0 != nil {
		return *m.L3EpcId_0
	}
	return Default_Flow_L3EpcId_0
}

func (m *Flow) GetL3EpcId_1() uint32 {
	if m != nil && m.L3EpcId_1 != nil {
		return *m.L3EpcId_1
	}
	return Default_Flow_L3EpcId_1
}

func (m *Flow) GetHost_0() uint32 {
	if m != nil && m.Host_0 != nil {
		return *m.Host_0
	}
	return 0
}

func (m *Flow) GetHost_1() uint32 {
	if m != nil && m.Host_1 != nil {
		return *m.Host_1
	}
	return 0
}

func (m *Flow) GetEpcId_0() uint32 {
	if m != nil && m.EpcId_0 != nil {
		return *m.EpcId_0
	}
	return Default_Flow_EpcId_0
}

func (m *Flow) GetEpcId_1() uint32 {
	if m != nil && m.EpcId_1 != nil {
		return *m.EpcId_1
	}
	return Default_Flow_EpcId_1
}

func (m *Flow) GetDeviceType_0() uint32 {
	if m != nil && m.DeviceType_0 != nil {
		return *m.DeviceType_0
	}
	return Default_Flow_DeviceType_0
}

func (m *Flow) GetDeviceType_1() uint32 {
	if m != nil && m.DeviceType_1 != nil {
		return *m.DeviceType_1
	}
	return Default_Flow_DeviceType_1
}

func (m *Flow) GetDeviceId_0() uint32 {
	if m != nil && m.DeviceId_0 != nil {
		return *m.DeviceId_0
	}
	return Default_Flow_DeviceId_0
}

func (m *Flow) GetDeviceId_1() uint32 {
	if m != nil && m.DeviceId_1 != nil {
		return *m.DeviceId_1
	}
	return Default_Flow_DeviceId_1
}

func (m *Flow) GetIsL2End_0() bool {
	if m != nil && m.IsL2End_0 != nil {
		return *m.IsL2End_0
	}
	return Default_Flow_IsL2End_0
}

func (m *Flow) GetIsL2End_1() bool {
	if m != nil && m.IsL2End_1 != nil {
		return *m.IsL2End_1
	}
	return Default_Flow_IsL2End_1
}

func (m *Flow) GetIsL3End_0() bool {
	if m != nil && m.IsL3End_0 != nil {
		return *m.IsL3End_0
	}
	return Default_Flow_IsL3End_0
}

func (m *Flow) GetIsL3End_1() bool {
	if m != nil && m.IsL3End_1 != nil {
		return *m.IsL3End_1
	}
	return Default_Flow_IsL3End_1
}

func (m *Flow) GetRttAvg() uint64 {
	if m != nil && m.RttAvg != nil {
		return *m.RttAvg
	}
	return Default_Flow_RttAvg
}

func (m *Flow) GetSrtAvg() uint64 {
	if m != nil && m.SrtAvg != nil {
		return *m.SrtAvg
	}
	return Default_Flow_SrtAvg
}

func (m *Flow) GetRetransCnt_0() uint64 {
	if m != nil && m.RetransCnt_0 != nil {
		return *m.RetransCnt_0
	}
	return Default_Flow_RetransCnt_0
}

func (m *Flow) GetRetransCnt_1() uint64 {
	if m != nil && m.RetransCnt_1 != nil {
		return *m.RetransCnt_1
	}
	return Default_Flow_RetransCnt_1
}

func (m *Flow) GetTotalRetransCnt() uint64 {
	if m != nil && m.TotalRetransCnt != nil {
		return *m.TotalRetransCnt
	}
	return Default_Flow_TotalRetransCnt
}

func (m *Flow) GetZeroWndCnt_0() uint64 {
	if m != nil && m.ZeroWndCnt_0 != nil {
		return *m.ZeroWndCnt_0
	}
	return Default_Flow_ZeroWndCnt_0
}

func (m *Flow) GetZeroWndCnt_1() uint64 {
	if m != nil && m.ZeroWndCnt_1 != nil {
		return *m.ZeroWndCnt_1
	}
	return Default_Flow_ZeroWndCnt_1
}

func (m *Flow) GetArtAvg() uint64 {
	if m != nil && m.ArtAvg != nil {
		return *m.ArtAvg
	}
	return Default_Flow_ArtAvg
}

func (m *Flow) GetRttClientAvg() uint64 {
	if m != nil && m.RttClientAvg != nil {
		return *m.RttClientAvg
	}
	return Default_Flow_RttClientAvg
}

func (m *Flow) GetRttServerAvg() uint64 {
	if m != nil && m.RttServerAvg != nil {
		return *m.RttServerAvg
	}
	return Default_Flow_RttServerAvg
}

func (m *Flow) GetProvinceSrc() uint32 {
	if m != nil && m.ProvinceSrc != nil {
		return *m.ProvinceSrc
	}
	return Default_Flow_ProvinceSrc
}

func (m *Flow) GetProvinceDst() uint32 {
	if m != nil && m.ProvinceDst != nil {
		return *m.ProvinceDst
	}
	return Default_Flow_ProvinceDst
}

func (m *Flow) GetCastTypeMap_0() uint32 {
	if m != nil && m.CastTypeMap_0 != nil {
		return *m.CastTypeMap_0
	}
	return Default_Flow_CastTypeMap_0
}

func (m *Flow) GetCastTypeMap_1() uint32 {
	if m != nil && m.CastTypeMap_1 != nil {
		return *m.CastTypeMap_1
	}
	return Default_Flow_CastTypeMap_1
}

func (m *Flow) GetTcpFlagsMap_0() uint32 {
	if m != nil && m.TcpFlagsMap_0 != nil {
		return *m.TcpFlagsMap_0
	}
	return Default_Flow_TcpFlagsMap_0
}

func (m *Flow) GetTcpFlagsMap_1() uint32 {
	if m != nil && m.TcpFlagsMap_1 != nil {
		return *m.TcpFlagsMap_1
	}
	return Default_Flow_TcpFlagsMap_1
}

func (m *Flow) GetTtlMap_0() uint32 {
	if m != nil && m.TtlMap_0 != nil {
		return *m.TtlMap_0
	}
	return Default_Flow_TtlMap_0
}

func (m *Flow) GetTtlMap_1() uint32 {
	if m != nil && m.TtlMap_1 != nil {
		return *m.TtlMap_1
	}
	return Default_Flow_TtlMap_1
}

func (m *Flow) GetPacketSizeMap_0() uint32 {
	if m != nil && m.PacketSizeMap_0 != nil {
		return *m.PacketSizeMap_0
	}
	return Default_Flow_PacketSizeMap_0
}

func (m *Flow) GetPacketSizeMap_1() uint32 {
	if m != nil && m.PacketSizeMap_1 != nil {
		return *m.PacketSizeMap_1
	}
	return Default_Flow_PacketSizeMap_1
}

type Metering struct {
	Exporter  *uint32 `protobuf:"varint,1,opt,name=exporter" json:"exporter,omitempty"`
	Timestamp *uint32 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	TapType   *uint32 `protobuf:"varint,3,opt,name=tap_type,json=tapType,def=0" json:"tap_type,omitempty"`
	TapPort   *uint32 `protobuf:"varint,4,opt,name=tap_port,json=tapPort,def=0" json:"tap_port,omitempty"`
	Vlan      *uint32 `protobuf:"varint,11,opt,name=vlan,def=0" json:"vlan,omitempty"`
	IpSrc     *uint32 `protobuf:"varint,21,opt,name=ip_src,json=ipSrc,def=0" json:"ip_src,omitempty"`
	IpDst     *uint32 `protobuf:"varint,22,opt,name=ip_dst,json=ipDst,def=0" json:"ip_dst,omitempty"`
	Proto     *uint32 `protobuf:"varint,31,opt,name=proto,def=0" json:"proto,omitempty"`
	PortSrc   *uint32 `protobuf:"varint,32,opt,name=port_src,json=portSrc,def=0" json:"port_src,omitempty"`
	PortDst   *uint32 `protobuf:"varint,33,opt,name=port_dst,json=portDst,def=0" json:"port_dst,omitempty"`
	ByteCnt_0 *uint64 `protobuf:"varint,41,opt,name=byte_cnt_0,json=byteCnt0,def=0" json:"byte_cnt_0,omitempty"`
	ByteCnt_1 *uint64 `protobuf:"varint,42,opt,name=byte_cnt_1,json=byteCnt1,def=0" json:"byte_cnt_1,omitempty"`
	PktCnt_0  *uint64 `protobuf:"varint,43,opt,name=pkt_cnt_0,json=pktCnt0,def=0" json:"pkt_cnt_0,omitempty"`
	PktCnt_1  *uint64 `protobuf:"varint,44,opt,name=pkt_cnt_1,json=pktCnt1,def=0" json:"pkt_cnt_1,omitempty"`
	// Platform Data
	L3EpcId_0            *uint32  `protobuf:"varint,51,opt,name=l3_epc_id_0,json=l3EpcId0,def=0" json:"l3_epc_id_0,omitempty"`
	L3EpcId_1            *uint32  `protobuf:"varint,52,opt,name=l3_epc_id_1,json=l3EpcId1,def=0" json:"l3_epc_id_1,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metering) Reset()         { *m = Metering{} }
func (m *Metering) String() string { return proto.CompactTextString(m) }
func (*Metering) ProtoMessage()    {}
func (*Metering) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{6}
}
func (m *Metering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metering.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metering.Merge(m, src)
}
func (m *Metering) XXX_Size() int {
	return m.Size()
}
func (m *Metering) XXX_DiscardUnknown() {
	xxx_messageInfo_Metering.DiscardUnknown(m)
}

var xxx_messageInfo_Metering proto.InternalMessageInfo

const Default_Metering_TapType uint32 = 0
const Default_Metering_TapPort uint32 = 0
const Default_Metering_Vlan uint32 = 0
const Default_Metering_IpSrc uint32 = 0
const Default_Metering_IpDst uint32 = 0
const Default_Metering_Proto uint32 = 0
const Default_Metering_PortSrc uint32 = 0
const Default_Metering_PortDst uint32 = 0
const Default_Metering_ByteCnt_0 uint64 = 0
const Default_Metering_ByteCnt_1 uint64 = 0
const Default_Metering_PktCnt_0 uint64 = 0
const Default_Metering_PktCnt_1 uint64 = 0
const Default_Metering_L3EpcId_0 uint32 = 0
const Default_Metering_L3EpcId_1 uint32 = 0

func (m *Metering) GetExporter() uint32 {
	if m != nil && m.Exporter != nil {
		return *m.Exporter
	}
	return 0
}

func (m *Metering) GetTimestamp() uint32 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *Metering) GetTapType() uint32 {
	if m != nil && m.TapType != nil {
		return *m.TapType
	}
	return Default_Metering_TapType
}

func (m *Metering) GetTapPort() uint32 {
	if m != nil && m.TapPort != nil {
		return *m.TapPort
	}
	return Default_Metering_TapPort
}

func (m *Metering) GetVlan() uint32 {
	if m != nil && m.Vlan != nil {
		return *m.Vlan
	}
	return Default_Metering_Vlan
}

func (m *Metering) GetIpSrc() uint32 {
	if m != nil && m.IpSrc != nil {
		return *m.IpSrc
	}
	return Default_Metering_IpSrc
}

func (m *Metering) GetIpDst() uint32 {
	if m != nil && m.IpDst != nil {
		return *m.IpDst
	}
	return Default_Metering_IpDst
}

func (m *Metering) GetProto() uint32 {
	if m != nil && m.Proto != nil {
		return *m.Proto
	}
	return Default_Metering_Proto
}

func (m *Metering) GetPortSrc() uint32 {
	if m != nil && m.PortSrc != nil {
		return *m.PortSrc
	}
	return Default_Metering_PortSrc
}

func (m *Metering) GetPortDst() uint32 {
	if m != nil && m.PortDst != nil {
		return *m.PortDst
	}
	return Default_Metering_PortDst
}

func (m *Metering) GetByteCnt_0() uint64 {
	if m != nil && m.ByteCnt_0 != nil {
		return *m.ByteCnt_0
	}
	return Default_Metering_ByteCnt_0
}

func (m *Metering) GetByteCnt_1() uint64 {
	if m != nil && m.ByteCnt_1 != nil {
		return *m.ByteCnt_1
	}
	return Default_Metering_ByteCnt_1
}

func (m *Metering) GetPktCnt_0() uint64 {
	if m != nil && m.PktCnt_0 != nil {
		return *m.PktCnt_0
	}
	return Default_Metering_PktCnt_0
}

func (m *Metering) GetPktCnt_1() uint64 {
	if m != nil && m.PktCnt_1 != nil {
		return *m.PktCnt_1
	}
	return Default_Metering_PktCnt_1
}

func (m *Metering) GetL3EpcId_0() uint32 {
	if m != nil && m.L3EpcId_0 != nil {
		return *m.L3EpcId_0
	}
	return Default_Metering_L3EpcId_0
}

func (m *Metering) GetL3EpcId_1() uint32 {
	if m != nil && m.L3EpcId_1 != nil {
		return *m.L3EpcId_1
	}
	return Default_Metering_L3EpcId_1
}

// 注意：message中的tag不要大于31，大于31以后key会多占用1个字节。
//  1. 字段delta_key表示记录该key和前一个包的该key的值的差量
//     假定所有差量都可能为负数，使用sint，当差值为0时不用记录
//  2. 字段key为null（has_key=0）表示该key和前一个包的该key的值相同
//  3. 字段key不为null（has_key=1）表示记录原始值
//  4. 每条网流的首包要记录所有key和delta_key
type EthernetHeader struct {
	DestinationAddress   *uint64  `protobuf:"varint,1,opt,name=destination_address,json=destinationAddress" json:"destination_address,omitempty"`
	SourceAddress        *uint64  `protobuf:"varint,2,opt,name=source_address,json=sourceAddress" json:"source_address,omitempty"`
	EtherType            *uint32  `protobuf:"varint,3,opt,name=ether_type,json=etherType" json:"ether_type,omitempty"`
	VlanTag              *uint32  `protobuf:"varint,4,opt,name=vlan_tag,json=vlanTag" json:"vlan_tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EthernetHeader) Reset()         { *m = EthernetHeader{} }
func (m *EthernetHeader) String() string { return proto.CompactTextString(m) }
func (*EthernetHeader) ProtoMessage()    {}
func (*EthernetHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{7}
}
func (m *EthernetHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EthernetHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EthernetHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EthernetHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthernetHeader.Merge(m, src)
}
func (m *EthernetHeader) XXX_Size() int {
	return m.Size()
}
func (m *EthernetHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_EthernetHeader.DiscardUnknown(m)
}

var xxx_messageInfo_EthernetHeader proto.InternalMessageInfo

func (m *EthernetHeader) GetDestinationAddress() uint64 {
	if m != nil && m.DestinationAddress != nil {
		return *m.DestinationAddress
	}
	return 0
}

func (m *EthernetHeader) GetSourceAddress() uint64 {
	if m != nil && m.SourceAddress != nil {
		return *m.SourceAddress
	}
	return 0
}

func (m *EthernetHeader) GetEtherType() uint32 {
	if m != nil && m.EtherType != nil {
		return *m.EtherType
	}
	return 0
}

func (m *EthernetHeader) GetVlanTag() uint32 {
	if m != nil && m.VlanTag != nil {
		return *m.VlanTag
	}
	return 0
}

type Ipv4Header struct {
	Version             *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	Ihl                 *uint32 `protobuf:"varint,2,opt,name=ihl" json:"ihl,omitempty"`
	Tos                 *uint32 `protobuf:"varint,3,opt,name=tos" json:"tos,omitempty"`
	TotalLength         *uint32 `protobuf:"varint,4,opt,name=total_length,json=totalLength" json:"total_length,omitempty"`
	DeltaIdentification *int32  `protobuf:"zigzag32,5,opt,name=delta_identification,json=deltaIdentification" json:"delta_identification,omitempty"`
	// flags is combined into fragment offset
	DeltaFragmentOffset *int32  `protobuf:"zigzag32,6,opt,name=delta_fragment_offset,json=deltaFragmentOffset" json:"delta_fragment_offset,omitempty"`
	Ttl                 *uint32 `protobuf:"varint,7,opt,name=ttl" json:"ttl,omitempty"`
	Protocol            *uint32 `protobuf:"varint,8,opt,name=protocol" json:"protocol,omitempty"`
	// ignore check_sum if it is correct
	HeaderChecksum *uint32 `protobuf:"varint,9,opt,name=header_checksum,json=headerChecksum" json:"header_checksum,omitempty"`
	// IP address always has 4B, use fixed encoding
	SourceAddress      *uint32 `protobuf:"fixed32,10,opt,name=source_address,json=sourceAddress" json:"source_address,omitempty"`
	DestinationAddress *uint32 `protobuf:"fixed32,11,opt,name=destination_address,json=destinationAddress" json:"destination_address,omitempty"`
	// 5.0不考虑IP option的压缩，直接将byte数组放在此处即可
	// options基本由byte组成，从wiki来看也没有压缩空间：
	// https://en.wikipedia.org/wiki/IPv4
	Options              []byte   `protobuf:"bytes,12,opt,name=options" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ipv4Header) Reset()         { *m = Ipv4Header{} }
func (m *Ipv4Header) String() string { return proto.CompactTextString(m) }
func (*Ipv4Header) ProtoMessage()    {}
func (*Ipv4Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{8}
}
func (m *Ipv4Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ipv4Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ipv4Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ipv4Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ipv4Header.Merge(m, src)
}
func (m *Ipv4Header) XXX_Size() int {
	return m.Size()
}
func (m *Ipv4Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Ipv4Header.DiscardUnknown(m)
}

var xxx_messageInfo_Ipv4Header proto.InternalMessageInfo

func (m *Ipv4Header) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Ipv4Header) GetIhl() uint32 {
	if m != nil && m.Ihl != nil {
		return *m.Ihl
	}
	return 0
}

func (m *Ipv4Header) GetTos() uint32 {
	if m != nil && m.Tos != nil {
		return *m.Tos
	}
	return 0
}

func (m *Ipv4Header) GetTotalLength() uint32 {
	if m != nil && m.TotalLength != nil {
		return *m.TotalLength
	}
	return 0
}

func (m *Ipv4Header) GetDeltaIdentification() int32 {
	if m != nil && m.DeltaIdentification != nil {
		return *m.DeltaIdentification
	}
	return 0
}

func (m *Ipv4Header) GetDeltaFragmentOffset() int32 {
	if m != nil && m.DeltaFragmentOffset != nil {
		return *m.DeltaFragmentOffset
	}
	return 0
}

func (m *Ipv4Header) GetTtl() uint32 {
	if m != nil && m.Ttl != nil {
		return *m.Ttl
	}
	return 0
}

func (m *Ipv4Header) GetProtocol() uint32 {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return 0
}

func (m *Ipv4Header) GetHeaderChecksum() uint32 {
	if m != nil && m.HeaderChecksum != nil {
		return *m.HeaderChecksum
	}
	return 0
}

func (m *Ipv4Header) GetSourceAddress() uint32 {
	if m != nil && m.SourceAddress != nil {
		return *m.SourceAddress
	}
	return 0
}

func (m *Ipv4Header) GetDestinationAddress() uint32 {
	if m != nil && m.DestinationAddress != nil {
		return *m.DestinationAddress
	}
	return 0
}

func (m *Ipv4Header) GetOptions() []byte {
	if m != nil {
		return m.Options
	}
	return nil
}

type TcpHeader struct {
	SourcePort                 *uint32 `protobuf:"varint,1,opt,name=source_port,json=sourcePort" json:"source_port,omitempty"`
	DestinationPort            *uint32 `protobuf:"varint,2,opt,name=destination_port,json=destinationPort" json:"destination_port,omitempty"`
	DeltaSequenceNumber        *int64  `protobuf:"zigzag64,3,opt,name=delta_sequence_number,json=deltaSequenceNumber" json:"delta_sequence_number,omitempty"`
	DeltaAcknowledgementNumber *int64  `protobuf:"zigzag64,4,opt,name=delta_acknowledgement_number,json=deltaAcknowledgementNumber" json:"delta_acknowledgement_number,omitempty"`
	DataOffset                 *uint32 `protobuf:"varint,5,opt,name=data_offset,json=dataOffset" json:"data_offset,omitempty"`
	Reserved                   *uint32 `protobuf:"varint,6,opt,name=reserved" json:"reserved,omitempty"`
	Flags                      *uint32 `protobuf:"varint,7,opt,name=flags" json:"flags,omitempty"`
	DeltaWindow                *int32  `protobuf:"zigzag32,8,opt,name=delta_window,json=deltaWindow" json:"delta_window,omitempty"`
	// checksum is ignored here                             2 B
	UrgentPointer *uint32 `protobuf:"varint,9,opt,name=urgent_pointer,json=urgentPointer" json:"urgent_pointer,omitempty"`
	// TCP option很常见的，由byte、u16、u32组成，且存在很多不确定性
	// 5.0考虑将TCP options分割成10个4字节word，仅记录差量
	// https://en.wikipedia.org/wiki/Transmission_Control_Protocol
	DeltaOption_0W       *int64   `protobuf:"zigzag64,10,opt,name=delta_option_0w,json=deltaOption0w" json:"delta_option_0w,omitempty"`
	DeltaOption_1W       *int64   `protobuf:"zigzag64,11,opt,name=delta_option_1w,json=deltaOption1w" json:"delta_option_1w,omitempty"`
	DeltaOption_2W       *int64   `protobuf:"zigzag64,12,opt,name=delta_option_2w,json=deltaOption2w" json:"delta_option_2w,omitempty"`
	DeltaOption_3W       *int64   `protobuf:"zigzag64,13,opt,name=delta_option_3w,json=deltaOption3w" json:"delta_option_3w,omitempty"`
	DeltaOption_4W       *int64   `protobuf:"zigzag64,14,opt,name=delta_option_4w,json=deltaOption4w" json:"delta_option_4w,omitempty"`
	DeltaOption_5W       *int64   `protobuf:"zigzag64,15,opt,name=delta_option_5w,json=deltaOption5w" json:"delta_option_5w,omitempty"`
	DeltaOption_6W       *int64   `protobuf:"zigzag64,16,opt,name=delta_option_6w,json=deltaOption6w" json:"delta_option_6w,omitempty"`
	DeltaOption_7W       *int64   `protobuf:"zigzag64,17,opt,name=delta_option_7w,json=deltaOption7w" json:"delta_option_7w,omitempty"`
	DeltaOption_8W       *int64   `protobuf:"zigzag64,18,opt,name=delta_option_8w,json=deltaOption8w" json:"delta_option_8w,omitempty"`
	DeltaOption_9W       *int64   `protobuf:"zigzag64,19,opt,name=delta_option_9w,json=deltaOption9w" json:"delta_option_9w,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpHeader) Reset()         { *m = TcpHeader{} }
func (m *TcpHeader) String() string { return proto.CompactTextString(m) }
func (*TcpHeader) ProtoMessage()    {}
func (*TcpHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{9}
}
func (m *TcpHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpHeader.Merge(m, src)
}
func (m *TcpHeader) XXX_Size() int {
	return m.Size()
}
func (m *TcpHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpHeader.DiscardUnknown(m)
}

var xxx_messageInfo_TcpHeader proto.InternalMessageInfo

func (m *TcpHeader) GetSourcePort() uint32 {
	if m != nil && m.SourcePort != nil {
		return *m.SourcePort
	}
	return 0
}

func (m *TcpHeader) GetDestinationPort() uint32 {
	if m != nil && m.DestinationPort != nil {
		return *m.DestinationPort
	}
	return 0
}

func (m *TcpHeader) GetDeltaSequenceNumber() int64 {
	if m != nil && m.DeltaSequenceNumber != nil {
		return *m.DeltaSequenceNumber
	}
	return 0
}

func (m *TcpHeader) GetDeltaAcknowledgementNumber() int64 {
	if m != nil && m.DeltaAcknowledgementNumber != nil {
		return *m.DeltaAcknowledgementNumber
	}
	return 0
}

func (m *TcpHeader) GetDataOffset() uint32 {
	if m != nil && m.DataOffset != nil {
		return *m.DataOffset
	}
	return 0
}

func (m *TcpHeader) GetReserved() uint32 {
	if m != nil && m.Reserved != nil {
		return *m.Reserved
	}
	return 0
}

func (m *TcpHeader) GetFlags() uint32 {
	if m != nil && m.Flags != nil {
		return *m.Flags
	}
	return 0
}

func (m *TcpHeader) GetDeltaWindow() int32 {
	if m != nil && m.DeltaWindow != nil {
		return *m.DeltaWindow
	}
	return 0
}

func (m *TcpHeader) GetUrgentPointer() uint32 {
	if m != nil && m.UrgentPointer != nil {
		return *m.UrgentPointer
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_0W() int64 {
	if m != nil && m.DeltaOption_0W != nil {
		return *m.DeltaOption_0W
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_1W() int64 {
	if m != nil && m.DeltaOption_1W != nil {
		return *m.DeltaOption_1W
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_2W() int64 {
	if m != nil && m.DeltaOption_2W != nil {
		return *m.DeltaOption_2W
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_3W() int64 {
	if m != nil && m.DeltaOption_3W != nil {
		return *m.DeltaOption_3W
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_4W() int64 {
	if m != nil && m.DeltaOption_4W != nil {
		return *m.DeltaOption_4W
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_5W() int64 {
	if m != nil && m.DeltaOption_5W != nil {
		return *m.DeltaOption_5W
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_6W() int64 {
	if m != nil && m.DeltaOption_6W != nil {
		return *m.DeltaOption_6W
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_7W() int64 {
	if m != nil && m.DeltaOption_7W != nil {
		return *m.DeltaOption_7W
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_8W() int64 {
	if m != nil && m.DeltaOption_8W != nil {
		return *m.DeltaOption_8W
	}
	return 0
}

func (m *TcpHeader) GetDeltaOption_9W() int64 {
	if m != nil && m.DeltaOption_9W != nil {
		return *m.DeltaOption_9W
	}
	return 0
}

type UdpHeader struct {
	SourcePort           *uint32  `protobuf:"varint,1,opt,name=source_port,json=sourcePort" json:"source_port,omitempty"`
	DestinationPort      *uint32  `protobuf:"varint,2,opt,name=destination_port,json=destinationPort" json:"destination_port,omitempty"`
	Length               *uint32  `protobuf:"varint,3,opt,name=length" json:"length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UdpHeader) Reset()         { *m = UdpHeader{} }
func (m *UdpHeader) String() string { return proto.CompactTextString(m) }
func (*UdpHeader) ProtoMessage()    {}
func (*UdpHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{10}
}
func (m *UdpHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UdpHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UdpHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UdpHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UdpHeader.Merge(m, src)
}
func (m *UdpHeader) XXX_Size() int {
	return m.Size()
}
func (m *UdpHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_UdpHeader.DiscardUnknown(m)
}

var xxx_messageInfo_UdpHeader proto.InternalMessageInfo

func (m *UdpHeader) GetSourcePort() uint32 {
	if m != nil && m.SourcePort != nil {
		return *m.SourcePort
	}
	return 0
}

func (m *UdpHeader) GetDestinationPort() uint32 {
	if m != nil && m.DestinationPort != nil {
		return *m.DestinationPort
	}
	return 0
}

func (m *UdpHeader) GetLength() uint32 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

type PacketHeader struct {
	DeltaTimestamp       *int64          `protobuf:"zigzag64,1,opt,name=delta_timestamp,json=deltaTimestamp" json:"delta_timestamp,omitempty"`
	Ethernet             *EthernetHeader `protobuf:"bytes,2,opt,name=ethernet" json:"ethernet,omitempty"`
	Ipv4                 *Ipv4Header     `protobuf:"bytes,3,opt,name=ipv4" json:"ipv4,omitempty"`
	Tcp                  *TcpHeader      `protobuf:"bytes,4,opt,name=tcp" json:"tcp,omitempty"`
	Udp                  *UdpHeader      `protobuf:"bytes,5,opt,name=udp" json:"udp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PacketHeader) Reset()         { *m = PacketHeader{} }
func (m *PacketHeader) String() string { return proto.CompactTextString(m) }
func (*PacketHeader) ProtoMessage()    {}
func (*PacketHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{11}
}
func (m *PacketHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PacketHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PacketHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PacketHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PacketHeader.Merge(m, src)
}
func (m *PacketHeader) XXX_Size() int {
	return m.Size()
}
func (m *PacketHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_PacketHeader.DiscardUnknown(m)
}

var xxx_messageInfo_PacketHeader proto.InternalMessageInfo

func (m *PacketHeader) GetDeltaTimestamp() int64 {
	if m != nil && m.DeltaTimestamp != nil {
		return *m.DeltaTimestamp
	}
	return 0
}

func (m *PacketHeader) GetEthernet() *EthernetHeader {
	if m != nil {
		return m.Ethernet
	}
	return nil
}

func (m *PacketHeader) GetIpv4() *Ipv4Header {
	if m != nil {
		return m.Ipv4
	}
	return nil
}

func (m *PacketHeader) GetTcp() *TcpHeader {
	if m != nil {
		return m.Tcp
	}
	return nil
}

func (m *PacketHeader) GetUdp() *UdpHeader {
	if m != nil {
		return m.Udp
	}
	return nil
}

// protobuf-message format
type FlowPktHdrBatch struct {
	Host      *uint32    `protobuf:"varint,1,opt,name=host" json:"host,omitempty"`
	FlowId    *uint64    `protobuf:"varint,2,opt,name=flow_id,json=flowId" json:"flow_id,omitempty"`
	Direction *Direction `protobuf:"varint,3,opt,name=direction,enum=DFI.Direction,def=0" json:"direction,omitempty"`
	Sequence  *uint32    `protobuf:"varint,4,opt,name=sequence" json:"sequence,omitempty"`
	// 连续多个PacketHeader序列化（压缩）以后的字节数组，最大长度为BUFFER_SIZE
	// 内存排布：header_0, ..., header_i, ..., header_n, 0xFF结束标记
	//
	//	header_i排布：compressed_header_size_i(1B), compressed_header_i
	CompressedHeaders    []byte   `protobuf:"bytes,5,opt,name=compressed_headers,json=compressedHeaders" json:"compressed_headers,omitempty"`
	CloseType            *uint32  `protobuf:"varint,6,opt,name=close_type,json=closeType" json:"close_type,omitempty"`
	Exporter             *uint32  `protobuf:"varint,7,opt,name=exporter" json:"exporter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowPktHdrBatch) Reset()         { *m = FlowPktHdrBatch{} }
func (m *FlowPktHdrBatch) String() string { return proto.CompactTextString(m) }
func (*FlowPktHdrBatch) ProtoMessage()    {}
func (*FlowPktHdrBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_65daf131049f2fbb, []int{12}
}
func (m *FlowPktHdrBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowPktHdrBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowPktHdrBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowPktHdrBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowPktHdrBatch.Merge(m, src)
}
func (m *FlowPktHdrBatch) XXX_Size() int {
	return m.Size()
}
func (m *FlowPktHdrBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowPktHdrBatch.DiscardUnknown(m)
}

var xxx_messageInfo_FlowPktHdrBatch proto.InternalMessageInfo

const Default_FlowPktHdrBatch_Direction Direction = Direction_FORWARD

func (m *FlowPktHdrBatch) GetHost() uint32 {
	if m != nil && m.Host != nil {
		return *m.Host
	}
	return 0
}

func (m *FlowPktHdrBatch) GetFlowId() uint64 {
	if m != nil && m.FlowId != nil {
		return *m.FlowId
	}
	return 0
}

func (m *FlowPktHdrBatch) GetDirection() Direction {
	if m != nil && m.Direction != nil {
		return *m.Direction
	}
	return Default_FlowPktHdrBatch_Direction
}

func (m *FlowPktHdrBatch) GetSequence() uint32 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func (m *FlowPktHdrBatch) GetCompressedHeaders() []byte {
	if m != nil {
		return m.CompressedHeaders
	}
	return nil
}

func (m *FlowPktHdrBatch) GetCloseType() uint32 {
	if m != nil && m.CloseType != nil {
		return *m.CloseType
	}
	return 0
}

func (m *FlowPktHdrBatch) GetExporter() uint32 {
	if m != nil && m.Exporter != nil {
		return *m.Exporter
	}
	return 0
}

func init() {
	proto.RegisterEnum("DFI.RequestType", RequestType_name, RequestType_value)
	proto.RegisterEnum("DFI.Direction", Direction_name, Direction_value)
	proto.RegisterType((*FlowHeader)(nil), "DFI.FlowHeader")
	proto.RegisterType((*OvsPort)(nil), "DFI.OvsPort")
	proto.RegisterType((*OvsTopology)(nil), "DFI.OvsTopology")
	proto.RegisterType((*Request)(nil), "DFI.Request")
	proto.RegisterType((*StreamHeader)(nil), "DFI.StreamHeader")
	proto.RegisterType((*Flow)(nil), "DFI.Flow")
	proto.RegisterType((*Metering)(nil), "DFI.Metering")
	proto.RegisterType((*EthernetHeader)(nil), "DFI.EthernetHeader")
	proto.RegisterType((*Ipv4Header)(nil), "DFI.Ipv4Header")
	proto.RegisterType((*TcpHeader)(nil), "DFI.TcpHeader")
	proto.RegisterType((*UdpHeader)(nil), "DFI.UdpHeader")
	proto.RegisterType((*PacketHeader)(nil), "DFI.PacketHeader")
	proto.RegisterType((*FlowPktHdrBatch)(nil), "DFI.FlowPktHdrBatch")
}

func init() { proto.RegisterFile("dfi.proto", fileDescriptor_65daf131049f2fbb) }

var fileDescriptor_65daf131049f2fbb = []byte{
	// 2280 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x98, 0x5b, 0x93, 0xdb, 0x48,
	0x15, 0xc7, 0xd1, 0x5c, 0x7c, 0x69, 0x5f, 0x66, 0x46, 0xd9, 0xec, 0xf6, 0x0e, 0xb9, 0x38, 0x86,
	0x24, 0x4e, 0x20, 0x13, 0x6b, 0x3c, 0x99, 0xec, 0xa6, 0x0a, 0xd8, 0x49, 0xc6, 0x93, 0x98, 0x4d,
	0x32, 0x53, 0x9a, 0x61, 0x03, 0xbc, 0xa8, 0x34, 0x52, 0xdb, 0x16, 0x23, 0x4b, 0x42, 0x6a, 0xdb,
	0x49, 0x58, 0x5e, 0xb8, 0xbc, 0x42, 0x71, 0xd9, 0xc7, 0x7d, 0xa1, 0x0a, 0x1e, 0xe1, 0x6b, 0x2c,
	0x77, 0xf8, 0x06, 0x54, 0x8a, 0x4f, 0x01, 0x2f, 0xd4, 0x39, 0xdd, 0x92, 0x25, 0xcb, 0xd9, 0x3c,
	0xf1, 0xa6, 0x3e, 0xff, 0x5f, 0x9f, 0xee, 0x3e, 0xa7, 0xa5, 0x3e, 0x2d, 0x52, 0xb6, 0xfb, 0xce,
	0x56, 0x10, 0xfa, 0xdc, 0x57, 0x97, 0xf7, 0x0f, 0x7a, 0x9b, 0xb7, 0x06, 0x0e, 0x1f, 0x8e, 0x4f,
	0xb7, 0x2c, 0x7f, 0x74, 0x7b, 0xe0, 0x0f, 0xfc, 0xdb, 0xa8, 0x9d, 0x8e, 0xfb, 0xd8, 0xc2, 0x06,
	0x3e, 0x89, 0x3e, 0xcd, 0x16, 0x21, 0x07, 0xae, 0x3f, 0x7d, 0xc4, 0x4c, 0x9b, 0x85, 0xea, 0x26,
	0x29, 0x45, 0xec, 0xfb, 0x63, 0xe6, 0x59, 0x8c, 0x2a, 0x8d, 0xa5, 0x56, 0x41, 0x4f, 0xda, 0xcd,
	0x8f, 0x49, 0xf1, 0x70, 0x12, 0x1d, 0xf9, 0x21, 0x57, 0xd7, 0xc9, 0xf2, 0xc8, 0xb4, 0xa8, 0xd2,
	0x50, 0x5a, 0x65, 0x1d, 0x1e, 0xd5, 0x77, 0x48, 0xd1, 0x0e, 0x8c, 0xc0, 0x0f, 0x39, 0x5d, 0x6a,
	0x28, 0xad, 0x9a, 0x5e, 0xb0, 0x03, 0x44, 0xaf, 0x92, 0xba, 0xe3, 0x71, 0x16, 0xf6, 0x4d, 0x8b,
	0x19, 0x9e, 0x39, 0x62, 0x74, 0x19, 0x7b, 0xd5, 0x12, 0xeb, 0x53, 0x73, 0xc4, 0xd4, 0xcb, 0xa4,
	0x72, 0x1a, 0x3a, 0xf6, 0x40, 0x32, 0x2b, 0xc8, 0x10, 0x61, 0x02, 0xa0, 0xa9, 0x91, 0xca, 0xe1,
	0x24, 0x3a, 0xf1, 0x03, 0xdf, 0xf5, 0x07, 0x2f, 0xd4, 0x26, 0x59, 0x85, 0xc1, 0x22, 0xaa, 0x34,
	0x96, 0x5b, 0x95, 0xed, 0xea, 0xd6, 0xfe, 0x41, 0x6f, 0x4b, 0x4e, 0x4f, 0x17, 0x52, 0xf3, 0x36,
	0x29, 0xea, 0x30, 0xf9, 0x88, 0xab, 0x5f, 0x26, 0x2b, 0xfc, 0x45, 0xc0, 0x70, 0xc6, 0xf5, 0xed,
	0x75, 0xa4, 0xa5, 0x76, 0xf2, 0x22, 0x60, 0x3a, 0xaa, 0xcd, 0x33, 0x52, 0x3d, 0xe6, 0x21, 0x33,
	0x47, 0x32, 0x1a, 0x17, 0x48, 0x99, 0x3b, 0x23, 0x16, 0x71, 0x73, 0x14, 0x60, 0x38, 0x8a, 0xfa,
	0xcc, 0x90, 0x89, 0xd5, 0x12, 0x8a, 0x49, 0x5b, 0xbd, 0x42, 0xaa, 0xa6, 0xc5, 0x1d, 0xdf, 0x33,
	0xfa, 0xae, 0x39, 0x88, 0xe8, 0x32, 0xea, 0x15, 0x61, 0x3b, 0x00, 0x53, 0xf3, 0x93, 0xf3, 0x64,
	0x05, 0x22, 0x0f, 0xa1, 0x9b, 0x70, 0x33, 0x30, 0x1c, 0x1b, 0xa7, 0x57, 0xd3, 0x0b, 0xd0, 0xec,
	0xd9, 0x30, 0x00, 0x7b, 0x0e, 0x4b, 0x61, 0xa1, 0x0c, 0x6a, 0xd2, 0x56, 0x2f, 0x12, 0x62, 0xb9,
	0x7e, 0xc4, 0x0c, 0x5c, 0x56, 0x11, 0xd5, 0x32, 0x5a, 0x60, 0x3d, 0xe0, 0xb3, 0xef, 0xfa, 0x53,
	0xf0, 0x59, 0x6a, 0x28, 0xad, 0x15, 0xbd, 0x00, 0xcd, 0x9e, 0x0d, 0x71, 0x46, 0x21, 0xf2, 0xc7,
	0xa1, 0xc5, 0x68, 0x19, 0x3b, 0x12, 0x30, 0x1d, 0xa3, 0x05, 0x1c, 0x47, 0xdc, 0x0c, 0xb9, 0x01,
	0x0b, 0xa5, 0x15, 0xe1, 0x18, 0x2d, 0x27, 0xce, 0x88, 0xa9, 0xef, 0x92, 0x12, 0xf3, 0x6c, 0x21,
	0x56, 0x51, 0x2c, 0x32, 0xcf, 0x46, 0x69, 0x93, 0x94, 0xec, 0x71, 0x68, 0xc2, 0x0a, 0x69, 0x0d,
	0x07, 0x4d, 0xda, 0xea, 0x05, 0x52, 0x82, 0x25, 0xe2, 0x64, 0xcf, 0x43, 0xb7, 0x7b, 0x4a, 0x5b,
	0x2f, 0x72, 0x33, 0xc0, 0xd9, 0x4a, 0x15, 0x77, 0xcf, 0xdb, 0x69, 0x15, 0x77, 0xd0, 0x79, 0xb2,
	0x32, 0x71, 0x4d, 0x8f, 0x5e, 0x8e, 0x15, 0x6c, 0x42, 0x27, 0xc6, 0x87, 0xc2, 0x65, 0x23, 0xe9,
	0xc4, 0xf8, 0x10, 0x5d, 0x6e, 0x92, 0xe2, 0xc8, 0xb4, 0x8c, 0x28, 0xb4, 0xe8, 0x15, 0x98, 0x0b,
	0x88, 0x85, 0x91, 0x69, 0x1d, 0x87, 0x56, 0xac, 0xd9, 0x11, 0xa7, 0xcd, 0xb4, 0xb6, 0x1f, 0xc1,
	0x60, 0x05, 0x27, 0xc0, 0x6e, 0x37, 0x70, 0x75, 0xab, 0x4e, 0x00, 0x5d, 0x84, 0x19, 0x7a, 0xdc,
	0x8c, 0xcd, 0x40, 0xbf, 0x43, 0x8a, 0x4e, 0xb0, 0x8b, 0xf8, 0xad, 0x86, 0xd2, 0xaa, 0xea, 0x05,
	0x27, 0xd8, 0x05, 0x5e, 0x0a, 0xd0, 0x61, 0x2b, 0x11, 0x44, 0x8f, 0x55, 0x7c, 0xef, 0x68, 0x27,
	0x9e, 0xb2, 0x68, 0x43, 0x60, 0x61, 0xfd, 0xe8, 0x6b, 0x47, 0x04, 0x16, 0xda, 0xe0, 0x2c, 0x96,
	0xc0, 0xdb, 0x9d, 0x99, 0x04, 0xee, 0xae, 0x90, 0x0a, 0xb7, 0x02, 0xb1, 0xc9, 0x8c, 0x36, 0xdd,
	0x8d, 0x9d, 0x96, 0xb9, 0x15, 0xe0, 0x36, 0x6b, 0x67, 0x11, 0x8d, 0xde, 0xcd, 0x21, 0x9a, 0x7a,
	0x91, 0x94, 0xf9, 0xd8, 0x33, 0xf8, 0x73, 0xd8, 0x2f, 0x5f, 0x9b, 0x25, 0x60, 0xec, 0x9d, 0x3c,
	0xef, 0xd9, 0x6a, 0x83, 0x54, 0x62, 0x39, 0x30, 0xda, 0xf4, 0xeb, 0x31, 0x50, 0x12, 0x40, 0xd0,
	0xce, 0x12, 0x1a, 0xfd, 0xc6, 0x3c, 0xa1, 0x61, 0x8a, 0x81, 0x80, 0x6c, 0x7d, 0x90, 0x19, 0x01,
	0xb2, 0x25, 0xfb, 0x87, 0x72, 0x84, 0xbd, 0x74, 0x7f, 0x3d, 0x3d, 0x42, 0x28, 0x47, 0xb8, 0x3f,
	0x4f, 0xcc, 0x46, 0x70, 0x58, 0x48, 0x1f, 0x64, 0x46, 0x70, 0xf0, 0x7d, 0x29, 0xc7, 0xfd, 0x6d,
	0xba, 0x9f, 0x96, 0xf5, 0xe7, 0xf8, 0x5a, 0x90, 0xd3, 0x17, 0x9c, 0x19, 0x96, 0xc7, 0x8d, 0x36,
	0x7d, 0x18, 0xef, 0x8a, 0x12, 0x18, 0x1f, 0x78, 0xbc, 0x9d, 0x01, 0x34, 0xfa, 0x68, 0x1e, 0xc0,
	0x18, 0x06, 0x67, 0x5c, 0x3a, 0xe8, 0xc5, 0x7a, 0x31, 0x38, 0xe3, 0xd8, 0x3f, 0x25, 0x6b, 0xf4,
	0x9b, 0x73, 0xb2, 0xa6, 0xde, 0x24, 0xeb, 0xdc, 0xe7, 0xa6, 0x6b, 0xa4, 0x66, 0xf1, 0x61, 0x4c,
	0xd5, 0x50, 0xba, 0x1f, 0x4f, 0x25, 0xcf, 0x6a, 0xf4, 0xf1, 0x42, 0x56, 0x53, 0x5b, 0x64, 0x4d,
	0xb0, 0xb3, 0xb9, 0x3d, 0x89, 0xd1, 0x2a, 0x2a, 0x47, 0x72, 0x82, 0x39, 0x52, 0xa3, 0x4f, 0x17,
	0x91, 0x1a, 0x6c, 0xa8, 0x68, 0x7c, 0xea, 0x31, 0x6e, 0x38, 0xb6, 0xd1, 0xa6, 0x76, 0xb2, 0xa1,
	0x84, 0xb5, 0x67, 0xb7, 0xb3, 0x88, 0x46, 0x59, 0x0e, 0xc1, 0x15, 0xbb, 0x1d, 0xc3, 0x66, 0x13,
	0xc7, 0x12, 0x1f, 0x31, 0xa3, 0x4d, 0xfb, 0x31, 0x57, 0x73, 0x3b, 0xfb, 0xa8, 0xc0, 0xee, 0x68,
	0x2f, 0x60, 0x35, 0x3a, 0x58, 0xc8, 0x6a, 0xea, 0x35, 0x52, 0x9f, 0xb1, 0x38, 0xc1, 0x61, 0x4c,
	0x56, 0x62, 0x12, 0xa6, 0x38, 0xcf, 0x69, 0xd4, 0x59, 0xc0, 0x69, 0xb0, 0xf1, 0xdc, 0x8e, 0xc1,
	0x02, 0x4b, 0x38, 0xfb, 0x5e, 0xb2, 0xf1, 0xdc, 0x4e, 0x37, 0xb0, 0xc0, 0x53, 0x86, 0xd0, 0xe8,
	0xd9, 0x3c, 0xa1, 0xc1, 0xd7, 0x63, 0xe8, 0x47, 0x10, 0x7c, 0x57, 0x7c, 0x3d, 0xa0, 0xd5, 0x4e,
	0xcc, 0x1a, 0x1d, 0xcd, 0xcc, 0x9a, 0xfa, 0x45, 0x52, 0x4a, 0x86, 0x7b, 0x1e, 0x3b, 0x2b, 0x30,
	0x31, 0xd8, 0x4c, 0xd4, 0xe8, 0x8b, 0xac, 0xa8, 0xa9, 0x57, 0x49, 0x2d, 0x1b, 0xd0, 0x97, 0xc9,
	0x92, 0xec, 0x54, 0x38, 0xe7, 0x30, 0x8d, 0xfe, 0x60, 0x01, 0x86, 0x79, 0x4e, 0x87, 0xf1, 0xe3,
	0x24, 0x89, 0x76, 0x12, 0xc4, 0x0c, 0xa2, 0xd1, 0x1f, 0xe6, 0x10, 0x98, 0x53, 0xc5, 0x89, 0x0c,
	0x77, 0xdb, 0x80, 0x63, 0xa3, 0x4d, 0x7f, 0x04, 0x47, 0x5c, 0xe9, 0xde, 0x6a, 0xdf, 0x74, 0x23,
	0xa6, 0x97, 0x9c, 0xe8, 0xf1, 0x76, 0xd7, 0xb3, 0xdb, 0x59, 0x4c, 0xa3, 0x3f, 0x5e, 0x88, 0x25,
	0xde, 0x3a, 0xd2, 0xdb, 0x4f, 0x72, 0x58, 0x27, 0xed, 0xad, 0x23, 0xbd, 0xfd, 0x74, 0x21, 0x06,
	0x91, 0x2e, 0x86, 0x9c, 0x1b, 0xe6, 0x64, 0x40, 0x7f, 0xa6, 0x24, 0x27, 0x41, 0xc8, 0xf9, 0xde,
	0x64, 0x00, 0x62, 0x14, 0x0a, 0xf1, 0xe7, 0x33, 0x31, 0x0a, 0x51, 0xbc, 0x46, 0x6a, 0x21, 0xe3,
	0xa1, 0xe9, 0x45, 0xf2, 0xad, 0xfa, 0x45, 0x82, 0x54, 0xa4, 0x80, 0x6f, 0xd5, 0x1c, 0xa7, 0xd1,
	0x5f, 0x2e, 0xe2, 0x34, 0x75, 0x8b, 0x6c, 0x88, 0xb7, 0x2f, 0x45, 0xd3, 0x5f, 0x25, 0xac, 0x78,
	0x35, 0xf5, 0xa4, 0x83, 0x7a, 0x9d, 0xd4, 0x5f, 0xb2, 0xd0, 0x37, 0xa6, 0x9e, 0x2d, 0x27, 0xf0,
	0xeb, 0x99, 0x63, 0x50, 0x9e, 0x79, 0x36, 0x4e, 0x60, 0x1e, 0xd4, 0xe8, 0x27, 0x8b, 0x40, 0x8c,
	0x85, 0x29, 0x97, 0xfb, 0xe9, 0x6c, 0xb9, 0xa6, 0x58, 0x6e, 0x8b, 0xd4, 0x21, 0x50, 0x96, 0xeb,
	0x30, 0x4f, 0x30, 0xbf, 0x4d, 0x98, 0x6a, 0xc8, 0xf9, 0x03, 0x14, 0x52, 0x64, 0xc4, 0xc2, 0x09,
	0x0b, 0x91, 0xfc, 0x5d, 0x86, 0x3c, 0x46, 0x01, 0xc8, 0xab, 0xa4, 0x1a, 0x84, 0xfe, 0xc4, 0xf1,
	0x2c, 0x86, 0x87, 0xde, 0xef, 0x95, 0x64, 0x17, 0xc6, 0x76, 0x38, 0xfc, 0xd2, 0x18, 0x1c, 0x80,
	0x7f, 0xc8, 0x63, 0x70, 0x10, 0xde, 0x20, 0x6b, 0x96, 0x19, 0x71, 0xb1, 0xa3, 0x47, 0x26, 0x9c,
	0x22, 0x9f, 0x25, 0x64, 0x15, 0x24, 0xd8, 0xd4, 0x4f, 0xcc, 0xa0, 0x9d, 0x47, 0x35, 0xfa, 0xc7,
	0x85, 0xa8, 0x06, 0xe8, 0xec, 0xec, 0x14, 0x5e, 0xff, 0x34, 0x43, 0xe3, 0x03, 0x34, 0xf6, 0x9a,
	0x45, 0x35, 0xfa, 0xe7, 0x85, 0xa8, 0xa6, 0x5e, 0x22, 0x65, 0xce, 0x5d, 0xe9, 0xef, 0x2f, 0xca,
	0xec, 0x30, 0xe2, 0x2e, 0xba, 0x4a, 0xe9, 0x1a, 0xfd, 0xeb, 0xbc, 0xae, 0xa9, 0xb7, 0xc8, 0x46,
	0x60, 0x5a, 0x67, 0x8c, 0x1b, 0x91, 0xf3, 0x32, 0x5e, 0xed, 0xdf, 0x12, 0xae, 0x2e, 0xc4, 0x63,
	0xe7, 0xa5, 0x58, 0xef, 0x02, 0x5c, 0xa3, 0x7f, 0x7f, 0x0d, 0xae, 0x35, 0xff, 0xbd, 0x4c, 0x4a,
	0x4f, 0x18, 0x67, 0xa1, 0xe3, 0x0d, 0x32, 0x25, 0xa8, 0x32, 0x57, 0x82, 0x66, 0xaa, 0x63, 0x51,
	0x9f, 0xa6, 0xaa, 0xe3, 0x74, 0xc5, 0xb7, 0xfc, 0xb9, 0x15, 0xdf, 0xca, 0x6b, 0x2b, 0xbe, 0x4a,
	0xb6, 0xe2, 0xa3, 0x49, 0x6d, 0x96, 0x94, 0x90, 0xb2, 0x3c, 0xa3, 0x49, 0x79, 0xf6, 0x76, 0x4a,
	0xc9, 0xd4, 0x5b, 0x97, 0xe7, 0xea, 0xad, 0x0b, 0xa9, 0x7a, 0x6b, 0x56, 0x3e, 0xc6, 0x25, 0xd7,
	0x85, 0x54, 0xc9, 0x75, 0x25, 0xa3, 0x82, 0xd3, 0x6c, 0xb5, 0x70, 0xe3, 0x4d, 0xd5, 0xc2, 0xcd,
	0x37, 0x54, 0x0b, 0x5f, 0xf9, 0xfc, 0x6a, 0xe1, 0xab, 0xb9, 0x6a, 0x61, 0xee, 0x4c, 0xea, 0xbc,
	0xf1, 0x4c, 0xda, 0xc9, 0x9d, 0x49, 0xcd, 0xdf, 0x28, 0xa4, 0xde, 0xe5, 0x43, 0x16, 0x7a, 0x8c,
	0xcb, 0xeb, 0xce, 0x6d, 0x72, 0xce, 0x66, 0x11, 0x77, 0x3c, 0xac, 0xd9, 0x0d, 0xd3, 0xb6, 0x43,
	0x16, 0x45, 0x98, 0xf7, 0x15, 0x5d, 0x4d, 0x49, 0x7b, 0x42, 0x81, 0xbb, 0x9d, 0xb8, 0x47, 0x24,
	0xec, 0x12, 0xb2, 0x35, 0x61, 0x8d, 0xb1, 0x8b, 0x84, 0x30, 0x18, 0x29, 0xb5, 0x19, 0xf4, 0x32,
	0x5a, 0x70, 0x2f, 0xbc, 0x4b, 0x4a, 0x90, 0x5e, 0x83, 0x9b, 0x03, 0xb1, 0x17, 0xf4, 0x22, 0xb4,
	0x4f, 0xcc, 0x41, 0xf3, 0xd3, 0x65, 0x42, 0x7a, 0xc1, 0x64, 0x47, 0x4e, 0x90, 0x92, 0xe2, 0x84,
	0x85, 0x11, 0x5c, 0x30, 0x14, 0x09, 0x8a, 0x26, 0x5c, 0x48, 0x9d, 0xa1, 0x2b, 0x77, 0x21, 0x3c,
	0x82, 0x85, 0xfb, 0x91, 0x1c, 0x0d, 0x1e, 0xe1, 0x4e, 0x26, 0xbe, 0xb1, 0x2e, 0xf3, 0x06, 0x7c,
	0x28, 0xc7, 0xaa, 0xa0, 0xed, 0x31, 0x9a, 0x54, 0x8d, 0xbc, 0x65, 0x33, 0x97, 0x9b, 0x86, 0x63,
	0x33, 0x8f, 0x3b, 0x7d, 0xc7, 0x12, 0xd7, 0x99, 0xd5, 0x86, 0xd2, 0xda, 0xd0, 0xcf, 0xa1, 0xd6,
	0xcb, 0x48, 0xea, 0x36, 0x39, 0x2f, 0xba, 0xf4, 0x43, 0x73, 0x30, 0x82, 0xcf, 0xa3, 0xdf, 0xef,
	0x47, 0x8c, 0xd3, 0x42, 0xaa, 0xcf, 0x81, 0xd4, 0x0e, 0x51, 0xc2, 0xb9, 0x71, 0x57, 0xde, 0xda,
	0xe0, 0x11, 0xde, 0x33, 0xdc, 0x96, 0x96, 0xef, 0xe2, 0x85, 0xad, 0xa6, 0x27, 0x6d, 0xf5, 0x3a,
	0x59, 0x1b, 0xe2, 0xfa, 0x0d, 0x6b, 0xc8, 0xac, 0xb3, 0x68, 0x3c, 0x92, 0xd7, 0xb6, 0xba, 0x30,
	0x3f, 0x90, 0xd6, 0x05, 0xe9, 0x20, 0x0d, 0xa5, 0x55, 0x9c, 0x4f, 0xc7, 0x6b, 0xd2, 0x5c, 0x41,
	0x76, 0x51, 0x9a, 0x29, 0x29, 0xfa, 0x01, 0x18, 0x22, 0xbc, 0xf2, 0x55, 0xf5, 0xb8, 0xd9, 0xfc,
	0xcf, 0x2a, 0x29, 0x9f, 0x58, 0x81, 0x4c, 0xcf, 0x65, 0x52, 0x91, 0xe3, 0xe3, 0x7b, 0x2d, 0x52,
	0x44, 0x84, 0x09, 0xdf, 0xeb, 0x1b, 0x64, 0x3d, 0x3d, 0x72, 0xea, 0x6f, 0xc1, 0x5a, 0xca, 0x8e,
	0x68, 0x12, 0xd6, 0xf8, 0x4a, 0x6d, 0x78, 0xe3, 0xd1, 0x29, 0x0b, 0x31, 0xa1, 0xaa, 0x0c, 0xeb,
	0xb1, 0xd4, 0x9e, 0xa2, 0xa4, 0x7e, 0x40, 0x2e, 0x88, 0x3e, 0xa6, 0x75, 0xe6, 0xf9, 0x53, 0x97,
	0xd9, 0x03, 0x86, 0x19, 0x91, 0x5d, 0x57, 0xb0, 0xeb, 0x26, 0x32, 0x7b, 0x59, 0x44, 0x7a, 0xb8,
	0x4c, 0x2a, 0xb6, 0xc9, 0xcd, 0x38, 0x85, 0xab, 0x62, 0x05, 0x60, 0x92, 0x99, 0xdb, 0x24, 0xa5,
	0x90, 0xe1, 0xe1, 0x66, 0x63, 0x82, 0x6b, 0x7a, 0xd2, 0x56, 0xdf, 0x22, 0xab, 0xe2, 0xb2, 0x2f,
	0xf2, 0x2a, 0x1a, 0xb0, 0xeb, 0xc4, 0xa4, 0xa6, 0x8e, 0x67, 0xfb, 0x53, 0xcc, 0xee, 0x06, 0x14,
	0x5a, 0x2e, 0x37, 0x9f, 0xa1, 0x09, 0xf2, 0x36, 0x0e, 0x07, 0x30, 0xd1, 0xc0, 0xc7, 0xbf, 0x22,
	0x32, 0xbf, 0x35, 0x61, 0x3d, 0x12, 0x46, 0xf5, 0x1a, 0x59, 0x13, 0x9e, 0x44, 0xf4, 0x8d, 0xf6,
	0x14, 0xf3, 0xab, 0xea, 0x35, 0x34, 0x1f, 0xa2, 0xb5, 0x3d, 0xcd, 0x71, 0xda, 0x14, 0x73, 0x9b,
	0xe5, 0xb4, 0x3c, 0xb7, 0x3d, 0xc5, 0xf4, 0x66, 0xb9, 0xed, 0x3c, 0xd7, 0x99, 0xe2, 0xf5, 0x3e,
	0xcb, 0x75, 0xf2, 0xdc, 0xce, 0x94, 0xd6, 0x73, 0xdc, 0x4e, 0x9e, 0xbb, 0x33, 0xa5, 0x6b, 0x39,
	0xee, 0x4e, 0x9e, 0xdb, 0x9d, 0xd2, 0xf5, 0x1c, 0xb7, 0x9b, 0xe7, 0xee, 0x4e, 0xe9, 0x46, 0x8e,
	0xbb, 0x9b, 0xe7, 0xde, 0x9b, 0x52, 0x35, 0xc7, 0xbd, 0x97, 0xe7, 0xde, 0x9f, 0xd2, 0x73, 0x39,
	0xee, 0xfd, 0x69, 0xd3, 0x27, 0xe5, 0x6f, 0xd9, 0xff, 0x8f, 0xbd, 0xff, 0x36, 0x29, 0xc8, 0x4f,
	0x94, 0xf8, 0x7a, 0xc9, 0x56, 0xf3, 0x9f, 0x0a, 0xa9, 0x1e, 0xe1, 0x61, 0x2d, 0x07, 0xbd, 0x1e,
	0xcf, 0x34, 0xfd, 0x97, 0x0a, 0x66, 0x5a, 0x47, 0xf3, 0x49, 0x72, 0x18, 0xdf, 0xc6, 0x7f, 0x25,
	0xf8, 0xad, 0xc7, 0x41, 0x2b, 0xdb, 0xe7, 0xf0, 0x17, 0x58, 0xf6, 0x00, 0xd0, 0x13, 0x48, 0xfd,
	0x12, 0x59, 0x71, 0x82, 0xc9, 0x0e, 0x4e, 0xa0, 0xb2, 0xbd, 0x86, 0xf0, 0xec, 0x43, 0xac, 0xa3,
	0xa8, 0x36, 0xc8, 0x32, 0xb7, 0x02, 0x7c, 0xad, 0x2a, 0xdb, 0x75, 0x64, 0x92, 0x8f, 0x81, 0x0e,
	0x12, 0x10, 0x63, 0x3b, 0xc0, 0xf7, 0x28, 0x26, 0x92, 0x90, 0xe9, 0x20, 0x35, 0xff, 0xab, 0x90,
	0xb5, 0x03, 0xd7, 0x9f, 0x1e, 0x9d, 0xf1, 0x47, 0x76, 0x78, 0xdf, 0xe4, 0xd6, 0x50, 0x55, 0xc9,
	0x0a, 0xdc, 0x84, 0x64, 0x10, 0xf1, 0x39, 0xfd, 0x43, 0x6b, 0x29, 0xf3, 0x43, 0xeb, 0x0e, 0x29,
	0xdb, 0x4e, 0xc8, 0xf0, 0xc7, 0x1a, 0x4e, 0xb7, 0x2e, 0x07, 0xda, 0x8f, 0xad, 0xf7, 0x8a, 0x07,
	0x87, 0xfa, 0xb3, 0x3d, 0x7d, 0x5f, 0x9f, 0x91, 0x99, 0x9f, 0x77, 0xe2, 0x20, 0x98, 0xfd, 0xbc,
	0xbb, 0x45, 0x54, 0xcb, 0x1f, 0x05, 0xf0, 0xed, 0x63, 0xb6, 0x21, 0x3e, 0xb2, 0x11, 0x2e, 0xa2,
	0xaa, 0x6f, 0xcc, 0x14, 0xb1, 0x8c, 0x68, 0xee, 0x57, 0x5c, 0x61, 0xfe, 0x57, 0x5c, 0xba, 0x84,
	0x2a, 0x66, 0x4b, 0xa8, 0x9b, 0xdf, 0x26, 0x95, 0xd4, 0x5f, 0x48, 0x75, 0x8d, 0x54, 0x0e, 0x1e,
	0x1f, 0x3e, 0x33, 0x1e, 0x75, 0xf7, 0xf6, 0xbb, 0xfa, 0xba, 0xa2, 0xae, 0x93, 0xea, 0xe1, 0x47,
	0xc7, 0xc6, 0xc9, 0xe1, 0xd1, 0xe1, 0xe3, 0xc3, 0x87, 0xdf, 0x59, 0x5f, 0x52, 0x37, 0x48, 0xed,
	0x68, 0xef, 0xc1, 0x87, 0xdd, 0x93, 0x18, 0x5a, 0x56, 0xcf, 0x91, 0xb5, 0x27, 0xdd, 0x93, 0xae,
	0xde, 0x7b, 0xfa, 0x30, 0x36, 0xae, 0xdc, 0xbc, 0x4a, 0xca, 0x49, 0x00, 0xd4, 0x0a, 0x89, 0x43,
	0xb0, 0xfe, 0x05, 0x68, 0xe8, 0xdd, 0x8f, 0xba, 0xfa, 0x71, 0x77, 0x5d, 0xb9, 0xbf, 0xfb, 0xd9,
	0xab, 0x4b, 0xca, 0x3f, 0x5e, 0x5d, 0x52, 0xfe, 0xf5, 0xea, 0x92, 0x42, 0xde, 0xb1, 0xbc, 0x2d,
	0x8f, 0xf1, 0x2d, 0x9b, 0xb1, 0x00, 0xc2, 0xbb, 0x35, 0x62, 0x51, 0x64, 0x0e, 0xd8, 0x7d, 0xb2,
	0x7f, 0xd0, 0x7b, 0x22, 0x9e, 0xbf, 0xbb, 0x6c, 0xf7, 0x9d, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff,
	0x2a, 0x36, 0xa3, 0xc4, 0x75, 0x16, 0x00, 0x00,
}

func (m *FlowHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sequence == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("sequence")
	} else {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Sequence))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *OvsPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OvsPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OvsPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BridgeName != nil {
		i -= len(*m.BridgeName)
		copy(dAtA[i:], *m.BridgeName)
		i = encodeVarintDfi(dAtA, i, uint64(len(*m.BridgeName)))
		i--
		dAtA[i] = 0x22
	}
	if m.InterfaceName != nil {
		i -= len(*m.InterfaceName)
		copy(dAtA[i:], *m.InterfaceName)
		i = encodeVarintDfi(dAtA, i, uint64(len(*m.InterfaceName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DpPort != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.DpPort))
		i--
		dAtA[i] = 0x10
	}
	if m.Mac != nil {
		i -= len(*m.Mac)
		copy(dAtA[i:], *m.Mac)
		i = encodeVarintDfi(dAtA, i, uint64(len(*m.Mac)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OvsTopology) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OvsTopology) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OvsTopology) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDfi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StreamHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ActionFlags == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("action_flags")
	} else {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.ActionFlags))
		i--
		dAtA[i] = 0x1d
	}
	if m.Sequence == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("sequence")
	} else {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Sequence))
		i--
		dAtA[i] = 0x15
	}
	if m.Timestamp == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("timestamp")
	} else {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Timestamp))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *Flow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PacketSizeMap_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PacketSizeMap_1))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf8
	}
	if m.PacketSizeMap_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PacketSizeMap_0))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf0
	}
	if m.TtlMap_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TtlMap_1))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe8
	}
	if m.TtlMap_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TtlMap_0))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpFlagsMap_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TcpFlagsMap_1))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpFlagsMap_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TcpFlagsMap_0))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd0
	}
	if m.CastTypeMap_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.CastTypeMap_1))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc8
	}
	if m.CastTypeMap_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.CastTypeMap_0))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc0
	}
	if m.ProvinceDst != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.ProvinceDst))
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xf8
	}
	if m.ProvinceSrc != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.ProvinceSrc))
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xf0
	}
	if m.RttServerAvg != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.RttServerAvg))
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xb0
	}
	if m.RttClientAvg != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.RttClientAvg))
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xa8
	}
	if m.ArtAvg != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.ArtAvg))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xe8
	}
	if m.ZeroWndCnt_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.ZeroWndCnt_1))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xa8
	}
	if m.ZeroWndCnt_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.ZeroWndCnt_0))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0xa0
	}
	if m.TotalRetransCnt != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TotalRetransCnt))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x98
	}
	if m.RetransCnt_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.RetransCnt_1))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x90
	}
	if m.RetransCnt_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.RetransCnt_0))
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x88
	}
	if m.SrtAvg != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.SrtAvg))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xf8
	}
	if m.RttAvg != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.RttAvg))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xf0
	}
	if m.IsL3End_1 != nil {
		i--
		if *m.IsL3End_1 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa8
	}
	if m.IsL3End_0 != nil {
		i--
		if *m.IsL3End_0 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa0
	}
	if m.IsL2End_1 != nil {
		i--
		if *m.IsL2End_1 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x98
	}
	if m.IsL2End_0 != nil {
		i--
		if *m.IsL2End_0 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x90
	}
	if m.DeviceId_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.DeviceId_1))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe8
	}
	if m.DeviceId_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.DeviceId_0))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe0
	}
	if m.DeviceType_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.DeviceType_1))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd8
	}
	if m.DeviceType_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.DeviceType_0))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd0
	}
	if m.EpcId_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.EpcId_1))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc8
	}
	if m.EpcId_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.EpcId_0))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc0
	}
	if m.Host_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Host_1))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe8
	}
	if m.Host_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Host_0))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe0
	}
	if m.L3EpcId_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.L3EpcId_1))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd8
	}
	if m.L3EpcId_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.L3EpcId_0))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd0
	}
	if m.L3DeviceId_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.L3DeviceId_1))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc8
	}
	if m.L3DeviceId_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.L3DeviceId_0))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc0
	}
	if m.L3DeviceType_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.L3DeviceType_1))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb8
	}
	if m.L3DeviceType_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.L3DeviceType_0))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.SubnetId_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.SubnetId_1))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.SubnetId_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.SubnetId_0))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.TotalPktCnt_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TotalPktCnt_1))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf0
	}
	if m.TotalPktCnt_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TotalPktCnt_0))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe8
	}
	if m.TotalByteCnt_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TotalByteCnt_1))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe0
	}
	if m.TotalByteCnt_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TotalByteCnt_0))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd8
	}
	if m.PktCnt_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PktCnt_1))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd0
	}
	if m.PktCnt_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PktCnt_0))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc8
	}
	if m.ByteCnt_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.ByteCnt_1))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc0
	}
	if m.ByteCnt_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.ByteCnt_0))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb8
	}
	if m.TunRxId != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TunRxId))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa0
	}
	if m.TunTier != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TunTier))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x98
	}
	if m.TunRxIp_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TunRxIp_1))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x90
	}
	if m.TunRxIp_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TunRxIp_0))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.TunType != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TunType))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x80
	}
	if m.TunTxIp_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TunTxIp_1))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if m.TunTxIp_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TunTxIp_0))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf0
	}
	if m.TunTxId != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TunTxId))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpFlags_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TcpFlags_1))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpFlags_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TcpFlags_0))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.PortDst != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PortDst))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.PortSrc != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PortSrc))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.Proto != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Proto))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.Ip6Dst != nil {
		i -= len(m.Ip6Dst)
		copy(dAtA[i:], m.Ip6Dst)
		i = encodeVarintDfi(dAtA, i, uint64(len(m.Ip6Dst)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.Ip6Src != nil {
		i -= len(m.Ip6Src)
		copy(dAtA[i:], m.Ip6Src)
		i = encodeVarintDfi(dAtA, i, uint64(len(m.Ip6Src)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.IpDst != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.IpDst))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.IpSrc != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.IpSrc))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.MacDst != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.MacDst))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.MacSrc != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.MacSrc))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.EthType != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.EthType))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.Vlan != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Vlan))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.TapPort != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TapPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.TapType != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TapType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Duration != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Duration))
		i--
		dAtA[i] = 0x68
	}
	if m.EndTime != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.EndTime))
		i--
		dAtA[i] = 0x60
	}
	if m.StartTime != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.StartTime))
		i--
		dAtA[i] = 0x58
	}
	if m.FlowSource != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.FlowSource))
		i--
		dAtA[i] = 0x48
	}
	if m.FlowId != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.FlowId))
		i--
		dAtA[i] = 0x40
	}
	if m.CloseType != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.CloseType))
		i--
		dAtA[i] = 0x38
	}
	if m.Exporter != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Exporter))
		i--
		dAtA[i] = 0x10
	}
	if m.VtapId != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.VtapId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Metering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.L3EpcId_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.L3EpcId_1))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.L3EpcId_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.L3EpcId_0))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.PktCnt_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PktCnt_1))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.PktCnt_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PktCnt_0))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.ByteCnt_1 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.ByteCnt_1))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.ByteCnt_0 != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.ByteCnt_0))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.PortDst != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PortDst))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.PortSrc != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.PortSrc))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.Proto != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Proto))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.IpDst != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.IpDst))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.IpSrc != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.IpSrc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Vlan != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Vlan))
		i--
		dAtA[i] = 0x58
	}
	if m.TapPort != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TapPort))
		i--
		dAtA[i] = 0x20
	}
	if m.TapType != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TapType))
		i--
		dAtA[i] = 0x18
	}
	if m.Timestamp != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Exporter != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Exporter))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EthernetHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthernetHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VlanTag != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.VlanTag))
		i--
		dAtA[i] = 0x20
	}
	if m.EtherType != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.EtherType))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceAddress != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.SourceAddress))
		i--
		dAtA[i] = 0x10
	}
	if m.DestinationAddress != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.DestinationAddress))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ipv4Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ipv4Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ipv4Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		i -= len(m.Options)
		copy(dAtA[i:], m.Options)
		i = encodeVarintDfi(dAtA, i, uint64(len(m.Options)))
		i--
		dAtA[i] = 0x62
	}
	if m.DestinationAddress != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.DestinationAddress))
		i--
		dAtA[i] = 0x5d
	}
	if m.SourceAddress != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.SourceAddress))
		i--
		dAtA[i] = 0x55
	}
	if m.HeaderChecksum != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.HeaderChecksum))
		i--
		dAtA[i] = 0x48
	}
	if m.Protocol != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Protocol))
		i--
		dAtA[i] = 0x40
	}
	if m.Ttl != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Ttl))
		i--
		dAtA[i] = 0x38
	}
	if m.DeltaFragmentOffset != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint32(*m.DeltaFragmentOffset)<<1)^uint32((*m.DeltaFragmentOffset>>31))))
		i--
		dAtA[i] = 0x30
	}
	if m.DeltaIdentification != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint32(*m.DeltaIdentification)<<1)^uint32((*m.DeltaIdentification>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalLength != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.TotalLength))
		i--
		dAtA[i] = 0x20
	}
	if m.Tos != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Tos))
		i--
		dAtA[i] = 0x18
	}
	if m.Ihl != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Ihl))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeltaOption_9W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_9W)<<1)^uint64((*m.DeltaOption_9W>>63))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.DeltaOption_8W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_8W)<<1)^uint64((*m.DeltaOption_8W>>63))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.DeltaOption_7W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_7W)<<1)^uint64((*m.DeltaOption_7W>>63))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.DeltaOption_6W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_6W)<<1)^uint64((*m.DeltaOption_6W>>63))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.DeltaOption_5W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_5W)<<1)^uint64((*m.DeltaOption_5W>>63))))
		i--
		dAtA[i] = 0x78
	}
	if m.DeltaOption_4W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_4W)<<1)^uint64((*m.DeltaOption_4W>>63))))
		i--
		dAtA[i] = 0x70
	}
	if m.DeltaOption_3W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_3W)<<1)^uint64((*m.DeltaOption_3W>>63))))
		i--
		dAtA[i] = 0x68
	}
	if m.DeltaOption_2W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_2W)<<1)^uint64((*m.DeltaOption_2W>>63))))
		i--
		dAtA[i] = 0x60
	}
	if m.DeltaOption_1W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_1W)<<1)^uint64((*m.DeltaOption_1W>>63))))
		i--
		dAtA[i] = 0x58
	}
	if m.DeltaOption_0W != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaOption_0W)<<1)^uint64((*m.DeltaOption_0W>>63))))
		i--
		dAtA[i] = 0x50
	}
	if m.UrgentPointer != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.UrgentPointer))
		i--
		dAtA[i] = 0x48
	}
	if m.DeltaWindow != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint32(*m.DeltaWindow)<<1)^uint32((*m.DeltaWindow>>31))))
		i--
		dAtA[i] = 0x40
	}
	if m.Flags != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Flags))
		i--
		dAtA[i] = 0x38
	}
	if m.Reserved != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Reserved))
		i--
		dAtA[i] = 0x30
	}
	if m.DataOffset != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.DataOffset))
		i--
		dAtA[i] = 0x28
	}
	if m.DeltaAcknowledgementNumber != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaAcknowledgementNumber)<<1)^uint64((*m.DeltaAcknowledgementNumber>>63))))
		i--
		dAtA[i] = 0x20
	}
	if m.DeltaSequenceNumber != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaSequenceNumber)<<1)^uint64((*m.DeltaSequenceNumber>>63))))
		i--
		dAtA[i] = 0x18
	}
	if m.DestinationPort != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.DestinationPort))
		i--
		dAtA[i] = 0x10
	}
	if m.SourcePort != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.SourcePort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UdpHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UdpHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UdpHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Length != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Length))
		i--
		dAtA[i] = 0x18
	}
	if m.DestinationPort != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.DestinationPort))
		i--
		dAtA[i] = 0x10
	}
	if m.SourcePort != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.SourcePort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PacketHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PacketHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PacketHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Udp != nil {
		{
			size, err := m.Udp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Tcp != nil {
		{
			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Ipv4 != nil {
		{
			size, err := m.Ipv4.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Ethernet != nil {
		{
			size, err := m.Ethernet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DeltaTimestamp != nil {
		i = encodeVarintDfi(dAtA, i, uint64((uint64(*m.DeltaTimestamp)<<1)^uint64((*m.DeltaTimestamp>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowPktHdrBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowPktHdrBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowPktHdrBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Exporter != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Exporter))
		i--
		dAtA[i] = 0x38
	}
	if m.CloseType != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.CloseType))
		i--
		dAtA[i] = 0x30
	}
	if m.CompressedHeaders != nil {
		i -= len(m.CompressedHeaders)
		copy(dAtA[i:], m.CompressedHeaders)
		i = encodeVarintDfi(dAtA, i, uint64(len(m.CompressedHeaders)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Sequence != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Sequence))
		i--
		dAtA[i] = 0x20
	}
	if m.Direction != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Direction))
		i--
		dAtA[i] = 0x18
	}
	if m.FlowId != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.FlowId))
		i--
		dAtA[i] = 0x10
	}
	if m.Host != nil {
		i = encodeVarintDfi(dAtA, i, uint64(*m.Host))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDfi(dAtA []byte, offset int, v uint64) int {
	offset -= sovDfi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FlowHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sequence != nil {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OvsPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mac != nil {
		l = len(*m.Mac)
		n += 1 + l + sovDfi(uint64(l))
	}
	if m.DpPort != nil {
		n += 1 + sovDfi(uint64(*m.DpPort))
	}
	if m.InterfaceName != nil {
		l = len(*m.InterfaceName)
		n += 1 + l + sovDfi(uint64(l))
	}
	if m.BridgeName != nil {
		l = len(*m.BridgeName)
		n += 1 + l + sovDfi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OvsTopology) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovDfi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovDfi(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		n += 5
	}
	if m.Sequence != nil {
		n += 5
	}
	if m.ActionFlags != nil {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Flow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VtapId != nil {
		n += 1 + sovDfi(uint64(*m.VtapId))
	}
	if m.Exporter != nil {
		n += 1 + sovDfi(uint64(*m.Exporter))
	}
	if m.CloseType != nil {
		n += 1 + sovDfi(uint64(*m.CloseType))
	}
	if m.FlowId != nil {
		n += 1 + sovDfi(uint64(*m.FlowId))
	}
	if m.FlowSource != nil {
		n += 1 + sovDfi(uint64(*m.FlowSource))
	}
	if m.StartTime != nil {
		n += 1 + sovDfi(uint64(*m.StartTime))
	}
	if m.EndTime != nil {
		n += 1 + sovDfi(uint64(*m.EndTime))
	}
	if m.Duration != nil {
		n += 1 + sovDfi(uint64(*m.Duration))
	}
	if m.TapType != nil {
		n += 2 + sovDfi(uint64(*m.TapType))
	}
	if m.TapPort != nil {
		n += 2 + sovDfi(uint64(*m.TapPort))
	}
	if m.Vlan != nil {
		n += 2 + sovDfi(uint64(*m.Vlan))
	}
	if m.EthType != nil {
		n += 2 + sovDfi(uint64(*m.EthType))
	}
	if m.MacSrc != nil {
		n += 2 + sovDfi(uint64(*m.MacSrc))
	}
	if m.MacDst != nil {
		n += 2 + sovDfi(uint64(*m.MacDst))
	}
	if m.IpSrc != nil {
		n += 2 + sovDfi(uint64(*m.IpSrc))
	}
	if m.IpDst != nil {
		n += 2 + sovDfi(uint64(*m.IpDst))
	}
	if m.Ip6Src != nil {
		l = len(m.Ip6Src)
		n += 2 + l + sovDfi(uint64(l))
	}
	if m.Ip6Dst != nil {
		l = len(m.Ip6Dst)
		n += 2 + l + sovDfi(uint64(l))
	}
	if m.Proto != nil {
		n += 2 + sovDfi(uint64(*m.Proto))
	}
	if m.PortSrc != nil {
		n += 2 + sovDfi(uint64(*m.PortSrc))
	}
	if m.PortDst != nil {
		n += 2 + sovDfi(uint64(*m.PortDst))
	}
	if m.TcpFlags_0 != nil {
		n += 2 + sovDfi(uint64(*m.TcpFlags_0))
	}
	if m.TcpFlags_1 != nil {
		n += 2 + sovDfi(uint64(*m.TcpFlags_1))
	}
	if m.TunTxId != nil {
		n += 2 + sovDfi(uint64(*m.TunTxId))
	}
	if m.TunTxIp_0 != nil {
		n += 2 + sovDfi(uint64(*m.TunTxIp_0))
	}
	if m.TunTxIp_1 != nil {
		n += 2 + sovDfi(uint64(*m.TunTxIp_1))
	}
	if m.TunType != nil {
		n += 2 + sovDfi(uint64(*m.TunType))
	}
	if m.TunRxIp_0 != nil {
		n += 2 + sovDfi(uint64(*m.TunRxIp_0))
	}
	if m.TunRxIp_1 != nil {
		n += 2 + sovDfi(uint64(*m.TunRxIp_1))
	}
	if m.TunTier != nil {
		n += 2 + sovDfi(uint64(*m.TunTier))
	}
	if m.TunRxId != nil {
		n += 2 + sovDfi(uint64(*m.TunRxId))
	}
	if m.ByteCnt_0 != nil {
		n += 2 + sovDfi(uint64(*m.ByteCnt_0))
	}
	if m.ByteCnt_1 != nil {
		n += 2 + sovDfi(uint64(*m.ByteCnt_1))
	}
	if m.PktCnt_0 != nil {
		n += 2 + sovDfi(uint64(*m.PktCnt_0))
	}
	if m.PktCnt_1 != nil {
		n += 2 + sovDfi(uint64(*m.PktCnt_1))
	}
	if m.TotalByteCnt_0 != nil {
		n += 2 + sovDfi(uint64(*m.TotalByteCnt_0))
	}
	if m.TotalByteCnt_1 != nil {
		n += 2 + sovDfi(uint64(*m.TotalByteCnt_1))
	}
	if m.TotalPktCnt_0 != nil {
		n += 2 + sovDfi(uint64(*m.TotalPktCnt_0))
	}
	if m.TotalPktCnt_1 != nil {
		n += 2 + sovDfi(uint64(*m.TotalPktCnt_1))
	}
	if m.SubnetId_0 != nil {
		n += 2 + sovDfi(uint64(*m.SubnetId_0))
	}
	if m.SubnetId_1 != nil {
		n += 2 + sovDfi(uint64(*m.SubnetId_1))
	}
	if m.L3DeviceType_0 != nil {
		n += 2 + sovDfi(uint64(*m.L3DeviceType_0))
	}
	if m.L3DeviceType_1 != nil {
		n += 2 + sovDfi(uint64(*m.L3DeviceType_1))
	}
	if m.L3DeviceId_0 != nil {
		n += 2 + sovDfi(uint64(*m.L3DeviceId_0))
	}
	if m.L3DeviceId_1 != nil {
		n += 2 + sovDfi(uint64(*m.L3DeviceId_1))
	}
	if m.L3EpcId_0 != nil {
		n += 2 + sovDfi(uint64(*m.L3EpcId_0))
	}
	if m.L3EpcId_1 != nil {
		n += 2 + sovDfi(uint64(*m.L3EpcId_1))
	}
	if m.Host_0 != nil {
		n += 2 + sovDfi(uint64(*m.Host_0))
	}
	if m.Host_1 != nil {
		n += 2 + sovDfi(uint64(*m.Host_1))
	}
	if m.EpcId_0 != nil {
		n += 2 + sovDfi(uint64(*m.EpcId_0))
	}
	if m.EpcId_1 != nil {
		n += 2 + sovDfi(uint64(*m.EpcId_1))
	}
	if m.DeviceType_0 != nil {
		n += 2 + sovDfi(uint64(*m.DeviceType_0))
	}
	if m.DeviceType_1 != nil {
		n += 2 + sovDfi(uint64(*m.DeviceType_1))
	}
	if m.DeviceId_0 != nil {
		n += 2 + sovDfi(uint64(*m.DeviceId_0))
	}
	if m.DeviceId_1 != nil {
		n += 2 + sovDfi(uint64(*m.DeviceId_1))
	}
	if m.IsL2End_0 != nil {
		n += 3
	}
	if m.IsL2End_1 != nil {
		n += 3
	}
	if m.IsL3End_0 != nil {
		n += 3
	}
	if m.IsL3End_1 != nil {
		n += 3
	}
	if m.RttAvg != nil {
		n += 2 + sovDfi(uint64(*m.RttAvg))
	}
	if m.SrtAvg != nil {
		n += 2 + sovDfi(uint64(*m.SrtAvg))
	}
	if m.RetransCnt_0 != nil {
		n += 2 + sovDfi(uint64(*m.RetransCnt_0))
	}
	if m.RetransCnt_1 != nil {
		n += 2 + sovDfi(uint64(*m.RetransCnt_1))
	}
	if m.TotalRetransCnt != nil {
		n += 2 + sovDfi(uint64(*m.TotalRetransCnt))
	}
	if m.ZeroWndCnt_0 != nil {
		n += 2 + sovDfi(uint64(*m.ZeroWndCnt_0))
	}
	if m.ZeroWndCnt_1 != nil {
		n += 2 + sovDfi(uint64(*m.ZeroWndCnt_1))
	}
	if m.ArtAvg != nil {
		n += 2 + sovDfi(uint64(*m.ArtAvg))
	}
	if m.RttClientAvg != nil {
		n += 2 + sovDfi(uint64(*m.RttClientAvg))
	}
	if m.RttServerAvg != nil {
		n += 2 + sovDfi(uint64(*m.RttServerAvg))
	}
	if m.ProvinceSrc != nil {
		n += 2 + sovDfi(uint64(*m.ProvinceSrc))
	}
	if m.ProvinceDst != nil {
		n += 2 + sovDfi(uint64(*m.ProvinceDst))
	}
	if m.CastTypeMap_0 != nil {
		n += 2 + sovDfi(uint64(*m.CastTypeMap_0))
	}
	if m.CastTypeMap_1 != nil {
		n += 2 + sovDfi(uint64(*m.CastTypeMap_1))
	}
	if m.TcpFlagsMap_0 != nil {
		n += 2 + sovDfi(uint64(*m.TcpFlagsMap_0))
	}
	if m.TcpFlagsMap_1 != nil {
		n += 2 + sovDfi(uint64(*m.TcpFlagsMap_1))
	}
	if m.TtlMap_0 != nil {
		n += 2 + sovDfi(uint64(*m.TtlMap_0))
	}
	if m.TtlMap_1 != nil {
		n += 2 + sovDfi(uint64(*m.TtlMap_1))
	}
	if m.PacketSizeMap_0 != nil {
		n += 2 + sovDfi(uint64(*m.PacketSizeMap_0))
	}
	if m.PacketSizeMap_1 != nil {
		n += 2 + sovDfi(uint64(*m.PacketSizeMap_1))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exporter != nil {
		n += 1 + sovDfi(uint64(*m.Exporter))
	}
	if m.Timestamp != nil {
		n += 1 + sovDfi(uint64(*m.Timestamp))
	}
	if m.TapType != nil {
		n += 1 + sovDfi(uint64(*m.TapType))
	}
	if m.TapPort != nil {
		n += 1 + sovDfi(uint64(*m.TapPort))
	}
	if m.Vlan != nil {
		n += 1 + sovDfi(uint64(*m.Vlan))
	}
	if m.IpSrc != nil {
		n += 2 + sovDfi(uint64(*m.IpSrc))
	}
	if m.IpDst != nil {
		n += 2 + sovDfi(uint64(*m.IpDst))
	}
	if m.Proto != nil {
		n += 2 + sovDfi(uint64(*m.Proto))
	}
	if m.PortSrc != nil {
		n += 2 + sovDfi(uint64(*m.PortSrc))
	}
	if m.PortDst != nil {
		n += 2 + sovDfi(uint64(*m.PortDst))
	}
	if m.ByteCnt_0 != nil {
		n += 2 + sovDfi(uint64(*m.ByteCnt_0))
	}
	if m.ByteCnt_1 != nil {
		n += 2 + sovDfi(uint64(*m.ByteCnt_1))
	}
	if m.PktCnt_0 != nil {
		n += 2 + sovDfi(uint64(*m.PktCnt_0))
	}
	if m.PktCnt_1 != nil {
		n += 2 + sovDfi(uint64(*m.PktCnt_1))
	}
	if m.L3EpcId_0 != nil {
		n += 2 + sovDfi(uint64(*m.L3EpcId_0))
	}
	if m.L3EpcId_1 != nil {
		n += 2 + sovDfi(uint64(*m.L3EpcId_1))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EthernetHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DestinationAddress != nil {
		n += 1 + sovDfi(uint64(*m.DestinationAddress))
	}
	if m.SourceAddress != nil {
		n += 1 + sovDfi(uint64(*m.SourceAddress))
	}
	if m.EtherType != nil {
		n += 1 + sovDfi(uint64(*m.EtherType))
	}
	if m.VlanTag != nil {
		n += 1 + sovDfi(uint64(*m.VlanTag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ipv4Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		n += 1 + sovDfi(uint64(*m.Version))
	}
	if m.Ihl != nil {
		n += 1 + sovDfi(uint64(*m.Ihl))
	}
	if m.Tos != nil {
		n += 1 + sovDfi(uint64(*m.Tos))
	}
	if m.TotalLength != nil {
		n += 1 + sovDfi(uint64(*m.TotalLength))
	}
	if m.DeltaIdentification != nil {
		n += 1 + sozDfi(uint64(*m.DeltaIdentification))
	}
	if m.DeltaFragmentOffset != nil {
		n += 1 + sozDfi(uint64(*m.DeltaFragmentOffset))
	}
	if m.Ttl != nil {
		n += 1 + sovDfi(uint64(*m.Ttl))
	}
	if m.Protocol != nil {
		n += 1 + sovDfi(uint64(*m.Protocol))
	}
	if m.HeaderChecksum != nil {
		n += 1 + sovDfi(uint64(*m.HeaderChecksum))
	}
	if m.SourceAddress != nil {
		n += 5
	}
	if m.DestinationAddress != nil {
		n += 5
	}
	if m.Options != nil {
		l = len(m.Options)
		n += 1 + l + sovDfi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourcePort != nil {
		n += 1 + sovDfi(uint64(*m.SourcePort))
	}
	if m.DestinationPort != nil {
		n += 1 + sovDfi(uint64(*m.DestinationPort))
	}
	if m.DeltaSequenceNumber != nil {
		n += 1 + sozDfi(uint64(*m.DeltaSequenceNumber))
	}
	if m.DeltaAcknowledgementNumber != nil {
		n += 1 + sozDfi(uint64(*m.DeltaAcknowledgementNumber))
	}
	if m.DataOffset != nil {
		n += 1 + sovDfi(uint64(*m.DataOffset))
	}
	if m.Reserved != nil {
		n += 1 + sovDfi(uint64(*m.Reserved))
	}
	if m.Flags != nil {
		n += 1 + sovDfi(uint64(*m.Flags))
	}
	if m.DeltaWindow != nil {
		n += 1 + sozDfi(uint64(*m.DeltaWindow))
	}
	if m.UrgentPointer != nil {
		n += 1 + sovDfi(uint64(*m.UrgentPointer))
	}
	if m.DeltaOption_0W != nil {
		n += 1 + sozDfi(uint64(*m.DeltaOption_0W))
	}
	if m.DeltaOption_1W != nil {
		n += 1 + sozDfi(uint64(*m.DeltaOption_1W))
	}
	if m.DeltaOption_2W != nil {
		n += 1 + sozDfi(uint64(*m.DeltaOption_2W))
	}
	if m.DeltaOption_3W != nil {
		n += 1 + sozDfi(uint64(*m.DeltaOption_3W))
	}
	if m.DeltaOption_4W != nil {
		n += 1 + sozDfi(uint64(*m.DeltaOption_4W))
	}
	if m.DeltaOption_5W != nil {
		n += 1 + sozDfi(uint64(*m.DeltaOption_5W))
	}
	if m.DeltaOption_6W != nil {
		n += 2 + sozDfi(uint64(*m.DeltaOption_6W))
	}
	if m.DeltaOption_7W != nil {
		n += 2 + sozDfi(uint64(*m.DeltaOption_7W))
	}
	if m.DeltaOption_8W != nil {
		n += 2 + sozDfi(uint64(*m.DeltaOption_8W))
	}
	if m.DeltaOption_9W != nil {
		n += 2 + sozDfi(uint64(*m.DeltaOption_9W))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UdpHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourcePort != nil {
		n += 1 + sovDfi(uint64(*m.SourcePort))
	}
	if m.DestinationPort != nil {
		n += 1 + sovDfi(uint64(*m.DestinationPort))
	}
	if m.Length != nil {
		n += 1 + sovDfi(uint64(*m.Length))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PacketHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeltaTimestamp != nil {
		n += 1 + sozDfi(uint64(*m.DeltaTimestamp))
	}
	if m.Ethernet != nil {
		l = m.Ethernet.Size()
		n += 1 + l + sovDfi(uint64(l))
	}
	if m.Ipv4 != nil {
		l = m.Ipv4.Size()
		n += 1 + l + sovDfi(uint64(l))
	}
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovDfi(uint64(l))
	}
	if m.Udp != nil {
		l = m.Udp.Size()
		n += 1 + l + sovDfi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowPktHdrBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Host != nil {
		n += 1 + sovDfi(uint64(*m.Host))
	}
	if m.FlowId != nil {
		n += 1 + sovDfi(uint64(*m.FlowId))
	}
	if m.Direction != nil {
		n += 1 + sovDfi(uint64(*m.Direction))
	}
	if m.Sequence != nil {
		n += 1 + sovDfi(uint64(*m.Sequence))
	}
	if m.CompressedHeaders != nil {
		l = len(m.CompressedHeaders)
		n += 1 + l + sovDfi(uint64(l))
	}
	if m.CloseType != nil {
		n += 1 + sovDfi(uint64(*m.CloseType))
	}
	if m.Exporter != nil {
		n += 1 + sovDfi(uint64(*m.Exporter))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDfi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDfi(x uint64) (n int) {
	return sovDfi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlowHeader) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Sequence = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("sequence")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OvsPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OvsPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OvsPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Mac = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DpPort = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InterfaceName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BridgeName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OvsTopology) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OvsTopology: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OvsTopology: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &OvsPort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v RequestType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= RequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamHeader) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Timestamp = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Sequence = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionFlags", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ActionFlags = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("timestamp")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("sequence")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("action_flags")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtapId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VtapId = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exporter", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exporter = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseType = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowId = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowSource", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowSource = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartTime = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndTime = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Duration = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TapType = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TapPort = &v
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Vlan = &v
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EthType = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacSrc", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MacSrc = &v
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacDst", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MacDst = &v
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSrc", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpSrc = &v
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDst", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpDst = &v
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip6Src", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip6Src = append(m.Ip6Src[:0], dAtA[iNdEx:postIndex]...)
			if m.Ip6Src == nil {
				m.Ip6Src = []byte{}
			}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip6Dst", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip6Dst = append(m.Ip6Dst[:0], dAtA[iNdEx:postIndex]...)
			if m.Ip6Dst == nil {
				m.Ip6Dst = []byte{}
			}
			iNdEx = postIndex
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Proto = &v
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSrc", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortSrc = &v
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortDst", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortDst = &v
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFlags_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpFlags_0 = &v
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFlags_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpFlags_1 = &v
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunTxId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunTxId = &v
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunTxIp_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunTxIp_0 = &v
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunTxIp_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunTxIp_1 = &v
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunType = &v
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunRxIp_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunRxIp_0 = &v
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunRxIp_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunRxIp_1 = &v
		case 67:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunTier", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunTier = &v
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunRxId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TunRxId = &v
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteCnt_0", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByteCnt_0 = &v
		case 72:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteCnt_1", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByteCnt_1 = &v
		case 73:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktCnt_0", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PktCnt_0 = &v
		case 74:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktCnt_1", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PktCnt_1 = &v
		case 75:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalByteCnt_0", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalByteCnt_0 = &v
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalByteCnt_1", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalByteCnt_1 = &v
		case 77:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPktCnt_0", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalPktCnt_0 = &v
		case 78:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPktCnt_1", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalPktCnt_1 = &v
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SubnetId_0 = &v
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SubnetId_1 = &v
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3DeviceType_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3DeviceType_0 = &v
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3DeviceType_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3DeviceType_1 = &v
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3DeviceId_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3DeviceId_0 = &v
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3DeviceId_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3DeviceId_1 = &v
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3EpcId_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3EpcId_0 = &v
		case 107:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3EpcId_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3EpcId_1 = &v
		case 108:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Host_0 = &v
		case 109:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Host_1 = &v
		case 120:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpcId_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EpcId_0 = &v
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpcId_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EpcId_1 = &v
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeviceType_0 = &v
		case 123:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeviceType_1 = &v
		case 124:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeviceId_0 = &v
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeviceId_1 = &v
		case 130:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsL2End_0", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsL2End_0 = &b
		case 131:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsL2End_1", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsL2End_1 = &b
		case 132:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsL3End_0", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsL3End_0 = &b
		case 133:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsL3End_1", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsL3End_1 = &b
		case 142:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttAvg", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RttAvg = &v
		case 143:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrtAvg", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SrtAvg = &v
		case 145:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransCnt_0", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetransCnt_0 = &v
		case 146:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransCnt_1", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetransCnt_1 = &v
		case 147:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRetransCnt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalRetransCnt = &v
		case 148:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroWndCnt_0", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZeroWndCnt_0 = &v
		case 149:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroWndCnt_1", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZeroWndCnt_1 = &v
		case 157:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtAvg", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArtAvg = &v
		case 165:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttClientAvg", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RttClientAvg = &v
		case 166:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttServerAvg", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RttServerAvg = &v
		case 174:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvinceSrc", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProvinceSrc = &v
		case 175:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvinceDst", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProvinceDst = &v
		case 200:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CastTypeMap_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CastTypeMap_0 = &v
		case 201:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CastTypeMap_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CastTypeMap_1 = &v
		case 202:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFlagsMap_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpFlagsMap_0 = &v
		case 203:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFlagsMap_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TcpFlagsMap_1 = &v
		case 204:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlMap_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlMap_0 = &v
		case 205:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlMap_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TtlMap_1 = &v
		case 206:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketSizeMap_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PacketSizeMap_0 = &v
		case 207:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketSizeMap_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PacketSizeMap_1 = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exporter", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exporter = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timestamp = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TapType = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TapPort = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Vlan = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSrc", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpSrc = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDst", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpDst = &v
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Proto = &v
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSrc", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortSrc = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortDst", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortDst = &v
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteCnt_0", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByteCnt_0 = &v
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteCnt_1", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByteCnt_1 = &v
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktCnt_0", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PktCnt_0 = &v
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktCnt_1", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PktCnt_1 = &v
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3EpcId_0", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3EpcId_0 = &v
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3EpcId_1", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L3EpcId_1 = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthernetHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthernetHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthernetHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationAddress", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DestinationAddress = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddress", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceAddress = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtherType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EtherType = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTag", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VlanTag = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ipv4Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ipv4Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ipv4Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ihl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ihl = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tos", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tos = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLength", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalLength = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaIdentification", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DeltaIdentification = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaFragmentOffset", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DeltaFragmentOffset = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ttl = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protocol = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderChecksum", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HeaderChecksum = &v
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SourceAddress = &v
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationAddress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DestinationAddress = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options[:0], dAtA[iNdEx:postIndex]...)
			if m.Options == nil {
				m.Options = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourcePort = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DestinationPort = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaSequenceNumber", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaSequenceNumber = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaAcknowledgementNumber", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaAcknowledgementNumber = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataOffset", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DataOffset = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reserved = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flags = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaWindow", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DeltaWindow = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrgentPointer", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UrgentPointer = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_0W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_0W = &v2
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_1W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_1W = &v2
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_2W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_2W = &v2
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_3W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_3W = &v2
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_4W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_4W = &v2
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_5W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_5W = &v2
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_6W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_6W = &v2
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_7W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_7W = &v2
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_8W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_8W = &v2
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOption_9W", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaOption_9W = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UdpHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UdpHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UdpHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourcePort = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DestinationPort = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Length = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PacketHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaTimestamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DeltaTimestamp = &v2
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ethernet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ethernet == nil {
				m.Ethernet = &EthernetHeader{}
			}
			if err := m.Ethernet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv4 == nil {
				m.Ipv4 = &Ipv4Header{}
			}
			if err := m.Ipv4.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tcp == nil {
				m.Tcp = &TcpHeader{}
			}
			if err := m.Tcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Udp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Udp == nil {
				m.Udp = &UdpHeader{}
			}
			if err := m.Udp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowPktHdrBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowPktHdrBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowPktHdrBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Host = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlowId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var v Direction
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Direction = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sequence = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedHeaders", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDfi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDfi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompressedHeaders = append(m.CompressedHeaders[:0], dAtA[iNdEx:postIndex]...)
			if m.CompressedHeaders == nil {
				m.CompressedHeaders = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CloseType = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exporter", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exporter = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDfi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDfi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDfi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDfi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDfi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDfi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDfi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDfi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDfi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDfi = fmt.Errorf("proto: unexpected end of group")
)
