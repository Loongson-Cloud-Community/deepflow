// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: diagnose.proto

package diagnose

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type L3TableRequest_From int32

const (
	L3TableRequest_FROM_TRAFFIC_TTL L3TableRequest_From = 4
	L3TableRequest_FROM_TRAFFIC_ARP L3TableRequest_From = 8
)

var L3TableRequest_From_name = map[int32]string{
	4: "FROM_TRAFFIC_TTL",
	8: "FROM_TRAFFIC_ARP",
}

var L3TableRequest_From_value = map[string]int32{
	"FROM_TRAFFIC_TTL": 4,
	"FROM_TRAFFIC_ARP": 8,
}

func (x L3TableRequest_From) Enum() *L3TableRequest_From {
	p := new(L3TableRequest_From)
	*p = x
	return p
}

func (x L3TableRequest_From) String() string {
	return proto.EnumName(L3TableRequest_From_name, int32(x))
}

func (x *L3TableRequest_From) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(L3TableRequest_From_value, data, "L3TableRequest_From")
	if err != nil {
		return err
	}
	*x = L3TableRequest_From(value)
	return nil
}

func (L3TableRequest_From) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d299e373e8035cd7, []int{3, 0}
}

type DiagnoseRequest struct {
	Arg                  *string  `protobuf:"bytes,1,opt,name=arg" json:"arg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiagnoseRequest) Reset()         { *m = DiagnoseRequest{} }
func (m *DiagnoseRequest) String() string { return proto.CompactTextString(m) }
func (*DiagnoseRequest) ProtoMessage()    {}
func (*DiagnoseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d299e373e8035cd7, []int{0}
}
func (m *DiagnoseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiagnoseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiagnoseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiagnoseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiagnoseRequest.Merge(m, src)
}
func (m *DiagnoseRequest) XXX_Size() int {
	return m.Size()
}
func (m *DiagnoseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiagnoseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiagnoseRequest proto.InternalMessageInfo

func (m *DiagnoseRequest) GetArg() string {
	if m != nil && m.Arg != nil {
		return *m.Arg
	}
	return ""
}

type DiagnoseResponse struct {
	Result               *string  `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiagnoseResponse) Reset()         { *m = DiagnoseResponse{} }
func (m *DiagnoseResponse) String() string { return proto.CompactTextString(m) }
func (*DiagnoseResponse) ProtoMessage()    {}
func (*DiagnoseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d299e373e8035cd7, []int{1}
}
func (m *DiagnoseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiagnoseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiagnoseResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiagnoseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiagnoseResponse.Merge(m, src)
}
func (m *DiagnoseResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiagnoseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiagnoseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiagnoseResponse proto.InternalMessageInfo

func (m *DiagnoseResponse) GetResult() string {
	if m != nil && m.Result != nil {
		return *m.Result
	}
	return ""
}

type ArpItem struct {
	Ip                   *string  `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	Mac                  *uint64  `protobuf:"varint,2,opt,name=mac" json:"mac,omitempty"`
	EpcId                *uint32  `protobuf:"varint,3,opt,name=epc_id,json=epcId" json:"epc_id,omitempty"`
	TapType              *uint32  `protobuf:"varint,4,opt,name=tap_type,json=tapType" json:"tap_type,omitempty"`
	TapPort              *uint32  `protobuf:"varint,5,opt,name=tap_port,json=tapPort" json:"tap_port,omitempty"`
	TxPackets            *uint64  `protobuf:"varint,10,opt,name=tx_packets,json=txPackets" json:"tx_packets,omitempty"`
	RxPackets            *uint64  `protobuf:"varint,11,opt,name=rx_packets,json=rxPackets" json:"rx_packets,omitempty"`
	TxBytes              *uint64  `protobuf:"varint,12,opt,name=tx_bytes,json=txBytes" json:"tx_bytes,omitempty"`
	RxBytes              *uint64  `protobuf:"varint,13,opt,name=rx_bytes,json=rxBytes" json:"rx_bytes,omitempty"`
	TxLastNs             *uint64  `protobuf:"varint,14,opt,name=tx_last_ns,json=txLastNs" json:"tx_last_ns,omitempty"`
	RxLastNs             *uint64  `protobuf:"varint,15,opt,name=rx_last_ns,json=rxLastNs" json:"rx_last_ns,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArpItem) Reset()         { *m = ArpItem{} }
func (m *ArpItem) String() string { return proto.CompactTextString(m) }
func (*ArpItem) ProtoMessage()    {}
func (*ArpItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d299e373e8035cd7, []int{2}
}
func (m *ArpItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArpItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArpItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArpItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArpItem.Merge(m, src)
}
func (m *ArpItem) XXX_Size() int {
	return m.Size()
}
func (m *ArpItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ArpItem.DiscardUnknown(m)
}

var xxx_messageInfo_ArpItem proto.InternalMessageInfo

func (m *ArpItem) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *ArpItem) GetMac() uint64 {
	if m != nil && m.Mac != nil {
		return *m.Mac
	}
	return 0
}

func (m *ArpItem) GetEpcId() uint32 {
	if m != nil && m.EpcId != nil {
		return *m.EpcId
	}
	return 0
}

func (m *ArpItem) GetTapType() uint32 {
	if m != nil && m.TapType != nil {
		return *m.TapType
	}
	return 0
}

func (m *ArpItem) GetTapPort() uint32 {
	if m != nil && m.TapPort != nil {
		return *m.TapPort
	}
	return 0
}

func (m *ArpItem) GetTxPackets() uint64 {
	if m != nil && m.TxPackets != nil {
		return *m.TxPackets
	}
	return 0
}

func (m *ArpItem) GetRxPackets() uint64 {
	if m != nil && m.RxPackets != nil {
		return *m.RxPackets
	}
	return 0
}

func (m *ArpItem) GetTxBytes() uint64 {
	if m != nil && m.TxBytes != nil {
		return *m.TxBytes
	}
	return 0
}

func (m *ArpItem) GetRxBytes() uint64 {
	if m != nil && m.RxBytes != nil {
		return *m.RxBytes
	}
	return 0
}

func (m *ArpItem) GetTxLastNs() uint64 {
	if m != nil && m.TxLastNs != nil {
		return *m.TxLastNs
	}
	return 0
}

func (m *ArpItem) GetRxLastNs() uint64 {
	if m != nil && m.RxLastNs != nil {
		return *m.RxLastNs
	}
	return 0
}

type L3TableRequest struct {
	ItemFrom             *uint32  `protobuf:"varint,1,opt,name=item_from,json=itemFrom" json:"item_from,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L3TableRequest) Reset()         { *m = L3TableRequest{} }
func (m *L3TableRequest) String() string { return proto.CompactTextString(m) }
func (*L3TableRequest) ProtoMessage()    {}
func (*L3TableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d299e373e8035cd7, []int{3}
}
func (m *L3TableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L3TableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L3TableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L3TableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L3TableRequest.Merge(m, src)
}
func (m *L3TableRequest) XXX_Size() int {
	return m.Size()
}
func (m *L3TableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_L3TableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_L3TableRequest proto.InternalMessageInfo

func (m *L3TableRequest) GetItemFrom() uint32 {
	if m != nil && m.ItemFrom != nil {
		return *m.ItemFrom
	}
	return 0
}

type L3TableResponse struct {
	ArpItems             []*ArpItem `protobuf:"bytes,1,rep,name=arp_items,json=arpItems" json:"arp_items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *L3TableResponse) Reset()         { *m = L3TableResponse{} }
func (m *L3TableResponse) String() string { return proto.CompactTextString(m) }
func (*L3TableResponse) ProtoMessage()    {}
func (*L3TableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d299e373e8035cd7, []int{4}
}
func (m *L3TableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L3TableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L3TableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L3TableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L3TableResponse.Merge(m, src)
}
func (m *L3TableResponse) XXX_Size() int {
	return m.Size()
}
func (m *L3TableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_L3TableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_L3TableResponse proto.InternalMessageInfo

func (m *L3TableResponse) GetArpItems() []*ArpItem {
	if m != nil {
		return m.ArpItems
	}
	return nil
}

type FlowItem struct {
	TapType              *uint32  `protobuf:"varint,1,opt,name=tap_type,json=tapType" json:"tap_type,omitempty"`
	SrcEpcId             *uint32  `protobuf:"varint,2,opt,name=src_epc_id,json=srcEpcId" json:"src_epc_id,omitempty"`
	DstEpcId             *uint32  `protobuf:"varint,3,opt,name=dst_epc_id,json=dstEpcId" json:"dst_epc_id,omitempty"`
	SrcIp                *string  `protobuf:"bytes,4,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	DstIp                *string  `protobuf:"bytes,5,opt,name=dst_ip,json=dstIp" json:"dst_ip,omitempty"`
	Protocol             *uint32  `protobuf:"varint,6,opt,name=protocol" json:"protocol,omitempty"`
	SrcPort              *uint32  `protobuf:"varint,7,opt,name=src_port,json=srcPort" json:"src_port,omitempty"`
	DstPort              *uint32  `protobuf:"varint,8,opt,name=dst_port,json=dstPort" json:"dst_port,omitempty"`
	TapPort              *uint32  `protobuf:"varint,9,opt,name=tap_port,json=tapPort" json:"tap_port,omitempty"`
	TxPackets            *uint64  `protobuf:"varint,20,opt,name=tx_packets,json=txPackets" json:"tx_packets,omitempty"`
	RxPackets            *uint64  `protobuf:"varint,21,opt,name=rx_packets,json=rxPackets" json:"rx_packets,omitempty"`
	TxBytes              *uint64  `protobuf:"varint,22,opt,name=tx_bytes,json=txBytes" json:"tx_bytes,omitempty"`
	RxBytes              *uint64  `protobuf:"varint,23,opt,name=rx_bytes,json=rxBytes" json:"rx_bytes,omitempty"`
	ClientFirstNs        *uint64  `protobuf:"varint,30,opt,name=client_first_ns,json=clientFirstNs" json:"client_first_ns,omitempty"`
	ServerFirstNs        *uint64  `protobuf:"varint,31,opt,name=server_first_ns,json=serverFirstNs" json:"server_first_ns,omitempty"`
	ClientLastNs         *uint64  `protobuf:"varint,32,opt,name=client_last_ns,json=clientLastNs" json:"client_last_ns,omitempty"`
	ServerLastNs         *uint64  `protobuf:"varint,33,opt,name=server_last_ns,json=serverLastNs" json:"server_last_ns,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowItem) Reset()         { *m = FlowItem{} }
func (m *FlowItem) String() string { return proto.CompactTextString(m) }
func (*FlowItem) ProtoMessage()    {}
func (*FlowItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_d299e373e8035cd7, []int{5}
}
func (m *FlowItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowItem.Merge(m, src)
}
func (m *FlowItem) XXX_Size() int {
	return m.Size()
}
func (m *FlowItem) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowItem.DiscardUnknown(m)
}

var xxx_messageInfo_FlowItem proto.InternalMessageInfo

func (m *FlowItem) GetTapType() uint32 {
	if m != nil && m.TapType != nil {
		return *m.TapType
	}
	return 0
}

func (m *FlowItem) GetSrcEpcId() uint32 {
	if m != nil && m.SrcEpcId != nil {
		return *m.SrcEpcId
	}
	return 0
}

func (m *FlowItem) GetDstEpcId() uint32 {
	if m != nil && m.DstEpcId != nil {
		return *m.DstEpcId
	}
	return 0
}

func (m *FlowItem) GetSrcIp() string {
	if m != nil && m.SrcIp != nil {
		return *m.SrcIp
	}
	return ""
}

func (m *FlowItem) GetDstIp() string {
	if m != nil && m.DstIp != nil {
		return *m.DstIp
	}
	return ""
}

func (m *FlowItem) GetProtocol() uint32 {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return 0
}

func (m *FlowItem) GetSrcPort() uint32 {
	if m != nil && m.SrcPort != nil {
		return *m.SrcPort
	}
	return 0
}

func (m *FlowItem) GetDstPort() uint32 {
	if m != nil && m.DstPort != nil {
		return *m.DstPort
	}
	return 0
}

func (m *FlowItem) GetTapPort() uint32 {
	if m != nil && m.TapPort != nil {
		return *m.TapPort
	}
	return 0
}

func (m *FlowItem) GetTxPackets() uint64 {
	if m != nil && m.TxPackets != nil {
		return *m.TxPackets
	}
	return 0
}

func (m *FlowItem) GetRxPackets() uint64 {
	if m != nil && m.RxPackets != nil {
		return *m.RxPackets
	}
	return 0
}

func (m *FlowItem) GetTxBytes() uint64 {
	if m != nil && m.TxBytes != nil {
		return *m.TxBytes
	}
	return 0
}

func (m *FlowItem) GetRxBytes() uint64 {
	if m != nil && m.RxBytes != nil {
		return *m.RxBytes
	}
	return 0
}

func (m *FlowItem) GetClientFirstNs() uint64 {
	if m != nil && m.ClientFirstNs != nil {
		return *m.ClientFirstNs
	}
	return 0
}

func (m *FlowItem) GetServerFirstNs() uint64 {
	if m != nil && m.ServerFirstNs != nil {
		return *m.ServerFirstNs
	}
	return 0
}

func (m *FlowItem) GetClientLastNs() uint64 {
	if m != nil && m.ClientLastNs != nil {
		return *m.ClientLastNs
	}
	return 0
}

func (m *FlowItem) GetServerLastNs() uint64 {
	if m != nil && m.ServerLastNs != nil {
		return *m.ServerLastNs
	}
	return 0
}

type FlowTableRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowTableRequest) Reset()         { *m = FlowTableRequest{} }
func (m *FlowTableRequest) String() string { return proto.CompactTextString(m) }
func (*FlowTableRequest) ProtoMessage()    {}
func (*FlowTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d299e373e8035cd7, []int{6}
}
func (m *FlowTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowTableRequest.Merge(m, src)
}
func (m *FlowTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *FlowTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FlowTableRequest proto.InternalMessageInfo

type FlowTableResponse struct {
	FlowItems            []*FlowItem `protobuf:"bytes,1,rep,name=flow_items,json=flowItems" json:"flow_items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FlowTableResponse) Reset()         { *m = FlowTableResponse{} }
func (m *FlowTableResponse) String() string { return proto.CompactTextString(m) }
func (*FlowTableResponse) ProtoMessage()    {}
func (*FlowTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d299e373e8035cd7, []int{7}
}
func (m *FlowTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowTableResponse.Merge(m, src)
}
func (m *FlowTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *FlowTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FlowTableResponse proto.InternalMessageInfo

func (m *FlowTableResponse) GetFlowItems() []*FlowItem {
	if m != nil {
		return m.FlowItems
	}
	return nil
}

func init() {
	proto.RegisterEnum("diagnose.L3TableRequest_From", L3TableRequest_From_name, L3TableRequest_From_value)
	proto.RegisterType((*DiagnoseRequest)(nil), "diagnose.DiagnoseRequest")
	proto.RegisterType((*DiagnoseResponse)(nil), "diagnose.DiagnoseResponse")
	proto.RegisterType((*ArpItem)(nil), "diagnose.ArpItem")
	proto.RegisterType((*L3TableRequest)(nil), "diagnose.L3TableRequest")
	proto.RegisterType((*L3TableResponse)(nil), "diagnose.L3TableResponse")
	proto.RegisterType((*FlowItem)(nil), "diagnose.FlowItem")
	proto.RegisterType((*FlowTableRequest)(nil), "diagnose.FlowTableRequest")
	proto.RegisterType((*FlowTableResponse)(nil), "diagnose.FlowTableResponse")
}

func init() { proto.RegisterFile("diagnose.proto", fileDescriptor_d299e373e8035cd7) }

var fileDescriptor_d299e373e8035cd7 = []byte{
	// 853 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x96, 0xdd, 0x72, 0xdb, 0x44,
	0x14, 0xc7, 0x2b, 0xc7, 0x49, 0xa4, 0x93, 0xf8, 0xa3, 0x9a, 0xa6, 0x28, 0x6e, 0x30, 0x46, 0x74,
	0x98, 0x0c, 0x17, 0x99, 0x21, 0x3c, 0x81, 0x93, 0x62, 0xd7, 0xe0, 0x36, 0x19, 0xd5, 0x93, 0x61,
	0xb8, 0xd1, 0x6c, 0xa5, 0xb5, 0xd1, 0x54, 0x1f, 0xcb, 0xee, 0x49, 0xe2, 0xbc, 0x03, 0x0f, 0xc0,
	0x23, 0xf0, 0x0a, 0xbc, 0x01, 0x97, 0x3c, 0x02, 0x13, 0x5e, 0x84, 0xd9, 0x0f, 0xc9, 0x31, 0x84,
	0x5c, 0x54, 0xb9, 0xf2, 0xee, 0xf9, 0x9f, 0xfd, 0xef, 0x6a, 0xcf, 0x4f, 0x47, 0x86, 0x76, 0x9c,
	0x90, 0x45, 0x5e, 0x08, 0x7a, 0xc4, 0x78, 0x81, 0x85, 0x6b, 0x97, 0x73, 0xff, 0x0b, 0xe8, 0xbc,
	0x32, 0xe3, 0x80, 0xfe, 0x7c, 0x49, 0x05, 0xba, 0x5d, 0xd8, 0x20, 0x7c, 0xe1, 0x59, 0x03, 0xeb,
	0xd0, 0x09, 0xe4, 0xd0, 0xff, 0x0a, 0xba, 0xab, 0x24, 0xc1, 0x8a, 0x5c, 0x50, 0xf7, 0x39, 0x6c,
	0x71, 0x2a, 0x2e, 0x53, 0x34, 0x89, 0x66, 0xe6, 0xff, 0xd6, 0x80, 0xed, 0x21, 0x67, 0x13, 0xa4,
	0x99, 0xdb, 0x86, 0x46, 0xc2, 0x8c, 0xde, 0x48, 0x98, 0x74, 0xce, 0x48, 0xe4, 0x35, 0x06, 0xd6,
	0x61, 0x33, 0x90, 0x43, 0x77, 0x0f, 0xb6, 0x28, 0x8b, 0xc2, 0x24, 0xf6, 0x36, 0x06, 0xd6, 0x61,
	0x2b, 0xd8, 0xa4, 0x2c, 0x9a, 0xc4, 0xee, 0x3e, 0xd8, 0x48, 0x58, 0x88, 0x37, 0x8c, 0x7a, 0x4d,
	0x25, 0x6c, 0x23, 0x61, 0xb3, 0x1b, 0x46, 0x4b, 0x89, 0x15, 0x1c, 0xbd, 0xcd, 0x4a, 0x3a, 0x2f,
	0x38, 0xba, 0x9f, 0x02, 0xe0, 0x32, 0x64, 0x24, 0xfa, 0x40, 0x51, 0x78, 0xa0, 0x76, 0x71, 0x70,
	0x79, 0xae, 0x03, 0x52, 0xe6, 0x2b, 0x79, 0x47, 0xcb, 0xbc, 0x92, 0xa5, 0xf1, 0x32, 0x7c, 0x7f,
	0x83, 0x54, 0x78, 0xbb, 0x4a, 0xdc, 0xc6, 0xe5, 0x89, 0x9c, 0x4a, 0x89, 0x97, 0x52, 0x4b, 0x4b,
	0xdc, 0x48, 0x07, 0x6a, 0xcf, 0x94, 0x08, 0x0c, 0x73, 0xe1, 0xb5, 0x95, 0x68, 0xe3, 0x72, 0x4a,
	0x04, 0xbe, 0x55, 0x2a, 0x5f, 0xa9, 0x1d, 0xad, 0x72, 0xa3, 0xfa, 0x04, 0xda, 0xd3, 0x6f, 0x66,
	0xe4, 0x7d, 0x5a, 0x5d, 0xfd, 0x0b, 0x70, 0x12, 0xa4, 0x59, 0x38, 0xe7, 0x45, 0xa6, 0xee, 0xad,
	0x15, 0xd8, 0x32, 0x30, 0xe2, 0x45, 0xe6, 0x1f, 0x43, 0x53, 0xfe, 0xba, 0xcf, 0xa0, 0x3b, 0x0a,
	0xce, 0xde, 0x84, 0xb3, 0x60, 0x38, 0x1a, 0x4d, 0x4e, 0xc3, 0xd9, 0x6c, 0xda, 0x6d, 0xfe, 0x27,
	0x3a, 0x0c, 0xce, 0xbb, 0xb6, 0x3f, 0x84, 0x4e, 0xb5, 0x85, 0x29, 0xdc, 0x11, 0x38, 0x84, 0xb3,
	0x50, 0xda, 0x0a, 0xcf, 0x1a, 0x6c, 0x1c, 0xee, 0x1c, 0x3f, 0x3d, 0xaa, 0xf8, 0x30, 0xa5, 0x0b,
	0x6c, 0xa2, 0x07, 0xc2, 0xff, 0xa5, 0x09, 0xf6, 0x28, 0x2d, 0xae, 0x55, 0x45, 0xef, 0x16, 0xc6,
	0x5a, 0x2f, 0xcc, 0x01, 0x80, 0xe0, 0x51, 0x68, 0xca, 0xd9, 0xd0, 0x87, 0x17, 0x3c, 0xfa, 0x56,
	0x55, 0xf4, 0x00, 0x20, 0x16, 0x18, 0xae, 0x15, 0xdb, 0x8e, 0x05, 0x6a, 0x75, 0x0f, 0xb6, 0xe4,
	0xda, 0x84, 0xa9, 0x6a, 0x3b, 0xc1, 0xa6, 0xe0, 0xd1, 0x84, 0xc9, 0xb0, 0x5c, 0x94, 0x30, 0x55,
	0x69, 0x27, 0xd8, 0x8c, 0x05, 0x4e, 0x98, 0xdb, 0x03, 0x5b, 0x61, 0x1c, 0x15, 0xa9, 0xb7, 0xa5,
	0x9d, 0xca, 0xb9, 0x3c, 0xa0, 0x74, 0x52, 0x78, 0x6c, 0xeb, 0x03, 0x0a, 0x1e, 0x29, 0x3c, 0xf6,
	0x41, 0x6e, 0xa8, 0x25, 0x5b, 0x4b, 0xb1, 0xc0, 0x52, 0xaa, 0xa0, 0x72, 0x1e, 0x82, 0xea, 0xd9,
	0xc3, 0x50, 0xed, 0x3d, 0x04, 0xd5, 0xf3, 0xff, 0x87, 0xea, 0x93, 0x75, 0xa8, 0xbe, 0x84, 0x4e,
	0x94, 0x26, 0x34, 0xc7, 0x70, 0x9e, 0x70, 0xcd, 0x4e, 0x5f, 0x65, 0xb4, 0x74, 0x78, 0x24, 0xa3,
	0x6f, 0x55, 0x9e, 0xa0, 0xfc, 0x8a, 0xf2, 0x55, 0xde, 0x67, 0x3a, 0x4f, 0x87, 0xcb, 0xbc, 0x97,
	0xd0, 0x36, 0x7e, 0x25, 0x8a, 0x03, 0x95, 0xb6, 0xab, 0xa3, 0x06, 0xd6, 0x97, 0xd0, 0x36, 0x6e,
	0x65, 0xd6, 0xe7, 0x3a, 0x4b, 0x47, 0x0d, 0xb4, 0x2e, 0x74, 0x25, 0x0d, 0x77, 0xb1, 0xf5, 0x47,
	0xf0, 0xf4, 0x4e, 0xcc, 0x70, 0xf6, 0x35, 0xc0, 0x3c, 0x2d, 0xae, 0xd7, 0x40, 0x73, 0x57, 0xa0,
	0x95, 0x48, 0x05, 0xce, 0xdc, 0x8c, 0xc4, 0xf1, 0xef, 0x00, 0x76, 0xd9, 0x68, 0xdc, 0xef, 0xa1,
	0x3b, 0xa6, 0x38, 0xe3, 0x49, 0x4c, 0x73, 0x7c, 0x87, 0x04, 0x2f, 0x85, 0xbb, 0xbf, 0x5a, 0xff,
	0xaf, 0xae, 0xd5, 0xeb, 0xdd, 0x27, 0xe9, 0xa3, 0xf8, 0x4f, 0xdc, 0xd7, 0xd0, 0x1a, 0x53, 0x3c,
	0xbb, 0x12, 0x27, 0x3c, 0x89, 0x17, 0xb4, 0x86, 0xd3, 0x08, 0x76, 0xb4, 0x93, 0xa4, 0xa3, 0x86,
	0x8f, 0x7e, 0xbc, 0xb3, 0x2b, 0x31, 0xc9, 0x91, 0xf2, 0x39, 0x89, 0xea, 0x1c, 0xea, 0x15, 0x38,
	0x63, 0x8a, 0x13, 0x36, 0x4d, 0xf2, 0x0f, 0x1f, 0xef, 0x32, 0x86, 0x5d, 0xe5, 0x32, 0x8c, 0x63,
	0x4e, 0x45, 0xed, 0x3b, 0x1a, 0xa6, 0xe9, 0x45, 0xf6, 0x43, 0x96, 0xd6, 0xbd, 0x23, 0x5d, 0xb2,
	0x37, 0x84, 0xb1, 0x24, 0x5f, 0xd4, 0x7d, 0xba, 0x13, 0x1e, 0x61, 0xfa, 0xee, 0xa7, 0xe2, 0xba,
	0xfe, 0x35, 0x09, 0x8a, 0xd3, 0x44, 0xe0, 0x23, 0x40, 0x79, 0x41, 0xb9, 0x48, 0x8a, 0xfc, 0xe3,
	0x9d, 0xbe, 0x83, 0x8e, 0x3a, 0x12, 0xca, 0x37, 0x50, 0x0c, 0xa3, 0xf4, 0x31, 0xc0, 0xd4, 0xf7,
	0x2e, 0xdf, 0xd3, 0xba, 0x24, 0xbc, 0x2e, 0x04, 0xe6, 0x24, 0xa3, 0x75, 0x7d, 0x2e, 0x32, 0xd9,
	0x07, 0x68, 0xed, 0x3e, 0x70, 0x91, 0x92, 0xfc, 0xb4, 0xc8, 0xe7, 0x49, 0x0d, 0x9c, 0x4e, 0x01,
	0xc6, 0x14, 0xcd, 0xc7, 0xd5, 0xf5, 0x56, 0xb9, 0xeb, 0x9f, 0xf4, 0xde, 0xfe, 0x3d, 0x4a, 0x65,
	0x32, 0x51, 0x28, 0x55, 0xbd, 0xd3, 0xed, 0xad, 0xf7, 0xc7, 0x35, 0xa3, 0x17, 0xf7, 0x6a, 0xa5,
	0xd5, 0x49, 0xef, 0x8f, 0xdb, 0xbe, 0xf5, 0xe7, 0x6d, 0xdf, 0xfa, 0xeb, 0xb6, 0x6f, 0xfd, 0xfa,
	0x77, 0xff, 0xc9, 0x8f, 0xd5, 0x9f, 0xbc, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xde, 0x2b, 0x1d,
	0x72, 0xff, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DiagnoseClient is the client API for Diagnose service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DiagnoseClient interface {
	GetTridentStatus(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	// TOPOLOGY
	GetOvsBridges(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetOvsPorts(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetOvsInterfaces(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetIpLink(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetIpAddress(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetAllVmXml(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetBridgeMapping(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetBrctlShow(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetIpsetList(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetOvsVersion(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	// ACL
	GetIptablesAcls(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	// FLOW
	GetOvsBridgeFlow(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	// Platform Info
	GetHostname(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetVmStates(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetVlanConfig(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error)
	GetL3Table(ctx context.Context, in *L3TableRequest, opts ...grpc.CallOption) (*L3TableResponse, error)
	GetFlowTable(ctx context.Context, in *FlowTableRequest, opts ...grpc.CallOption) (*FlowTableResponse, error)
}

type diagnoseClient struct {
	cc *grpc.ClientConn
}

func NewDiagnoseClient(cc *grpc.ClientConn) DiagnoseClient {
	return &diagnoseClient{cc}
}

func (c *diagnoseClient) GetTridentStatus(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetTridentStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetOvsBridges(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetOvsBridges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetOvsPorts(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetOvsPorts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetOvsInterfaces(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetOvsInterfaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetIpLink(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetIpLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetIpAddress(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetIpAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetAllVmXml(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetAllVmXml", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetBridgeMapping(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetBridgeMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetBrctlShow(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetBrctlShow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetIpsetList(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetIpsetList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetOvsVersion(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetOvsVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetIptablesAcls(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetIptablesAcls", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetOvsBridgeFlow(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetOvsBridgeFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetHostname(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetHostname", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetVmStates(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetVmStates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetVlanConfig(ctx context.Context, in *DiagnoseRequest, opts ...grpc.CallOption) (*DiagnoseResponse, error) {
	out := new(DiagnoseResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetVlanConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetL3Table(ctx context.Context, in *L3TableRequest, opts ...grpc.CallOption) (*L3TableResponse, error) {
	out := new(L3TableResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetL3Table", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diagnoseClient) GetFlowTable(ctx context.Context, in *FlowTableRequest, opts ...grpc.CallOption) (*FlowTableResponse, error) {
	out := new(FlowTableResponse)
	err := c.cc.Invoke(ctx, "/diagnose.Diagnose/GetFlowTable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiagnoseServer is the server API for Diagnose service.
type DiagnoseServer interface {
	GetTridentStatus(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	// TOPOLOGY
	GetOvsBridges(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetOvsPorts(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetOvsInterfaces(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetIpLink(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetIpAddress(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetAllVmXml(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetBridgeMapping(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetBrctlShow(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetIpsetList(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetOvsVersion(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	// ACL
	GetIptablesAcls(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	// FLOW
	GetOvsBridgeFlow(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	// Platform Info
	GetHostname(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetVmStates(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetVlanConfig(context.Context, *DiagnoseRequest) (*DiagnoseResponse, error)
	GetL3Table(context.Context, *L3TableRequest) (*L3TableResponse, error)
	GetFlowTable(context.Context, *FlowTableRequest) (*FlowTableResponse, error)
}

// UnimplementedDiagnoseServer can be embedded to have forward compatible implementations.
type UnimplementedDiagnoseServer struct {
}

func (*UnimplementedDiagnoseServer) GetTridentStatus(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTridentStatus not implemented")
}
func (*UnimplementedDiagnoseServer) GetOvsBridges(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOvsBridges not implemented")
}
func (*UnimplementedDiagnoseServer) GetOvsPorts(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOvsPorts not implemented")
}
func (*UnimplementedDiagnoseServer) GetOvsInterfaces(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOvsInterfaces not implemented")
}
func (*UnimplementedDiagnoseServer) GetIpLink(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIpLink not implemented")
}
func (*UnimplementedDiagnoseServer) GetIpAddress(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIpAddress not implemented")
}
func (*UnimplementedDiagnoseServer) GetAllVmXml(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllVmXml not implemented")
}
func (*UnimplementedDiagnoseServer) GetBridgeMapping(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBridgeMapping not implemented")
}
func (*UnimplementedDiagnoseServer) GetBrctlShow(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBrctlShow not implemented")
}
func (*UnimplementedDiagnoseServer) GetIpsetList(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIpsetList not implemented")
}
func (*UnimplementedDiagnoseServer) GetOvsVersion(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOvsVersion not implemented")
}
func (*UnimplementedDiagnoseServer) GetIptablesAcls(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIptablesAcls not implemented")
}
func (*UnimplementedDiagnoseServer) GetOvsBridgeFlow(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOvsBridgeFlow not implemented")
}
func (*UnimplementedDiagnoseServer) GetHostname(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHostname not implemented")
}
func (*UnimplementedDiagnoseServer) GetVmStates(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVmStates not implemented")
}
func (*UnimplementedDiagnoseServer) GetVlanConfig(ctx context.Context, req *DiagnoseRequest) (*DiagnoseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVlanConfig not implemented")
}
func (*UnimplementedDiagnoseServer) GetL3Table(ctx context.Context, req *L3TableRequest) (*L3TableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetL3Table not implemented")
}
func (*UnimplementedDiagnoseServer) GetFlowTable(ctx context.Context, req *FlowTableRequest) (*FlowTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFlowTable not implemented")
}

func RegisterDiagnoseServer(s *grpc.Server, srv DiagnoseServer) {
	s.RegisterService(&_Diagnose_serviceDesc, srv)
}

func _Diagnose_GetTridentStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetTridentStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetTridentStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetTridentStatus(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetOvsBridges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetOvsBridges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetOvsBridges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetOvsBridges(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetOvsPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetOvsPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetOvsPorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetOvsPorts(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetOvsInterfaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetOvsInterfaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetOvsInterfaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetOvsInterfaces(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetIpLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetIpLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetIpLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetIpLink(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetIpAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetIpAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetIpAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetIpAddress(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetAllVmXml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetAllVmXml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetAllVmXml",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetAllVmXml(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetBridgeMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetBridgeMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetBridgeMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetBridgeMapping(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetBrctlShow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetBrctlShow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetBrctlShow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetBrctlShow(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetIpsetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetIpsetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetIpsetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetIpsetList(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetOvsVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetOvsVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetOvsVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetOvsVersion(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetIptablesAcls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetIptablesAcls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetIptablesAcls",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetIptablesAcls(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetOvsBridgeFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetOvsBridgeFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetOvsBridgeFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetOvsBridgeFlow(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetHostname_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetHostname(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetHostname",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetHostname(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetVmStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetVmStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetVmStates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetVmStates(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetVlanConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnoseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetVlanConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetVlanConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetVlanConfig(ctx, req.(*DiagnoseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetL3Table_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(L3TableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetL3Table(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetL3Table",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetL3Table(ctx, req.(*L3TableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Diagnose_GetFlowTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiagnoseServer).GetFlowTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/diagnose.Diagnose/GetFlowTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiagnoseServer).GetFlowTable(ctx, req.(*FlowTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Diagnose_serviceDesc = grpc.ServiceDesc{
	ServiceName: "diagnose.Diagnose",
	HandlerType: (*DiagnoseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTridentStatus",
			Handler:    _Diagnose_GetTridentStatus_Handler,
		},
		{
			MethodName: "GetOvsBridges",
			Handler:    _Diagnose_GetOvsBridges_Handler,
		},
		{
			MethodName: "GetOvsPorts",
			Handler:    _Diagnose_GetOvsPorts_Handler,
		},
		{
			MethodName: "GetOvsInterfaces",
			Handler:    _Diagnose_GetOvsInterfaces_Handler,
		},
		{
			MethodName: "GetIpLink",
			Handler:    _Diagnose_GetIpLink_Handler,
		},
		{
			MethodName: "GetIpAddress",
			Handler:    _Diagnose_GetIpAddress_Handler,
		},
		{
			MethodName: "GetAllVmXml",
			Handler:    _Diagnose_GetAllVmXml_Handler,
		},
		{
			MethodName: "GetBridgeMapping",
			Handler:    _Diagnose_GetBridgeMapping_Handler,
		},
		{
			MethodName: "GetBrctlShow",
			Handler:    _Diagnose_GetBrctlShow_Handler,
		},
		{
			MethodName: "GetIpsetList",
			Handler:    _Diagnose_GetIpsetList_Handler,
		},
		{
			MethodName: "GetOvsVersion",
			Handler:    _Diagnose_GetOvsVersion_Handler,
		},
		{
			MethodName: "GetIptablesAcls",
			Handler:    _Diagnose_GetIptablesAcls_Handler,
		},
		{
			MethodName: "GetOvsBridgeFlow",
			Handler:    _Diagnose_GetOvsBridgeFlow_Handler,
		},
		{
			MethodName: "GetHostname",
			Handler:    _Diagnose_GetHostname_Handler,
		},
		{
			MethodName: "GetVmStates",
			Handler:    _Diagnose_GetVmStates_Handler,
		},
		{
			MethodName: "GetVlanConfig",
			Handler:    _Diagnose_GetVlanConfig_Handler,
		},
		{
			MethodName: "GetL3Table",
			Handler:    _Diagnose_GetL3Table_Handler,
		},
		{
			MethodName: "GetFlowTable",
			Handler:    _Diagnose_GetFlowTable_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "diagnose.proto",
}

func (m *DiagnoseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiagnoseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiagnoseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Arg != nil {
		i -= len(*m.Arg)
		copy(dAtA[i:], *m.Arg)
		i = encodeVarintDiagnose(dAtA, i, uint64(len(*m.Arg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiagnoseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiagnoseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiagnoseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != nil {
		i -= len(*m.Result)
		copy(dAtA[i:], *m.Result)
		i = encodeVarintDiagnose(dAtA, i, uint64(len(*m.Result)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArpItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArpItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArpItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RxLastNs != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.RxLastNs))
		i--
		dAtA[i] = 0x78
	}
	if m.TxLastNs != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.TxLastNs))
		i--
		dAtA[i] = 0x70
	}
	if m.RxBytes != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.RxBytes))
		i--
		dAtA[i] = 0x68
	}
	if m.TxBytes != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.TxBytes))
		i--
		dAtA[i] = 0x60
	}
	if m.RxPackets != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.RxPackets))
		i--
		dAtA[i] = 0x58
	}
	if m.TxPackets != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.TxPackets))
		i--
		dAtA[i] = 0x50
	}
	if m.TapPort != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.TapPort))
		i--
		dAtA[i] = 0x28
	}
	if m.TapType != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.TapType))
		i--
		dAtA[i] = 0x20
	}
	if m.EpcId != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.EpcId))
		i--
		dAtA[i] = 0x18
	}
	if m.Mac != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.Mac))
		i--
		dAtA[i] = 0x10
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintDiagnose(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L3TableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3TableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L3TableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ItemFrom != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.ItemFrom))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L3TableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3TableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L3TableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ArpItems) > 0 {
		for iNdEx := len(m.ArpItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArpItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDiagnose(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlowItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServerLastNs != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.ServerLastNs))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.ClientLastNs != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.ClientLastNs))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.ServerFirstNs != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.ServerFirstNs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.ClientFirstNs != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.ClientFirstNs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.RxBytes != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.RxBytes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.TxBytes != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.TxBytes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.RxPackets != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.RxPackets))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.TxPackets != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.TxPackets))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.TapPort != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.TapPort))
		i--
		dAtA[i] = 0x48
	}
	if m.DstPort != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.DstPort))
		i--
		dAtA[i] = 0x40
	}
	if m.SrcPort != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.SrcPort))
		i--
		dAtA[i] = 0x38
	}
	if m.Protocol != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.Protocol))
		i--
		dAtA[i] = 0x30
	}
	if m.DstIp != nil {
		i -= len(*m.DstIp)
		copy(dAtA[i:], *m.DstIp)
		i = encodeVarintDiagnose(dAtA, i, uint64(len(*m.DstIp)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SrcIp != nil {
		i -= len(*m.SrcIp)
		copy(dAtA[i:], *m.SrcIp)
		i = encodeVarintDiagnose(dAtA, i, uint64(len(*m.SrcIp)))
		i--
		dAtA[i] = 0x22
	}
	if m.DstEpcId != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.DstEpcId))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcEpcId != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.SrcEpcId))
		i--
		dAtA[i] = 0x10
	}
	if m.TapType != nil {
		i = encodeVarintDiagnose(dAtA, i, uint64(*m.TapType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *FlowTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FlowItems) > 0 {
		for iNdEx := len(m.FlowItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FlowItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDiagnose(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDiagnose(dAtA []byte, offset int, v uint64) int {
	offset -= sovDiagnose(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DiagnoseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Arg != nil {
		l = len(*m.Arg)
		n += 1 + l + sovDiagnose(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiagnoseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = len(*m.Result)
		n += 1 + l + sovDiagnose(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArpItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 1 + l + sovDiagnose(uint64(l))
	}
	if m.Mac != nil {
		n += 1 + sovDiagnose(uint64(*m.Mac))
	}
	if m.EpcId != nil {
		n += 1 + sovDiagnose(uint64(*m.EpcId))
	}
	if m.TapType != nil {
		n += 1 + sovDiagnose(uint64(*m.TapType))
	}
	if m.TapPort != nil {
		n += 1 + sovDiagnose(uint64(*m.TapPort))
	}
	if m.TxPackets != nil {
		n += 1 + sovDiagnose(uint64(*m.TxPackets))
	}
	if m.RxPackets != nil {
		n += 1 + sovDiagnose(uint64(*m.RxPackets))
	}
	if m.TxBytes != nil {
		n += 1 + sovDiagnose(uint64(*m.TxBytes))
	}
	if m.RxBytes != nil {
		n += 1 + sovDiagnose(uint64(*m.RxBytes))
	}
	if m.TxLastNs != nil {
		n += 1 + sovDiagnose(uint64(*m.TxLastNs))
	}
	if m.RxLastNs != nil {
		n += 1 + sovDiagnose(uint64(*m.RxLastNs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L3TableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemFrom != nil {
		n += 1 + sovDiagnose(uint64(*m.ItemFrom))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L3TableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ArpItems) > 0 {
		for _, e := range m.ArpItems {
			l = e.Size()
			n += 1 + l + sovDiagnose(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TapType != nil {
		n += 1 + sovDiagnose(uint64(*m.TapType))
	}
	if m.SrcEpcId != nil {
		n += 1 + sovDiagnose(uint64(*m.SrcEpcId))
	}
	if m.DstEpcId != nil {
		n += 1 + sovDiagnose(uint64(*m.DstEpcId))
	}
	if m.SrcIp != nil {
		l = len(*m.SrcIp)
		n += 1 + l + sovDiagnose(uint64(l))
	}
	if m.DstIp != nil {
		l = len(*m.DstIp)
		n += 1 + l + sovDiagnose(uint64(l))
	}
	if m.Protocol != nil {
		n += 1 + sovDiagnose(uint64(*m.Protocol))
	}
	if m.SrcPort != nil {
		n += 1 + sovDiagnose(uint64(*m.SrcPort))
	}
	if m.DstPort != nil {
		n += 1 + sovDiagnose(uint64(*m.DstPort))
	}
	if m.TapPort != nil {
		n += 1 + sovDiagnose(uint64(*m.TapPort))
	}
	if m.TxPackets != nil {
		n += 2 + sovDiagnose(uint64(*m.TxPackets))
	}
	if m.RxPackets != nil {
		n += 2 + sovDiagnose(uint64(*m.RxPackets))
	}
	if m.TxBytes != nil {
		n += 2 + sovDiagnose(uint64(*m.TxBytes))
	}
	if m.RxBytes != nil {
		n += 2 + sovDiagnose(uint64(*m.RxBytes))
	}
	if m.ClientFirstNs != nil {
		n += 2 + sovDiagnose(uint64(*m.ClientFirstNs))
	}
	if m.ServerFirstNs != nil {
		n += 2 + sovDiagnose(uint64(*m.ServerFirstNs))
	}
	if m.ClientLastNs != nil {
		n += 2 + sovDiagnose(uint64(*m.ClientLastNs))
	}
	if m.ServerLastNs != nil {
		n += 2 + sovDiagnose(uint64(*m.ServerLastNs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FlowItems) > 0 {
		for _, e := range m.FlowItems {
			l = e.Size()
			n += 1 + l + sovDiagnose(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDiagnose(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDiagnose(x uint64) (n int) {
	return sovDiagnose(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DiagnoseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiagnose
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiagnoseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiagnoseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiagnose
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiagnose
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Arg = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiagnose(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDiagnose
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiagnoseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiagnose
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiagnoseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiagnoseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiagnose
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiagnose
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Result = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiagnose(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDiagnose
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArpItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiagnose
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArpItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArpItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiagnose
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiagnose
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mac = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpcId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EpcId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TapType = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TapPort = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxPackets = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RxPackets = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxBytes = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RxBytes = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxLastNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxLastNs = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxLastNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RxLastNs = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDiagnose(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDiagnose
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L3TableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiagnose
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3TableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3TableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemFrom", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ItemFrom = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDiagnose(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDiagnose
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L3TableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiagnose
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3TableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3TableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArpItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiagnose
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiagnose
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArpItems = append(m.ArpItems, &ArpItem{})
			if err := m.ArpItems[len(m.ArpItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiagnose(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDiagnose
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiagnose
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TapType = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcEpcId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SrcEpcId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstEpcId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DstEpcId = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiagnose
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiagnose
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SrcIp = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiagnose
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiagnose
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DstIp = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protocol = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SrcPort = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DstPort = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TapPort = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxPackets = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RxPackets = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxBytes = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RxBytes = &v
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientFirstNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClientFirstNs = &v
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerFirstNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServerFirstNs = &v
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLastNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClientLastNs = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerLastNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServerLastNs = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDiagnose(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDiagnose
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiagnose
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDiagnose(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDiagnose
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiagnose
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiagnose
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiagnose
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowItems = append(m.FlowItems, &FlowItem{})
			if err := m.FlowItems[len(m.FlowItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiagnose(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDiagnose
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDiagnose(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDiagnose
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDiagnose
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDiagnose
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDiagnose
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDiagnose
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDiagnose        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDiagnose          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDiagnose = fmt.Errorf("proto: unexpected end of group")
)
