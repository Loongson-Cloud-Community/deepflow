// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: metric.proto

package pb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MiniField struct {
	Ip                   []byte   `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Ip1                  []byte   `protobuf:"bytes,2,opt,name=ip1,proto3" json:"ip1,omitempty"`
	GlobalThreadId       uint32   `protobuf:"varint,3,opt,name=global_thread_id,json=globalThreadId,proto3" json:"global_thread_id,omitempty"`
	IsIpv6               uint32   `protobuf:"varint,4,opt,name=is_ipv6,json=isIpv6,proto3" json:"is_ipv6,omitempty"`
	L3EpcId              int32    `protobuf:"varint,5,opt,name=l3_epc_id,json=l3EpcId,proto3" json:"l3_epc_id,omitempty"`
	L3EpcId1             int32    `protobuf:"varint,6,opt,name=l3_epc_id1,json=l3EpcId1,proto3" json:"l3_epc_id1,omitempty"`
	Mac                  uint64   `protobuf:"varint,7,opt,name=mac,proto3" json:"mac,omitempty"`
	Mac1                 uint64   `protobuf:"varint,8,opt,name=mac1,proto3" json:"mac1,omitempty"`
	Direction            uint32   `protobuf:"varint,9,opt,name=direction,proto3" json:"direction,omitempty"`
	TapSide              uint32   `protobuf:"varint,10,opt,name=tap_side,json=tapSide,proto3" json:"tap_side,omitempty"`
	Protocol             uint32   `protobuf:"varint,11,opt,name=protocol,proto3" json:"protocol,omitempty"`
	AclGid               uint32   `protobuf:"varint,12,opt,name=acl_gid,json=aclGid,proto3" json:"acl_gid,omitempty"`
	ServerPort           uint32   `protobuf:"varint,13,opt,name=server_port,json=serverPort,proto3" json:"server_port,omitempty"`
	VtapId               uint32   `protobuf:"varint,14,opt,name=vtap_id,json=vtapId,proto3" json:"vtap_id,omitempty"`
	TapPort              uint64   `protobuf:"varint,15,opt,name=tap_port,json=tapPort,proto3" json:"tap_port,omitempty"`
	TapType              uint32   `protobuf:"varint,16,opt,name=tap_type,json=tapType,proto3" json:"tap_type,omitempty"`
	L7Protocol           uint32   `protobuf:"varint,17,opt,name=l7_protocol,json=l7Protocol,proto3" json:"l7_protocol,omitempty"`
	TagType              uint32   `protobuf:"varint,18,opt,name=tag_type,json=tagType,proto3" json:"tag_type,omitempty"`
	TagValue             uint32   `protobuf:"varint,19,opt,name=tag_value,json=tagValue,proto3" json:"tag_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MiniField) Reset()         { *m = MiniField{} }
func (m *MiniField) String() string { return proto.CompactTextString(m) }
func (*MiniField) ProtoMessage()    {}
func (*MiniField) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{0}
}
func (m *MiniField) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MiniField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MiniField.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MiniField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MiniField.Merge(m, src)
}
func (m *MiniField) XXX_Size() int {
	return m.Size()
}
func (m *MiniField) XXX_DiscardUnknown() {
	xxx_messageInfo_MiniField.DiscardUnknown(m)
}

var xxx_messageInfo_MiniField proto.InternalMessageInfo

func (m *MiniField) GetIp() []byte {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *MiniField) GetIp1() []byte {
	if m != nil {
		return m.Ip1
	}
	return nil
}

func (m *MiniField) GetGlobalThreadId() uint32 {
	if m != nil {
		return m.GlobalThreadId
	}
	return 0
}

func (m *MiniField) GetIsIpv6() uint32 {
	if m != nil {
		return m.IsIpv6
	}
	return 0
}

func (m *MiniField) GetL3EpcId() int32 {
	if m != nil {
		return m.L3EpcId
	}
	return 0
}

func (m *MiniField) GetL3EpcId1() int32 {
	if m != nil {
		return m.L3EpcId1
	}
	return 0
}

func (m *MiniField) GetMac() uint64 {
	if m != nil {
		return m.Mac
	}
	return 0
}

func (m *MiniField) GetMac1() uint64 {
	if m != nil {
		return m.Mac1
	}
	return 0
}

func (m *MiniField) GetDirection() uint32 {
	if m != nil {
		return m.Direction
	}
	return 0
}

func (m *MiniField) GetTapSide() uint32 {
	if m != nil {
		return m.TapSide
	}
	return 0
}

func (m *MiniField) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *MiniField) GetAclGid() uint32 {
	if m != nil {
		return m.AclGid
	}
	return 0
}

func (m *MiniField) GetServerPort() uint32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *MiniField) GetVtapId() uint32 {
	if m != nil {
		return m.VtapId
	}
	return 0
}

func (m *MiniField) GetTapPort() uint64 {
	if m != nil {
		return m.TapPort
	}
	return 0
}

func (m *MiniField) GetTapType() uint32 {
	if m != nil {
		return m.TapType
	}
	return 0
}

func (m *MiniField) GetL7Protocol() uint32 {
	if m != nil {
		return m.L7Protocol
	}
	return 0
}

func (m *MiniField) GetTagType() uint32 {
	if m != nil {
		return m.TagType
	}
	return 0
}

func (m *MiniField) GetTagValue() uint32 {
	if m != nil {
		return m.TagValue
	}
	return 0
}

type MiniTag struct {
	Field                *MiniField `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	Code                 uint64     `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MiniTag) Reset()         { *m = MiniTag{} }
func (m *MiniTag) String() string { return proto.CompactTextString(m) }
func (*MiniTag) ProtoMessage()    {}
func (*MiniTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{1}
}
func (m *MiniTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MiniTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MiniTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MiniTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MiniTag.Merge(m, src)
}
func (m *MiniTag) XXX_Size() int {
	return m.Size()
}
func (m *MiniTag) XXX_DiscardUnknown() {
	xxx_messageInfo_MiniTag.DiscardUnknown(m)
}

var xxx_messageInfo_MiniTag proto.InternalMessageInfo

func (m *MiniTag) GetField() *MiniField {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *MiniTag) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

type Meter struct {
	MeterId              uint32      `protobuf:"varint,1,opt,name=meter_id,json=meterId,proto3" json:"meter_id,omitempty"`
	Flow                 *FlowMeter  `protobuf:"bytes,2,opt,name=flow,proto3" json:"flow,omitempty"`
	Usage                *UsageMeter `protobuf:"bytes,3,opt,name=usage,proto3" json:"usage,omitempty"`
	App                  *AppMeter   `protobuf:"bytes,4,opt,name=app,proto3" json:"app,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Meter) Reset()         { *m = Meter{} }
func (m *Meter) String() string { return proto.CompactTextString(m) }
func (*Meter) ProtoMessage()    {}
func (*Meter) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{2}
}
func (m *Meter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Meter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Meter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Meter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Meter.Merge(m, src)
}
func (m *Meter) XXX_Size() int {
	return m.Size()
}
func (m *Meter) XXX_DiscardUnknown() {
	xxx_messageInfo_Meter.DiscardUnknown(m)
}

var xxx_messageInfo_Meter proto.InternalMessageInfo

func (m *Meter) GetMeterId() uint32 {
	if m != nil {
		return m.MeterId
	}
	return 0
}

func (m *Meter) GetFlow() *FlowMeter {
	if m != nil {
		return m.Flow
	}
	return nil
}

func (m *Meter) GetUsage() *UsageMeter {
	if m != nil {
		return m.Usage
	}
	return nil
}

func (m *Meter) GetApp() *AppMeter {
	if m != nil {
		return m.App
	}
	return nil
}

type Document struct {
	Timestamp            uint32   `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Tag                  *MiniTag `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	Meter                *Meter   `protobuf:"bytes,3,opt,name=meter,proto3" json:"meter,omitempty"`
	Flags                uint32   `protobuf:"varint,4,opt,name=flags,proto3" json:"flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Document) Reset()         { *m = Document{} }
func (m *Document) String() string { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()    {}
func (*Document) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{3}
}
func (m *Document) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Document) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Document.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Document) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Document.Merge(m, src)
}
func (m *Document) XXX_Size() int {
	return m.Size()
}
func (m *Document) XXX_DiscardUnknown() {
	xxx_messageInfo_Document.DiscardUnknown(m)
}

var xxx_messageInfo_Document proto.InternalMessageInfo

func (m *Document) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Document) GetTag() *MiniTag {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *Document) GetMeter() *Meter {
	if m != nil {
		return m.Meter
	}
	return nil
}

func (m *Document) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

// flow meter
type FlowMeter struct {
	Traffic              *Traffic     `protobuf:"bytes,1,opt,name=traffic,proto3" json:"traffic,omitempty"`
	Latency              *Latency     `protobuf:"bytes,2,opt,name=latency,proto3" json:"latency,omitempty"`
	Performance          *Performance `protobuf:"bytes,3,opt,name=performance,proto3" json:"performance,omitempty"`
	Anomaly              *Anomaly     `protobuf:"bytes,4,opt,name=anomaly,proto3" json:"anomaly,omitempty"`
	FlowLoad             *FlowLoad    `protobuf:"bytes,5,opt,name=flow_load,json=flowLoad,proto3" json:"flow_load,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *FlowMeter) Reset()         { *m = FlowMeter{} }
func (m *FlowMeter) String() string { return proto.CompactTextString(m) }
func (*FlowMeter) ProtoMessage()    {}
func (*FlowMeter) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{4}
}
func (m *FlowMeter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowMeter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowMeter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowMeter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowMeter.Merge(m, src)
}
func (m *FlowMeter) XXX_Size() int {
	return m.Size()
}
func (m *FlowMeter) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowMeter.DiscardUnknown(m)
}

var xxx_messageInfo_FlowMeter proto.InternalMessageInfo

func (m *FlowMeter) GetTraffic() *Traffic {
	if m != nil {
		return m.Traffic
	}
	return nil
}

func (m *FlowMeter) GetLatency() *Latency {
	if m != nil {
		return m.Latency
	}
	return nil
}

func (m *FlowMeter) GetPerformance() *Performance {
	if m != nil {
		return m.Performance
	}
	return nil
}

func (m *FlowMeter) GetAnomaly() *Anomaly {
	if m != nil {
		return m.Anomaly
	}
	return nil
}

func (m *FlowMeter) GetFlowLoad() *FlowLoad {
	if m != nil {
		return m.FlowLoad
	}
	return nil
}

type Traffic struct {
	PacketTx             uint64   `protobuf:"varint,1,opt,name=packet_tx,json=packetTx,proto3" json:"packet_tx,omitempty"`
	PacketRx             uint64   `protobuf:"varint,2,opt,name=packet_rx,json=packetRx,proto3" json:"packet_rx,omitempty"`
	ByteTx               uint64   `protobuf:"varint,3,opt,name=byte_tx,json=byteTx,proto3" json:"byte_tx,omitempty"`
	ByteRx               uint64   `protobuf:"varint,4,opt,name=byte_rx,json=byteRx,proto3" json:"byte_rx,omitempty"`
	L3ByteTx             uint64   `protobuf:"varint,5,opt,name=l3_byte_tx,json=l3ByteTx,proto3" json:"l3_byte_tx,omitempty"`
	L3ByteRx             uint64   `protobuf:"varint,6,opt,name=l3_byte_rx,json=l3ByteRx,proto3" json:"l3_byte_rx,omitempty"`
	L4ByteTx             uint64   `protobuf:"varint,7,opt,name=l4_byte_tx,json=l4ByteTx,proto3" json:"l4_byte_tx,omitempty"`
	L4ByteRx             uint64   `protobuf:"varint,8,opt,name=l4_byte_rx,json=l4ByteRx,proto3" json:"l4_byte_rx,omitempty"`
	NewFlow              uint64   `protobuf:"varint,9,opt,name=new_flow,json=newFlow,proto3" json:"new_flow,omitempty"`
	ClosedFlow           uint64   `protobuf:"varint,10,opt,name=closed_flow,json=closedFlow,proto3" json:"closed_flow,omitempty"`
	L7Request            uint32   `protobuf:"varint,11,opt,name=l7_request,json=l7Request,proto3" json:"l7_request,omitempty"`
	L7Response           uint32   `protobuf:"varint,12,opt,name=l7_response,json=l7Response,proto3" json:"l7_response,omitempty"`
	Syn                  uint32   `protobuf:"varint,13,opt,name=syn,proto3" json:"syn,omitempty"`
	Synack               uint32   `protobuf:"varint,14,opt,name=synack,proto3" json:"synack,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Traffic) Reset()         { *m = Traffic{} }
func (m *Traffic) String() string { return proto.CompactTextString(m) }
func (*Traffic) ProtoMessage()    {}
func (*Traffic) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{5}
}
func (m *Traffic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Traffic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Traffic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Traffic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Traffic.Merge(m, src)
}
func (m *Traffic) XXX_Size() int {
	return m.Size()
}
func (m *Traffic) XXX_DiscardUnknown() {
	xxx_messageInfo_Traffic.DiscardUnknown(m)
}

var xxx_messageInfo_Traffic proto.InternalMessageInfo

func (m *Traffic) GetPacketTx() uint64 {
	if m != nil {
		return m.PacketTx
	}
	return 0
}

func (m *Traffic) GetPacketRx() uint64 {
	if m != nil {
		return m.PacketRx
	}
	return 0
}

func (m *Traffic) GetByteTx() uint64 {
	if m != nil {
		return m.ByteTx
	}
	return 0
}

func (m *Traffic) GetByteRx() uint64 {
	if m != nil {
		return m.ByteRx
	}
	return 0
}

func (m *Traffic) GetL3ByteTx() uint64 {
	if m != nil {
		return m.L3ByteTx
	}
	return 0
}

func (m *Traffic) GetL3ByteRx() uint64 {
	if m != nil {
		return m.L3ByteRx
	}
	return 0
}

func (m *Traffic) GetL4ByteTx() uint64 {
	if m != nil {
		return m.L4ByteTx
	}
	return 0
}

func (m *Traffic) GetL4ByteRx() uint64 {
	if m != nil {
		return m.L4ByteRx
	}
	return 0
}

func (m *Traffic) GetNewFlow() uint64 {
	if m != nil {
		return m.NewFlow
	}
	return 0
}

func (m *Traffic) GetClosedFlow() uint64 {
	if m != nil {
		return m.ClosedFlow
	}
	return 0
}

func (m *Traffic) GetL7Request() uint32 {
	if m != nil {
		return m.L7Request
	}
	return 0
}

func (m *Traffic) GetL7Response() uint32 {
	if m != nil {
		return m.L7Response
	}
	return 0
}

func (m *Traffic) GetSyn() uint32 {
	if m != nil {
		return m.Syn
	}
	return 0
}

func (m *Traffic) GetSynack() uint32 {
	if m != nil {
		return m.Synack
	}
	return 0
}

// current max id = 21
type Latency struct {
	RttMax               uint32   `protobuf:"varint,1,opt,name=rtt_max,json=rttMax,proto3" json:"rtt_max,omitempty"`
	RttClientMax         uint32   `protobuf:"varint,2,opt,name=rtt_client_max,json=rttClientMax,proto3" json:"rtt_client_max,omitempty"`
	RttServerMax         uint32   `protobuf:"varint,3,opt,name=rtt_server_max,json=rttServerMax,proto3" json:"rtt_server_max,omitempty"`
	SrtMax               uint32   `protobuf:"varint,4,opt,name=srt_max,json=srtMax,proto3" json:"srt_max,omitempty"`
	ArtMax               uint32   `protobuf:"varint,5,opt,name=art_max,json=artMax,proto3" json:"art_max,omitempty"`
	RrtMax               uint32   `protobuf:"varint,6,opt,name=rrt_max,json=rrtMax,proto3" json:"rrt_max,omitempty"`
	CitMax               uint32   `protobuf:"varint,19,opt,name=cit_max,json=citMax,proto3" json:"cit_max,omitempty"`
	RttSum               uint64   `protobuf:"varint,7,opt,name=rtt_sum,json=rttSum,proto3" json:"rtt_sum,omitempty"`
	RttClientSum         uint64   `protobuf:"varint,8,opt,name=rtt_client_sum,json=rttClientSum,proto3" json:"rtt_client_sum,omitempty"`
	RttServerSum         uint64   `protobuf:"varint,9,opt,name=rtt_server_sum,json=rttServerSum,proto3" json:"rtt_server_sum,omitempty"`
	SrtSum               uint64   `protobuf:"varint,10,opt,name=srt_sum,json=srtSum,proto3" json:"srt_sum,omitempty"`
	ArtSum               uint64   `protobuf:"varint,11,opt,name=art_sum,json=artSum,proto3" json:"art_sum,omitempty"`
	RrtSum               uint64   `protobuf:"varint,12,opt,name=rrt_sum,json=rrtSum,proto3" json:"rrt_sum,omitempty"`
	CitSum               uint64   `protobuf:"varint,20,opt,name=cit_sum,json=citSum,proto3" json:"cit_sum,omitempty"`
	RttCount             uint32   `protobuf:"varint,13,opt,name=rtt_count,json=rttCount,proto3" json:"rtt_count,omitempty"`
	RttClientCount       uint32   `protobuf:"varint,14,opt,name=rtt_client_count,json=rttClientCount,proto3" json:"rtt_client_count,omitempty"`
	RttServerCount       uint32   `protobuf:"varint,15,opt,name=rtt_server_count,json=rttServerCount,proto3" json:"rtt_server_count,omitempty"`
	SrtCount             uint32   `protobuf:"varint,16,opt,name=srt_count,json=srtCount,proto3" json:"srt_count,omitempty"`
	ArtCount             uint32   `protobuf:"varint,17,opt,name=art_count,json=artCount,proto3" json:"art_count,omitempty"`
	RrtCount             uint32   `protobuf:"varint,18,opt,name=rrt_count,json=rrtCount,proto3" json:"rrt_count,omitempty"`
	CitCount             uint32   `protobuf:"varint,21,opt,name=cit_count,json=citCount,proto3" json:"cit_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Latency) Reset()         { *m = Latency{} }
func (m *Latency) String() string { return proto.CompactTextString(m) }
func (*Latency) ProtoMessage()    {}
func (*Latency) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{6}
}
func (m *Latency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Latency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Latency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Latency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Latency.Merge(m, src)
}
func (m *Latency) XXX_Size() int {
	return m.Size()
}
func (m *Latency) XXX_DiscardUnknown() {
	xxx_messageInfo_Latency.DiscardUnknown(m)
}

var xxx_messageInfo_Latency proto.InternalMessageInfo

func (m *Latency) GetRttMax() uint32 {
	if m != nil {
		return m.RttMax
	}
	return 0
}

func (m *Latency) GetRttClientMax() uint32 {
	if m != nil {
		return m.RttClientMax
	}
	return 0
}

func (m *Latency) GetRttServerMax() uint32 {
	if m != nil {
		return m.RttServerMax
	}
	return 0
}

func (m *Latency) GetSrtMax() uint32 {
	if m != nil {
		return m.SrtMax
	}
	return 0
}

func (m *Latency) GetArtMax() uint32 {
	if m != nil {
		return m.ArtMax
	}
	return 0
}

func (m *Latency) GetRrtMax() uint32 {
	if m != nil {
		return m.RrtMax
	}
	return 0
}

func (m *Latency) GetCitMax() uint32 {
	if m != nil {
		return m.CitMax
	}
	return 0
}

func (m *Latency) GetRttSum() uint64 {
	if m != nil {
		return m.RttSum
	}
	return 0
}

func (m *Latency) GetRttClientSum() uint64 {
	if m != nil {
		return m.RttClientSum
	}
	return 0
}

func (m *Latency) GetRttServerSum() uint64 {
	if m != nil {
		return m.RttServerSum
	}
	return 0
}

func (m *Latency) GetSrtSum() uint64 {
	if m != nil {
		return m.SrtSum
	}
	return 0
}

func (m *Latency) GetArtSum() uint64 {
	if m != nil {
		return m.ArtSum
	}
	return 0
}

func (m *Latency) GetRrtSum() uint64 {
	if m != nil {
		return m.RrtSum
	}
	return 0
}

func (m *Latency) GetCitSum() uint64 {
	if m != nil {
		return m.CitSum
	}
	return 0
}

func (m *Latency) GetRttCount() uint32 {
	if m != nil {
		return m.RttCount
	}
	return 0
}

func (m *Latency) GetRttClientCount() uint32 {
	if m != nil {
		return m.RttClientCount
	}
	return 0
}

func (m *Latency) GetRttServerCount() uint32 {
	if m != nil {
		return m.RttServerCount
	}
	return 0
}

func (m *Latency) GetSrtCount() uint32 {
	if m != nil {
		return m.SrtCount
	}
	return 0
}

func (m *Latency) GetArtCount() uint32 {
	if m != nil {
		return m.ArtCount
	}
	return 0
}

func (m *Latency) GetRrtCount() uint32 {
	if m != nil {
		return m.RrtCount
	}
	return 0
}

func (m *Latency) GetCitCount() uint32 {
	if m != nil {
		return m.CitCount
	}
	return 0
}

type Performance struct {
	RetransTx            uint64   `protobuf:"varint,1,opt,name=retrans_tx,json=retransTx,proto3" json:"retrans_tx,omitempty"`
	RetransRx            uint64   `protobuf:"varint,2,opt,name=retrans_rx,json=retransRx,proto3" json:"retrans_rx,omitempty"`
	ZeroWinTx            uint64   `protobuf:"varint,3,opt,name=zero_win_tx,json=zeroWinTx,proto3" json:"zero_win_tx,omitempty"`
	ZeroWinRx            uint64   `protobuf:"varint,4,opt,name=zero_win_rx,json=zeroWinRx,proto3" json:"zero_win_rx,omitempty"`
	RetransSyn           uint32   `protobuf:"varint,5,opt,name=retrans_syn,json=retransSyn,proto3" json:"retrans_syn,omitempty"`
	RetransSynack        uint32   `protobuf:"varint,6,opt,name=retrans_synack,json=retransSynack,proto3" json:"retrans_synack,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Performance) Reset()         { *m = Performance{} }
func (m *Performance) String() string { return proto.CompactTextString(m) }
func (*Performance) ProtoMessage()    {}
func (*Performance) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{7}
}
func (m *Performance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Performance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Performance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Performance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Performance.Merge(m, src)
}
func (m *Performance) XXX_Size() int {
	return m.Size()
}
func (m *Performance) XXX_DiscardUnknown() {
	xxx_messageInfo_Performance.DiscardUnknown(m)
}

var xxx_messageInfo_Performance proto.InternalMessageInfo

func (m *Performance) GetRetransTx() uint64 {
	if m != nil {
		return m.RetransTx
	}
	return 0
}

func (m *Performance) GetRetransRx() uint64 {
	if m != nil {
		return m.RetransRx
	}
	return 0
}

func (m *Performance) GetZeroWinTx() uint64 {
	if m != nil {
		return m.ZeroWinTx
	}
	return 0
}

func (m *Performance) GetZeroWinRx() uint64 {
	if m != nil {
		return m.ZeroWinRx
	}
	return 0
}

func (m *Performance) GetRetransSyn() uint32 {
	if m != nil {
		return m.RetransSyn
	}
	return 0
}

func (m *Performance) GetRetransSynack() uint32 {
	if m != nil {
		return m.RetransSynack
	}
	return 0
}

type Anomaly struct {
	ClientRstFlow         uint64   `protobuf:"varint,1,opt,name=client_rst_flow,json=clientRstFlow,proto3" json:"client_rst_flow,omitempty"`
	ServerRstFlow         uint64   `protobuf:"varint,2,opt,name=server_rst_flow,json=serverRstFlow,proto3" json:"server_rst_flow,omitempty"`
	ClientSynRepeat       uint64   `protobuf:"varint,3,opt,name=client_syn_repeat,json=clientSynRepeat,proto3" json:"client_syn_repeat,omitempty"`
	ServerSynackRepeat    uint64   `protobuf:"varint,4,opt,name=server_synack_repeat,json=serverSynackRepeat,proto3" json:"server_synack_repeat,omitempty"`
	ClientHalfCloseFlow   uint64   `protobuf:"varint,5,opt,name=client_half_close_flow,json=clientHalfCloseFlow,proto3" json:"client_half_close_flow,omitempty"`
	ServerHalfCloseFlow   uint64   `protobuf:"varint,6,opt,name=server_half_close_flow,json=serverHalfCloseFlow,proto3" json:"server_half_close_flow,omitempty"`
	ClientSourcePortReuse uint64   `protobuf:"varint,7,opt,name=client_source_port_reuse,json=clientSourcePortReuse,proto3" json:"client_source_port_reuse,omitempty"`
	ClientEstablishReset  uint64   `protobuf:"varint,8,opt,name=client_establish_reset,json=clientEstablishReset,proto3" json:"client_establish_reset,omitempty"`
	ServerReset           uint64   `protobuf:"varint,9,opt,name=server_reset,json=serverReset,proto3" json:"server_reset,omitempty"`
	ServerQueueLack       uint64   `protobuf:"varint,10,opt,name=server_queue_lack,json=serverQueueLack,proto3" json:"server_queue_lack,omitempty"`
	ServerEstablishReset  uint64   `protobuf:"varint,11,opt,name=server_establish_reset,json=serverEstablishReset,proto3" json:"server_establish_reset,omitempty"`
	TcpTimeout            uint64   `protobuf:"varint,12,opt,name=tcp_timeout,json=tcpTimeout,proto3" json:"tcp_timeout,omitempty"`
	L7ClientError         uint32   `protobuf:"varint,13,opt,name=l7_client_error,json=l7ClientError,proto3" json:"l7_client_error,omitempty"`
	L7ServerError         uint32   `protobuf:"varint,14,opt,name=l7_server_error,json=l7ServerError,proto3" json:"l7_server_error,omitempty"`
	L7Timeout             uint32   `protobuf:"varint,15,opt,name=l7_timeout,json=l7Timeout,proto3" json:"l7_timeout,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *Anomaly) Reset()         { *m = Anomaly{} }
func (m *Anomaly) String() string { return proto.CompactTextString(m) }
func (*Anomaly) ProtoMessage()    {}
func (*Anomaly) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{8}
}
func (m *Anomaly) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Anomaly) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Anomaly.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Anomaly) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Anomaly.Merge(m, src)
}
func (m *Anomaly) XXX_Size() int {
	return m.Size()
}
func (m *Anomaly) XXX_DiscardUnknown() {
	xxx_messageInfo_Anomaly.DiscardUnknown(m)
}

var xxx_messageInfo_Anomaly proto.InternalMessageInfo

func (m *Anomaly) GetClientRstFlow() uint64 {
	if m != nil {
		return m.ClientRstFlow
	}
	return 0
}

func (m *Anomaly) GetServerRstFlow() uint64 {
	if m != nil {
		return m.ServerRstFlow
	}
	return 0
}

func (m *Anomaly) GetClientSynRepeat() uint64 {
	if m != nil {
		return m.ClientSynRepeat
	}
	return 0
}

func (m *Anomaly) GetServerSynackRepeat() uint64 {
	if m != nil {
		return m.ServerSynackRepeat
	}
	return 0
}

func (m *Anomaly) GetClientHalfCloseFlow() uint64 {
	if m != nil {
		return m.ClientHalfCloseFlow
	}
	return 0
}

func (m *Anomaly) GetServerHalfCloseFlow() uint64 {
	if m != nil {
		return m.ServerHalfCloseFlow
	}
	return 0
}

func (m *Anomaly) GetClientSourcePortReuse() uint64 {
	if m != nil {
		return m.ClientSourcePortReuse
	}
	return 0
}

func (m *Anomaly) GetClientEstablishReset() uint64 {
	if m != nil {
		return m.ClientEstablishReset
	}
	return 0
}

func (m *Anomaly) GetServerReset() uint64 {
	if m != nil {
		return m.ServerReset
	}
	return 0
}

func (m *Anomaly) GetServerQueueLack() uint64 {
	if m != nil {
		return m.ServerQueueLack
	}
	return 0
}

func (m *Anomaly) GetServerEstablishReset() uint64 {
	if m != nil {
		return m.ServerEstablishReset
	}
	return 0
}

func (m *Anomaly) GetTcpTimeout() uint64 {
	if m != nil {
		return m.TcpTimeout
	}
	return 0
}

func (m *Anomaly) GetL7ClientError() uint32 {
	if m != nil {
		return m.L7ClientError
	}
	return 0
}

func (m *Anomaly) GetL7ServerError() uint32 {
	if m != nil {
		return m.L7ServerError
	}
	return 0
}

func (m *Anomaly) GetL7Timeout() uint32 {
	if m != nil {
		return m.L7Timeout
	}
	return 0
}

type FlowLoad struct {
	Load                 uint64   `protobuf:"varint,1,opt,name=load,proto3" json:"load,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowLoad) Reset()         { *m = FlowLoad{} }
func (m *FlowLoad) String() string { return proto.CompactTextString(m) }
func (*FlowLoad) ProtoMessage()    {}
func (*FlowLoad) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{9}
}
func (m *FlowLoad) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowLoad) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowLoad.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowLoad) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowLoad.Merge(m, src)
}
func (m *FlowLoad) XXX_Size() int {
	return m.Size()
}
func (m *FlowLoad) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowLoad.DiscardUnknown(m)
}

var xxx_messageInfo_FlowLoad proto.InternalMessageInfo

func (m *FlowLoad) GetLoad() uint64 {
	if m != nil {
		return m.Load
	}
	return 0
}

// usage meter
type UsageMeter struct {
	PacketTx             uint64   `protobuf:"varint,1,opt,name=packet_tx,json=packetTx,proto3" json:"packet_tx,omitempty"`
	PacketRx             uint64   `protobuf:"varint,2,opt,name=packet_rx,json=packetRx,proto3" json:"packet_rx,omitempty"`
	ByteTx               uint64   `protobuf:"varint,3,opt,name=byte_tx,json=byteTx,proto3" json:"byte_tx,omitempty"`
	ByteRx               uint64   `protobuf:"varint,4,opt,name=byte_rx,json=byteRx,proto3" json:"byte_rx,omitempty"`
	L3ByteTx             uint64   `protobuf:"varint,5,opt,name=l3_byte_tx,json=l3ByteTx,proto3" json:"l3_byte_tx,omitempty"`
	L3ByteRx             uint64   `protobuf:"varint,6,opt,name=l3_byte_rx,json=l3ByteRx,proto3" json:"l3_byte_rx,omitempty"`
	L4ByteTx             uint64   `protobuf:"varint,7,opt,name=l4_byte_tx,json=l4ByteTx,proto3" json:"l4_byte_tx,omitempty"`
	L4ByteRx             uint64   `protobuf:"varint,8,opt,name=l4_byte_rx,json=l4ByteRx,proto3" json:"l4_byte_rx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageMeter) Reset()         { *m = UsageMeter{} }
func (m *UsageMeter) String() string { return proto.CompactTextString(m) }
func (*UsageMeter) ProtoMessage()    {}
func (*UsageMeter) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{10}
}
func (m *UsageMeter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageMeter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageMeter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageMeter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageMeter.Merge(m, src)
}
func (m *UsageMeter) XXX_Size() int {
	return m.Size()
}
func (m *UsageMeter) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageMeter.DiscardUnknown(m)
}

var xxx_messageInfo_UsageMeter proto.InternalMessageInfo

func (m *UsageMeter) GetPacketTx() uint64 {
	if m != nil {
		return m.PacketTx
	}
	return 0
}

func (m *UsageMeter) GetPacketRx() uint64 {
	if m != nil {
		return m.PacketRx
	}
	return 0
}

func (m *UsageMeter) GetByteTx() uint64 {
	if m != nil {
		return m.ByteTx
	}
	return 0
}

func (m *UsageMeter) GetByteRx() uint64 {
	if m != nil {
		return m.ByteRx
	}
	return 0
}

func (m *UsageMeter) GetL3ByteTx() uint64 {
	if m != nil {
		return m.L3ByteTx
	}
	return 0
}

func (m *UsageMeter) GetL3ByteRx() uint64 {
	if m != nil {
		return m.L3ByteRx
	}
	return 0
}

func (m *UsageMeter) GetL4ByteTx() uint64 {
	if m != nil {
		return m.L4ByteTx
	}
	return 0
}

func (m *UsageMeter) GetL4ByteRx() uint64 {
	if m != nil {
		return m.L4ByteRx
	}
	return 0
}

// app meter
type AppMeter struct {
	Traffic              *AppTraffic `protobuf:"bytes,1,opt,name=traffic,proto3" json:"traffic,omitempty"`
	Latency              *AppLatency `protobuf:"bytes,2,opt,name=latency,proto3" json:"latency,omitempty"`
	Anomaly              *AppAnomaly `protobuf:"bytes,3,opt,name=anomaly,proto3" json:"anomaly,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AppMeter) Reset()         { *m = AppMeter{} }
func (m *AppMeter) String() string { return proto.CompactTextString(m) }
func (*AppMeter) ProtoMessage()    {}
func (*AppMeter) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{11}
}
func (m *AppMeter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppMeter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppMeter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppMeter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppMeter.Merge(m, src)
}
func (m *AppMeter) XXX_Size() int {
	return m.Size()
}
func (m *AppMeter) XXX_DiscardUnknown() {
	xxx_messageInfo_AppMeter.DiscardUnknown(m)
}

var xxx_messageInfo_AppMeter proto.InternalMessageInfo

func (m *AppMeter) GetTraffic() *AppTraffic {
	if m != nil {
		return m.Traffic
	}
	return nil
}

func (m *AppMeter) GetLatency() *AppLatency {
	if m != nil {
		return m.Latency
	}
	return nil
}

func (m *AppMeter) GetAnomaly() *AppAnomaly {
	if m != nil {
		return m.Anomaly
	}
	return nil
}

type AppTraffic struct {
	Request              uint32   `protobuf:"varint,1,opt,name=request,proto3" json:"request,omitempty"`
	Response             uint32   `protobuf:"varint,2,opt,name=response,proto3" json:"response,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppTraffic) Reset()         { *m = AppTraffic{} }
func (m *AppTraffic) String() string { return proto.CompactTextString(m) }
func (*AppTraffic) ProtoMessage()    {}
func (*AppTraffic) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{12}
}
func (m *AppTraffic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppTraffic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppTraffic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppTraffic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppTraffic.Merge(m, src)
}
func (m *AppTraffic) XXX_Size() int {
	return m.Size()
}
func (m *AppTraffic) XXX_DiscardUnknown() {
	xxx_messageInfo_AppTraffic.DiscardUnknown(m)
}

var xxx_messageInfo_AppTraffic proto.InternalMessageInfo

func (m *AppTraffic) GetRequest() uint32 {
	if m != nil {
		return m.Request
	}
	return 0
}

func (m *AppTraffic) GetResponse() uint32 {
	if m != nil {
		return m.Response
	}
	return 0
}

type AppLatency struct {
	RrtMax               uint32   `protobuf:"varint,1,opt,name=rrt_max,json=rrtMax,proto3" json:"rrt_max,omitempty"`
	RrtSum               uint64   `protobuf:"varint,2,opt,name=rrt_sum,json=rrtSum,proto3" json:"rrt_sum,omitempty"`
	RrtCount             uint32   `protobuf:"varint,3,opt,name=rrt_count,json=rrtCount,proto3" json:"rrt_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppLatency) Reset()         { *m = AppLatency{} }
func (m *AppLatency) String() string { return proto.CompactTextString(m) }
func (*AppLatency) ProtoMessage()    {}
func (*AppLatency) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{13}
}
func (m *AppLatency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppLatency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppLatency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppLatency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppLatency.Merge(m, src)
}
func (m *AppLatency) XXX_Size() int {
	return m.Size()
}
func (m *AppLatency) XXX_DiscardUnknown() {
	xxx_messageInfo_AppLatency.DiscardUnknown(m)
}

var xxx_messageInfo_AppLatency proto.InternalMessageInfo

func (m *AppLatency) GetRrtMax() uint32 {
	if m != nil {
		return m.RrtMax
	}
	return 0
}

func (m *AppLatency) GetRrtSum() uint64 {
	if m != nil {
		return m.RrtSum
	}
	return 0
}

func (m *AppLatency) GetRrtCount() uint32 {
	if m != nil {
		return m.RrtCount
	}
	return 0
}

type AppAnomaly struct {
	ClientError          uint32   `protobuf:"varint,1,opt,name=client_error,json=clientError,proto3" json:"client_error,omitempty"`
	ServerError          uint32   `protobuf:"varint,2,opt,name=server_error,json=serverError,proto3" json:"server_error,omitempty"`
	Timeout              uint32   `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppAnomaly) Reset()         { *m = AppAnomaly{} }
func (m *AppAnomaly) String() string { return proto.CompactTextString(m) }
func (*AppAnomaly) ProtoMessage()    {}
func (*AppAnomaly) Descriptor() ([]byte, []int) {
	return fileDescriptor_da41641f55bff5df, []int{14}
}
func (m *AppAnomaly) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppAnomaly) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppAnomaly.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppAnomaly) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppAnomaly.Merge(m, src)
}
func (m *AppAnomaly) XXX_Size() int {
	return m.Size()
}
func (m *AppAnomaly) XXX_DiscardUnknown() {
	xxx_messageInfo_AppAnomaly.DiscardUnknown(m)
}

var xxx_messageInfo_AppAnomaly proto.InternalMessageInfo

func (m *AppAnomaly) GetClientError() uint32 {
	if m != nil {
		return m.ClientError
	}
	return 0
}

func (m *AppAnomaly) GetServerError() uint32 {
	if m != nil {
		return m.ServerError
	}
	return 0
}

func (m *AppAnomaly) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func init() {
	proto.RegisterType((*MiniField)(nil), "metric.MiniField")
	proto.RegisterType((*MiniTag)(nil), "metric.MiniTag")
	proto.RegisterType((*Meter)(nil), "metric.Meter")
	proto.RegisterType((*Document)(nil), "metric.Document")
	proto.RegisterType((*FlowMeter)(nil), "metric.FlowMeter")
	proto.RegisterType((*Traffic)(nil), "metric.Traffic")
	proto.RegisterType((*Latency)(nil), "metric.Latency")
	proto.RegisterType((*Performance)(nil), "metric.Performance")
	proto.RegisterType((*Anomaly)(nil), "metric.Anomaly")
	proto.RegisterType((*FlowLoad)(nil), "metric.FlowLoad")
	proto.RegisterType((*UsageMeter)(nil), "metric.UsageMeter")
	proto.RegisterType((*AppMeter)(nil), "metric.AppMeter")
	proto.RegisterType((*AppTraffic)(nil), "metric.AppTraffic")
	proto.RegisterType((*AppLatency)(nil), "metric.AppLatency")
	proto.RegisterType((*AppAnomaly)(nil), "metric.AppAnomaly")
}

func init() { proto.RegisterFile("metric.proto", fileDescriptor_da41641f55bff5df) }

var fileDescriptor_da41641f55bff5df = []byte{
	// 1572 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x97, 0x5d, 0x6e, 0xdc, 0x46,
	0x12, 0xc7, 0x31, 0x1a, 0xcd, 0x57, 0x8d, 0x3e, 0x5b, 0xb2, 0xcd, 0xb5, 0xbd, 0xb2, 0xcc, 0x5d,
	0x7b, 0xb5, 0x86, 0x3f, 0x56, 0x96, 0xd6, 0x7a, 0xb6, 0xbd, 0xf6, 0xae, 0x00, 0x1b, 0xf0, 0x52,
	0xb3, 0x1b, 0x20, 0x79, 0x20, 0x5a, 0x64, 0xcf, 0x88, 0x30, 0x87, 0xa4, 0x9b, 0x3d, 0xd2, 0x4c,
	0x9e, 0xf2, 0x94, 0x1c, 0x20, 0x01, 0x72, 0x82, 0xdc, 0x25, 0x8f, 0x01, 0x72, 0x81, 0xc0, 0x27,
	0x08, 0x72, 0x82, 0xa0, 0xba, 0xaa, 0x39, 0x9c, 0xf1, 0x11, 0xf2, 0xc6, 0xae, 0xdf, 0xbf, 0xa6,
	0xab, 0xc8, 0xaa, 0xea, 0x1e, 0x58, 0x1b, 0x2b, 0xa3, 0x93, 0xe8, 0x71, 0xa1, 0x73, 0x93, 0x8b,
	0x36, 0xad, 0x6e, 0x3e, 0x1a, 0x25, 0xe6, 0x62, 0x72, 0xfe, 0x38, 0xca, 0xc7, 0x4f, 0x46, 0xf9,
	0x28, 0x7f, 0x62, 0xf1, 0xf9, 0x64, 0x68, 0x57, 0x76, 0x61, 0x9f, 0xc8, 0xcd, 0xff, 0x66, 0x15,
	0x7a, 0x6f, 0x93, 0x2c, 0x79, 0x9d, 0xa8, 0x34, 0x16, 0x1b, 0xb0, 0x92, 0x14, 0x5e, 0x63, 0xbf,
	0x71, 0xb0, 0x16, 0xac, 0x24, 0x85, 0xd8, 0x82, 0x66, 0x52, 0x1c, 0x7a, 0x2b, 0xd6, 0x80, 0x8f,
	0xe2, 0x00, 0xb6, 0x46, 0x69, 0x7e, 0x2e, 0xd3, 0xd0, 0x5c, 0x68, 0x25, 0xe3, 0x30, 0x89, 0xbd,
	0xe6, 0x7e, 0xe3, 0x60, 0x3d, 0xd8, 0x20, 0xfb, 0xc0, 0x9a, 0x4f, 0x63, 0x71, 0x03, 0x3a, 0x49,
	0x19, 0x26, 0xc5, 0xe5, 0x33, 0x6f, 0xd5, 0x0a, 0xda, 0x49, 0x79, 0x5a, 0x5c, 0x3e, 0x13, 0x37,
	0xa1, 0x97, 0x1e, 0x85, 0xaa, 0x88, 0xd0, 0xb7, 0xb5, 0xdf, 0x38, 0x68, 0x05, 0x9d, 0xf4, 0xe8,
	0x55, 0x11, 0x9d, 0xc6, 0xe2, 0x36, 0x40, 0xc5, 0x0e, 0xbd, 0xb6, 0x85, 0x5d, 0x86, 0x87, 0x18,
	0xce, 0x58, 0x46, 0x5e, 0x67, 0xbf, 0x71, 0xb0, 0x1a, 0xe0, 0xa3, 0x10, 0xb0, 0x3a, 0x96, 0xd1,
	0xa1, 0xd7, 0xb5, 0x26, 0xfb, 0x2c, 0x6e, 0x43, 0x2f, 0x4e, 0xb4, 0x8a, 0x4c, 0x92, 0x67, 0x5e,
	0xcf, 0x6e, 0x3d, 0x37, 0x88, 0x3f, 0x41, 0xd7, 0xc8, 0x22, 0x2c, 0x93, 0x58, 0x79, 0x60, 0x61,
	0xc7, 0xc8, 0xe2, 0x2c, 0x89, 0x95, 0xb8, 0x09, 0x5d, 0xfb, 0x52, 0xa2, 0x3c, 0xf5, 0xfa, 0x16,
	0x55, 0x6b, 0xcc, 0x46, 0x46, 0x69, 0x38, 0x4a, 0x62, 0x6f, 0x8d, 0xb2, 0x91, 0x51, 0xfa, 0xef,
	0x24, 0x16, 0x77, 0xa0, 0x5f, 0x2a, 0x7d, 0xa9, 0x74, 0x58, 0xe4, 0xda, 0x78, 0xeb, 0x16, 0x02,
	0x99, 0xde, 0xe5, 0xda, 0xa0, 0xe7, 0x25, 0xee, 0x98, 0xc4, 0xde, 0x06, 0x79, 0xe2, 0xf2, 0x34,
	0x76, 0x91, 0x58, 0xb7, 0x4d, 0x1b, 0x3f, 0x46, 0x62, 0x7d, 0x18, 0x99, 0x59, 0xa1, 0xbc, 0xad,
	0x2a, 0xc8, 0xc1, 0xac, 0x50, 0xb8, 0x5f, 0x7a, 0x12, 0x56, 0x71, 0x6e, 0xd3, 0x7e, 0xe9, 0xc9,
	0x3b, 0x17, 0xa9, 0xf5, 0x1d, 0x91, 0xaf, 0x70, 0xbe, 0x23, 0xeb, 0x7b, 0x0b, 0x7a, 0x88, 0x2e,
	0x65, 0x3a, 0x51, 0xde, 0x0e, 0x65, 0x68, 0xe4, 0xe8, 0xff, 0xb8, 0xf6, 0x5f, 0x43, 0x07, 0x0b,
	0x61, 0x20, 0x47, 0xe2, 0x6f, 0xd0, 0x1a, 0x62, 0x3d, 0xd8, 0x4a, 0xe8, 0x3f, 0xdd, 0x7e, 0xcc,
	0x95, 0x56, 0x15, 0x4a, 0x40, 0x1c, 0x5f, 0x7f, 0x94, 0xc7, 0xca, 0x16, 0xc8, 0x6a, 0x60, 0x9f,
	0xfd, 0xef, 0x1b, 0xd0, 0x7a, 0xab, 0x8c, 0xd2, 0x18, 0xc9, 0x18, 0x1f, 0x30, 0xf5, 0x06, 0x45,
	0x62, 0xd7, 0xa7, 0xb1, 0xb8, 0x07, 0xab, 0xc3, 0x34, 0xbf, 0xb2, 0x8e, 0xb5, 0x0d, 0x5e, 0xa7,
	0xf9, 0x95, 0xf5, 0x0d, 0x2c, 0x16, 0x07, 0xd0, 0x9a, 0x94, 0x72, 0xa4, 0x6c, 0x89, 0xf5, 0x9f,
	0x0a, 0xa7, 0xfb, 0x1f, 0x1a, 0x49, 0x48, 0x02, 0xe1, 0x43, 0x53, 0x16, 0x85, 0xad, 0xb4, 0xfe,
	0xd3, 0x2d, 0xa7, 0x7b, 0x5e, 0x14, 0xa4, 0x42, 0xe8, 0x7f, 0xdd, 0x80, 0xee, 0xbf, 0xf2, 0x68,
	0x32, 0x56, 0x99, 0xc1, 0x2a, 0x31, 0xc9, 0x58, 0x95, 0x46, 0x8e, 0x0b, 0x8e, 0x6e, 0x6e, 0x10,
	0x77, 0xa1, 0x69, 0xe4, 0x88, 0xc3, 0xdb, 0xac, 0xe7, 0x3f, 0x90, 0xa3, 0x00, 0x99, 0xf8, 0x0b,
	0xb4, 0x6c, 0x36, 0x1c, 0xdb, 0x7a, 0x25, 0xa2, 0xb0, 0x2c, 0x13, 0xbb, 0xd0, 0x1a, 0xa6, 0x72,
	0x54, 0x72, 0x0b, 0xd0, 0xc2, 0xff, 0xad, 0x01, 0xbd, 0x2a, 0x55, 0xf1, 0x77, 0xe8, 0x18, 0x2d,
	0x87, 0xc3, 0x24, 0xe2, 0xf7, 0x5d, 0xed, 0x37, 0x20, 0x73, 0xe0, 0x38, 0x4a, 0x53, 0x69, 0x54,
	0x16, 0xcd, 0x96, 0x43, 0x7b, 0x43, 0xe6, 0xc0, 0x71, 0xf1, 0x4f, 0xe8, 0x17, 0x4a, 0x0f, 0x73,
	0x3d, 0x96, 0x59, 0xe4, 0x5e, 0xe0, 0x8e, 0x93, 0xbf, 0x9b, 0xa3, 0xa0, 0xae, 0xc3, 0x1d, 0x64,
	0x96, 0x8f, 0x65, 0x3a, 0xe3, 0x77, 0x59, 0xed, 0xf0, 0x9c, 0xcc, 0x81, 0xe3, 0xe2, 0x11, 0xf4,
	0xf0, 0x23, 0x85, 0x69, 0x2e, 0xa9, 0x8f, 0x6b, 0x2f, 0x1e, 0xb3, 0x7b, 0x93, 0xcb, 0x38, 0xe8,
	0x0e, 0xf9, 0xc9, 0xff, 0xb6, 0x09, 0x1d, 0x4e, 0x08, 0x0b, 0xb1, 0x90, 0xd1, 0x7b, 0x65, 0x42,
	0x33, 0xb5, 0x49, 0xaf, 0x06, 0x5d, 0x32, 0x0c, 0xa6, 0x35, 0xa8, 0xa7, 0x5c, 0x59, 0x0c, 0x83,
	0x29, 0x76, 0xd3, 0xf9, 0xcc, 0x28, 0xf4, 0x6b, 0x5a, 0xd4, 0xc6, 0xe5, 0x60, 0x0e, 0xf4, 0xd4,
	0x06, 0xce, 0x20, 0x98, 0xf2, 0x48, 0x71, 0x4e, 0x2d, 0xfa, 0xbd, 0xf4, 0xe8, 0x05, 0xb9, 0xd5,
	0xa8, 0x9e, 0xda, 0x81, 0x53, 0x51, 0xf6, 0x3d, 0xae, 0x7c, 0x3b, 0x4c, 0x8f, 0x6b, 0xbe, 0xc7,
	0x95, 0x6f, 0xb7, 0x4e, 0x83, 0x29, 0x56, 0x7f, 0xa6, 0xae, 0x42, 0x5b, 0xe6, 0x3d, 0x6a, 0xef,
	0x4c, 0x5d, 0xe1, 0x8b, 0xc1, 0x1e, 0x8e, 0xd2, 0xbc, 0x54, 0x31, 0x51, 0xb0, 0x14, 0xc8, 0x64,
	0x05, 0x7f, 0x06, 0x48, 0x4f, 0x42, 0xad, 0x3e, 0x4c, 0x54, 0x69, 0x78, 0x16, 0xf5, 0xd2, 0x93,
	0x80, 0x0c, 0x3c, 0x03, 0xb4, 0x2a, 0x8b, 0x3c, 0x2b, 0x15, 0x0f, 0x24, 0x40, 0x4e, 0x16, 0x1c,
	0x94, 0xe5, 0x2c, 0xe3, 0x61, 0x84, 0x8f, 0xe2, 0x3a, 0xb4, 0xcb, 0x59, 0x26, 0xa3, 0xf7, 0x6e,
	0x08, 0xd1, 0xca, 0xff, 0xaa, 0x05, 0x1d, 0xae, 0x1d, 0x7c, 0x85, 0xda, 0x98, 0x70, 0x2c, 0xa7,
	0xdc, 0x10, 0x6d, 0x6d, 0xcc, 0x5b, 0x39, 0x15, 0x7f, 0x85, 0x0d, 0x04, 0x51, 0x9a, 0xa8, 0x8c,
	0xf8, 0x8a, 0xe5, 0x6b, 0xda, 0x98, 0x97, 0xd6, 0x58, 0x53, 0xf1, 0x34, 0x44, 0x55, 0xb3, 0x52,
	0x9d, 0x59, 0x23, 0xaa, 0x6e, 0x40, 0xa7, 0xd4, 0xf4, 0x23, 0x7c, 0x2c, 0x94, 0xda, 0x30, 0x90,
	0x0c, 0x5a, 0x3c, 0x61, 0x2b, 0xa0, 0x19, 0xb4, 0x39, 0xac, 0x0a, 0x44, 0x09, 0x01, 0x1a, 0x66,
	0xed, 0x28, 0xa9, 0x3c, 0x30, 0x92, 0xc9, 0x98, 0xbf, 0x19, 0x26, 0x72, 0x36, 0x19, 0x2f, 0x25,
	0x82, 0x9c, 0xbe, 0xda, 0x3c, 0x91, 0x9a, 0x8a, 0x13, 0x41, 0x55, 0xaf, 0x52, 0x51, 0x22, 0xa8,
	0xe2, 0x44, 0x10, 0xd3, 0x07, 0xc4, 0x44, 0x18, 0x48, 0x06, 0x7d, 0x02, 0xb2, 0x02, 0x9a, 0xc1,
	0x1a, 0x87, 0x55, 0x01, 0x4c, 0x04, 0xc1, 0x2e, 0x81, 0x28, 0xb1, 0xe0, 0x16, 0xf4, 0x6c, 0xbc,
	0xf9, 0x24, 0x73, 0x47, 0x4b, 0x17, 0x43, 0xc5, 0x35, 0x1e, 0xc5, 0xb5, 0x64, 0x48, 0x43, 0x1f,
	0x77, 0xa3, 0x4a, 0x67, 0x41, 0xc9, 0x09, 0x91, 0x72, 0xb3, 0x52, 0x52, 0x4a, 0xa4, 0xbc, 0x05,
	0x3d, 0x4c, 0x8a, 0x24, 0x74, 0xf2, 0x74, 0x4b, 0x6d, 0x2a, 0x28, 0x2b, 0x48, 0x07, 0x4f, 0x57,
	0xd6, 0xa0, 0xae, 0xa0, 0xe0, 0x50, 0x6b, 0x10, 0x13, 0x24, 0x78, 0x8d, 0x60, 0x94, 0x10, 0xf4,
	0x7f, 0x6e, 0x40, 0xbf, 0x36, 0x8f, 0xb0, 0xf8, 0xb5, 0x32, 0x5a, 0x66, 0xe5, 0x7c, 0x3a, 0xf4,
	0xd8, 0x32, 0x98, 0xd6, 0x71, 0x35, 0x1f, 0x1c, 0x0e, 0xa6, 0x62, 0x0f, 0xfa, 0x5f, 0x2a, 0x9d,
	0x87, 0x57, 0x49, 0x36, 0x1f, 0x12, 0x3d, 0x34, 0x7d, 0x96, 0x64, 0x83, 0x45, 0x5e, 0xcd, 0x0a,
	0xc7, 0x83, 0x29, 0xf6, 0x96, 0xfb, 0x79, 0x6c, 0x21, 0x2a, 0x45, 0xb7, 0xe3, 0xd9, 0x2c, 0x13,
	0xf7, 0x60, 0xa3, 0x26, 0xc0, 0x8e, 0xa2, 0xaa, 0x5c, 0x9f, 0x6b, 0xb0, 0xb1, 0x7e, 0x68, 0x41,
	0x87, 0x47, 0xa6, 0xb8, 0x0f, 0x9b, 0xfc, 0x95, 0x74, 0x69, 0xa8, 0xe7, 0x29, 0xad, 0x75, 0x32,
	0x07, 0xa5, 0xb1, 0x6d, 0x7f, 0x1f, 0x36, 0xf9, 0x1b, 0x55, 0x3a, 0xca, 0x6f, 0x9d, 0xcc, 0x4e,
	0xf7, 0x00, 0xb6, 0x5d, 0x09, 0xcf, 0xb2, 0x50, 0xab, 0x42, 0x49, 0xc3, 0x99, 0xf2, 0x46, 0x67,
	0xb3, 0x2c, 0xb0, 0x66, 0xf1, 0x0f, 0xd8, 0x75, 0x85, 0x6c, 0x03, 0x73, 0x72, 0x4a, 0x5c, 0x10,
	0xa3, 0x98, 0xd9, 0xe3, 0x08, 0xae, 0xf3, 0xaf, 0x5f, 0xc8, 0x74, 0x18, 0xda, 0xb1, 0x44, 0xc1,
	0xd0, 0xf0, 0xdc, 0x21, 0xfa, 0x1f, 0x99, 0x0e, 0x5f, 0x22, 0xb3, 0x21, 0x1d, 0xc1, 0x75, 0xde,
	0x66, 0xd9, 0x89, 0x66, 0xea, 0x0e, 0xd1, 0x45, 0xa7, 0x13, 0xf0, 0x5c, 0x1e, 0xf9, 0x44, 0x47,
	0xca, 0xde, 0x85, 0x42, 0xad, 0x26, 0xa5, 0xe2, 0xc6, 0xbd, 0xc6, 0xe9, 0x58, 0x8c, 0x57, 0xa3,
	0x00, 0xa1, 0x38, 0xae, 0x42, 0xc4, 0xf3, 0xfa, 0x3c, 0x4d, 0xca, 0x0b, 0x1c, 0x87, 0xca, 0x70,
	0x3f, 0xef, 0x12, 0x7d, 0xe5, 0x60, 0x80, 0x4c, 0xdc, 0x85, 0x35, 0xf7, 0x7a, 0xad, 0x96, 0xba,
	0x9a, 0xaf, 0x6f, 0x24, 0x79, 0x00, 0xdb, 0x2c, 0xf9, 0x30, 0x51, 0x13, 0x15, 0xa6, 0xf8, 0x7d,
	0xa9, 0xbd, 0xf9, 0xd3, 0xfc, 0x17, 0xed, 0x6f, 0x64, 0xf4, 0x1e, 0x83, 0x60, 0xed, 0x72, 0x10,
	0xd4, 0xf6, 0xfc, 0xde, 0x97, 0x82, 0xb8, 0x03, 0x7d, 0x13, 0x15, 0x21, 0x5e, 0x35, 0xf2, 0x89,
	0xe1, 0x41, 0x00, 0x26, 0x2a, 0x06, 0x64, 0xc1, 0x22, 0x48, 0x4f, 0x5c, 0x57, 0x2b, 0xad, 0x73,
	0xcd, 0x9d, 0xbf, 0x9e, 0x9e, 0x50, 0x53, 0xbf, 0x42, 0x23, 0xeb, 0x5c, 0x04, 0x56, 0xb7, 0xe1,
	0x74, 0xd4, 0xd2, 0xa4, 0xa3, 0xb3, 0xc4, 0xed, 0xb7, 0xe9, 0xce, 0x12, 0xde, 0xce, 0xdf, 0x83,
	0xae, 0x3b, 0xac, 0xf1, 0x3a, 0x67, 0x0f, 0x73, 0x2a, 0x4e, 0xfb, 0xec, 0xff, 0xda, 0x00, 0x98,
	0x5f, 0xb7, 0xfe, 0x08, 0x27, 0xb7, 0xff, 0x5d, 0x03, 0xba, 0xee, 0xe6, 0x28, 0x1e, 0x2e, 0xdf,
	0xce, 0x44, 0xed, 0x72, 0xf9, 0xc9, 0x05, 0xed, 0xe1, 0xf2, 0x05, 0xad, 0xae, 0xfe, 0xe4, 0x8e,
	0xf6, 0x70, 0x7e, 0xd9, 0x6a, 0x7e, 0xa2, 0x5e, 0xbe, 0x6f, 0xf9, 0x2f, 0x00, 0xe6, 0x5b, 0x0a,
	0x0f, 0x3a, 0xee, 0x7e, 0xc0, 0x77, 0x6b, 0x5e, 0xe2, 0xdf, 0x98, 0xea, 0x6a, 0xb0, 0xc2, 0x83,
	0x98, 0xd7, 0xfe, 0x17, 0xf6, 0x37, 0xea, 0x07, 0xbe, 0x5e, 0x3c, 0xf0, 0x17, 0x8e, 0x5c, 0x3c,
	0x90, 0x56, 0x16, 0x4e, 0xaa, 0x85, 0x29, 0xdf, 0x5c, 0x9c, 0xf2, 0x7e, 0x6a, 0x7f, 0xdc, 0x0d,
	0xbd, 0xbb, 0xb0, 0xb6, 0x50, 0xc4, 0xb4, 0x43, 0x3f, 0xaa, 0x95, 0xf0, 0xbc, 0x21, 0x49, 0x42,
	0xd1, 0x72, 0x43, 0x92, 0xc4, 0x83, 0x8e, 0x2b, 0xdd, 0x26, 0xff, 0x99, 0xa1, 0xe5, 0x8b, 0xad,
	0x1f, 0x3f, 0xee, 0x35, 0x7e, 0xfa, 0xb8, 0xd7, 0xf8, 0xe5, 0xe3, 0x5e, 0xe3, 0xf3, 0x95, 0xe2,
	0xfc, 0xbc, 0x6d, 0xff, 0x15, 0x1d, 0xfd, 0x1e, 0x00, 0x00, 0xff, 0xff, 0x9a, 0xbb, 0x66, 0x2d,
	0x19, 0x0f, 0x00, 0x00,
}

func (m *MiniField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiniField) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MiniField) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TagValue != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.TagValue))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.TagType != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.TagType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.L7Protocol != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L7Protocol))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.TapType != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.TapType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.TapPort != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.TapPort))
		i--
		dAtA[i] = 0x78
	}
	if m.VtapId != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.VtapId))
		i--
		dAtA[i] = 0x70
	}
	if m.ServerPort != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ServerPort))
		i--
		dAtA[i] = 0x68
	}
	if m.AclGid != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.AclGid))
		i--
		dAtA[i] = 0x60
	}
	if m.Protocol != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x58
	}
	if m.TapSide != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.TapSide))
		i--
		dAtA[i] = 0x50
	}
	if m.Direction != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x48
	}
	if m.Mac1 != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Mac1))
		i--
		dAtA[i] = 0x40
	}
	if m.Mac != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Mac))
		i--
		dAtA[i] = 0x38
	}
	if m.L3EpcId1 != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L3EpcId1))
		i--
		dAtA[i] = 0x30
	}
	if m.L3EpcId != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L3EpcId))
		i--
		dAtA[i] = 0x28
	}
	if m.IsIpv6 != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.IsIpv6))
		i--
		dAtA[i] = 0x20
	}
	if m.GlobalThreadId != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.GlobalThreadId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ip1) > 0 {
		i -= len(m.Ip1)
		copy(dAtA[i:], m.Ip1)
		i = encodeVarintMetric(dAtA, i, uint64(len(m.Ip1)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintMetric(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MiniTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiniTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MiniTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Field != nil {
		{
			size, err := m.Field.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Meter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Meter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Meter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.App != nil {
		{
			size, err := m.App.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Usage != nil {
		{
			size, err := m.Usage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Flow != nil {
		{
			size, err := m.Flow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MeterId != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.MeterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Document) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Document) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flags != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x20
	}
	if m.Meter != nil {
		{
			size, err := m.Meter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Tag != nil {
		{
			size, err := m.Tag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowMeter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMeter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowMeter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FlowLoad != nil {
		{
			size, err := m.FlowLoad.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Anomaly != nil {
		{
			size, err := m.Anomaly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Performance != nil {
		{
			size, err := m.Performance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Latency != nil {
		{
			size, err := m.Latency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Traffic != nil {
		{
			size, err := m.Traffic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Traffic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Traffic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Traffic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Synack != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Synack))
		i--
		dAtA[i] = 0x70
	}
	if m.Syn != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Syn))
		i--
		dAtA[i] = 0x68
	}
	if m.L7Response != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L7Response))
		i--
		dAtA[i] = 0x60
	}
	if m.L7Request != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L7Request))
		i--
		dAtA[i] = 0x58
	}
	if m.ClosedFlow != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ClosedFlow))
		i--
		dAtA[i] = 0x50
	}
	if m.NewFlow != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.NewFlow))
		i--
		dAtA[i] = 0x48
	}
	if m.L4ByteRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L4ByteRx))
		i--
		dAtA[i] = 0x40
	}
	if m.L4ByteTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L4ByteTx))
		i--
		dAtA[i] = 0x38
	}
	if m.L3ByteRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L3ByteRx))
		i--
		dAtA[i] = 0x30
	}
	if m.L3ByteTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L3ByteTx))
		i--
		dAtA[i] = 0x28
	}
	if m.ByteRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ByteRx))
		i--
		dAtA[i] = 0x20
	}
	if m.ByteTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ByteTx))
		i--
		dAtA[i] = 0x18
	}
	if m.PacketRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.PacketRx))
		i--
		dAtA[i] = 0x10
	}
	if m.PacketTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.PacketTx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Latency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Latency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Latency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CitCount != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.CitCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CitSum != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.CitSum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.CitMax != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.CitMax))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.RrtCount != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RrtCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ArtCount != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ArtCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SrtCount != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.SrtCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.RttServerCount != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RttServerCount))
		i--
		dAtA[i] = 0x78
	}
	if m.RttClientCount != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RttClientCount))
		i--
		dAtA[i] = 0x70
	}
	if m.RttCount != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RttCount))
		i--
		dAtA[i] = 0x68
	}
	if m.RrtSum != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RrtSum))
		i--
		dAtA[i] = 0x60
	}
	if m.ArtSum != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ArtSum))
		i--
		dAtA[i] = 0x58
	}
	if m.SrtSum != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.SrtSum))
		i--
		dAtA[i] = 0x50
	}
	if m.RttServerSum != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RttServerSum))
		i--
		dAtA[i] = 0x48
	}
	if m.RttClientSum != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RttClientSum))
		i--
		dAtA[i] = 0x40
	}
	if m.RttSum != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RttSum))
		i--
		dAtA[i] = 0x38
	}
	if m.RrtMax != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RrtMax))
		i--
		dAtA[i] = 0x30
	}
	if m.ArtMax != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ArtMax))
		i--
		dAtA[i] = 0x28
	}
	if m.SrtMax != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.SrtMax))
		i--
		dAtA[i] = 0x20
	}
	if m.RttServerMax != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RttServerMax))
		i--
		dAtA[i] = 0x18
	}
	if m.RttClientMax != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RttClientMax))
		i--
		dAtA[i] = 0x10
	}
	if m.RttMax != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RttMax))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Performance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Performance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Performance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RetransSynack != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RetransSynack))
		i--
		dAtA[i] = 0x30
	}
	if m.RetransSyn != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RetransSyn))
		i--
		dAtA[i] = 0x28
	}
	if m.ZeroWinRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ZeroWinRx))
		i--
		dAtA[i] = 0x20
	}
	if m.ZeroWinTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ZeroWinTx))
		i--
		dAtA[i] = 0x18
	}
	if m.RetransRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RetransRx))
		i--
		dAtA[i] = 0x10
	}
	if m.RetransTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RetransTx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Anomaly) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Anomaly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Anomaly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.L7Timeout != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L7Timeout))
		i--
		dAtA[i] = 0x78
	}
	if m.L7ServerError != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L7ServerError))
		i--
		dAtA[i] = 0x70
	}
	if m.L7ClientError != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L7ClientError))
		i--
		dAtA[i] = 0x68
	}
	if m.TcpTimeout != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.TcpTimeout))
		i--
		dAtA[i] = 0x60
	}
	if m.ServerEstablishReset != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ServerEstablishReset))
		i--
		dAtA[i] = 0x58
	}
	if m.ServerQueueLack != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ServerQueueLack))
		i--
		dAtA[i] = 0x50
	}
	if m.ServerReset != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ServerReset))
		i--
		dAtA[i] = 0x48
	}
	if m.ClientEstablishReset != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ClientEstablishReset))
		i--
		dAtA[i] = 0x40
	}
	if m.ClientSourcePortReuse != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ClientSourcePortReuse))
		i--
		dAtA[i] = 0x38
	}
	if m.ServerHalfCloseFlow != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ServerHalfCloseFlow))
		i--
		dAtA[i] = 0x30
	}
	if m.ClientHalfCloseFlow != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ClientHalfCloseFlow))
		i--
		dAtA[i] = 0x28
	}
	if m.ServerSynackRepeat != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ServerSynackRepeat))
		i--
		dAtA[i] = 0x20
	}
	if m.ClientSynRepeat != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ClientSynRepeat))
		i--
		dAtA[i] = 0x18
	}
	if m.ServerRstFlow != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ServerRstFlow))
		i--
		dAtA[i] = 0x10
	}
	if m.ClientRstFlow != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ClientRstFlow))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowLoad) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowLoad) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowLoad) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Load != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Load))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UsageMeter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageMeter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageMeter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.L4ByteRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L4ByteRx))
		i--
		dAtA[i] = 0x40
	}
	if m.L4ByteTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L4ByteTx))
		i--
		dAtA[i] = 0x38
	}
	if m.L3ByteRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L3ByteRx))
		i--
		dAtA[i] = 0x30
	}
	if m.L3ByteTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.L3ByteTx))
		i--
		dAtA[i] = 0x28
	}
	if m.ByteRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ByteRx))
		i--
		dAtA[i] = 0x20
	}
	if m.ByteTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ByteTx))
		i--
		dAtA[i] = 0x18
	}
	if m.PacketRx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.PacketRx))
		i--
		dAtA[i] = 0x10
	}
	if m.PacketTx != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.PacketTx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppMeter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppMeter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppMeter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Anomaly != nil {
		{
			size, err := m.Anomaly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Latency != nil {
		{
			size, err := m.Latency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Traffic != nil {
		{
			size, err := m.Traffic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppTraffic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppTraffic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppTraffic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Response))
		i--
		dAtA[i] = 0x10
	}
	if m.Request != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Request))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppLatency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppLatency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppLatency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RrtCount != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RrtCount))
		i--
		dAtA[i] = 0x18
	}
	if m.RrtSum != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RrtSum))
		i--
		dAtA[i] = 0x10
	}
	if m.RrtMax != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.RrtMax))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppAnomaly) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppAnomaly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppAnomaly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timeout != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x18
	}
	if m.ServerError != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ServerError))
		i--
		dAtA[i] = 0x10
	}
	if m.ClientError != 0 {
		i = encodeVarintMetric(dAtA, i, uint64(m.ClientError))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetric(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetric(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MiniField) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovMetric(uint64(l))
	}
	l = len(m.Ip1)
	if l > 0 {
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.GlobalThreadId != 0 {
		n += 1 + sovMetric(uint64(m.GlobalThreadId))
	}
	if m.IsIpv6 != 0 {
		n += 1 + sovMetric(uint64(m.IsIpv6))
	}
	if m.L3EpcId != 0 {
		n += 1 + sovMetric(uint64(m.L3EpcId))
	}
	if m.L3EpcId1 != 0 {
		n += 1 + sovMetric(uint64(m.L3EpcId1))
	}
	if m.Mac != 0 {
		n += 1 + sovMetric(uint64(m.Mac))
	}
	if m.Mac1 != 0 {
		n += 1 + sovMetric(uint64(m.Mac1))
	}
	if m.Direction != 0 {
		n += 1 + sovMetric(uint64(m.Direction))
	}
	if m.TapSide != 0 {
		n += 1 + sovMetric(uint64(m.TapSide))
	}
	if m.Protocol != 0 {
		n += 1 + sovMetric(uint64(m.Protocol))
	}
	if m.AclGid != 0 {
		n += 1 + sovMetric(uint64(m.AclGid))
	}
	if m.ServerPort != 0 {
		n += 1 + sovMetric(uint64(m.ServerPort))
	}
	if m.VtapId != 0 {
		n += 1 + sovMetric(uint64(m.VtapId))
	}
	if m.TapPort != 0 {
		n += 1 + sovMetric(uint64(m.TapPort))
	}
	if m.TapType != 0 {
		n += 2 + sovMetric(uint64(m.TapType))
	}
	if m.L7Protocol != 0 {
		n += 2 + sovMetric(uint64(m.L7Protocol))
	}
	if m.TagType != 0 {
		n += 2 + sovMetric(uint64(m.TagType))
	}
	if m.TagValue != 0 {
		n += 2 + sovMetric(uint64(m.TagValue))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MiniTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Field != nil {
		l = m.Field.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovMetric(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Meter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MeterId != 0 {
		n += 1 + sovMetric(uint64(m.MeterId))
	}
	if m.Flow != nil {
		l = m.Flow.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.Usage != nil {
		l = m.Usage.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Document) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovMetric(uint64(m.Timestamp))
	}
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.Meter != nil {
		l = m.Meter.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.Flags != 0 {
		n += 1 + sovMetric(uint64(m.Flags))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowMeter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Traffic != nil {
		l = m.Traffic.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.Latency != nil {
		l = m.Latency.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.Performance != nil {
		l = m.Performance.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.Anomaly != nil {
		l = m.Anomaly.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.FlowLoad != nil {
		l = m.FlowLoad.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Traffic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PacketTx != 0 {
		n += 1 + sovMetric(uint64(m.PacketTx))
	}
	if m.PacketRx != 0 {
		n += 1 + sovMetric(uint64(m.PacketRx))
	}
	if m.ByteTx != 0 {
		n += 1 + sovMetric(uint64(m.ByteTx))
	}
	if m.ByteRx != 0 {
		n += 1 + sovMetric(uint64(m.ByteRx))
	}
	if m.L3ByteTx != 0 {
		n += 1 + sovMetric(uint64(m.L3ByteTx))
	}
	if m.L3ByteRx != 0 {
		n += 1 + sovMetric(uint64(m.L3ByteRx))
	}
	if m.L4ByteTx != 0 {
		n += 1 + sovMetric(uint64(m.L4ByteTx))
	}
	if m.L4ByteRx != 0 {
		n += 1 + sovMetric(uint64(m.L4ByteRx))
	}
	if m.NewFlow != 0 {
		n += 1 + sovMetric(uint64(m.NewFlow))
	}
	if m.ClosedFlow != 0 {
		n += 1 + sovMetric(uint64(m.ClosedFlow))
	}
	if m.L7Request != 0 {
		n += 1 + sovMetric(uint64(m.L7Request))
	}
	if m.L7Response != 0 {
		n += 1 + sovMetric(uint64(m.L7Response))
	}
	if m.Syn != 0 {
		n += 1 + sovMetric(uint64(m.Syn))
	}
	if m.Synack != 0 {
		n += 1 + sovMetric(uint64(m.Synack))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Latency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RttMax != 0 {
		n += 1 + sovMetric(uint64(m.RttMax))
	}
	if m.RttClientMax != 0 {
		n += 1 + sovMetric(uint64(m.RttClientMax))
	}
	if m.RttServerMax != 0 {
		n += 1 + sovMetric(uint64(m.RttServerMax))
	}
	if m.SrtMax != 0 {
		n += 1 + sovMetric(uint64(m.SrtMax))
	}
	if m.ArtMax != 0 {
		n += 1 + sovMetric(uint64(m.ArtMax))
	}
	if m.RrtMax != 0 {
		n += 1 + sovMetric(uint64(m.RrtMax))
	}
	if m.RttSum != 0 {
		n += 1 + sovMetric(uint64(m.RttSum))
	}
	if m.RttClientSum != 0 {
		n += 1 + sovMetric(uint64(m.RttClientSum))
	}
	if m.RttServerSum != 0 {
		n += 1 + sovMetric(uint64(m.RttServerSum))
	}
	if m.SrtSum != 0 {
		n += 1 + sovMetric(uint64(m.SrtSum))
	}
	if m.ArtSum != 0 {
		n += 1 + sovMetric(uint64(m.ArtSum))
	}
	if m.RrtSum != 0 {
		n += 1 + sovMetric(uint64(m.RrtSum))
	}
	if m.RttCount != 0 {
		n += 1 + sovMetric(uint64(m.RttCount))
	}
	if m.RttClientCount != 0 {
		n += 1 + sovMetric(uint64(m.RttClientCount))
	}
	if m.RttServerCount != 0 {
		n += 1 + sovMetric(uint64(m.RttServerCount))
	}
	if m.SrtCount != 0 {
		n += 2 + sovMetric(uint64(m.SrtCount))
	}
	if m.ArtCount != 0 {
		n += 2 + sovMetric(uint64(m.ArtCount))
	}
	if m.RrtCount != 0 {
		n += 2 + sovMetric(uint64(m.RrtCount))
	}
	if m.CitMax != 0 {
		n += 2 + sovMetric(uint64(m.CitMax))
	}
	if m.CitSum != 0 {
		n += 2 + sovMetric(uint64(m.CitSum))
	}
	if m.CitCount != 0 {
		n += 2 + sovMetric(uint64(m.CitCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Performance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetransTx != 0 {
		n += 1 + sovMetric(uint64(m.RetransTx))
	}
	if m.RetransRx != 0 {
		n += 1 + sovMetric(uint64(m.RetransRx))
	}
	if m.ZeroWinTx != 0 {
		n += 1 + sovMetric(uint64(m.ZeroWinTx))
	}
	if m.ZeroWinRx != 0 {
		n += 1 + sovMetric(uint64(m.ZeroWinRx))
	}
	if m.RetransSyn != 0 {
		n += 1 + sovMetric(uint64(m.RetransSyn))
	}
	if m.RetransSynack != 0 {
		n += 1 + sovMetric(uint64(m.RetransSynack))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Anomaly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientRstFlow != 0 {
		n += 1 + sovMetric(uint64(m.ClientRstFlow))
	}
	if m.ServerRstFlow != 0 {
		n += 1 + sovMetric(uint64(m.ServerRstFlow))
	}
	if m.ClientSynRepeat != 0 {
		n += 1 + sovMetric(uint64(m.ClientSynRepeat))
	}
	if m.ServerSynackRepeat != 0 {
		n += 1 + sovMetric(uint64(m.ServerSynackRepeat))
	}
	if m.ClientHalfCloseFlow != 0 {
		n += 1 + sovMetric(uint64(m.ClientHalfCloseFlow))
	}
	if m.ServerHalfCloseFlow != 0 {
		n += 1 + sovMetric(uint64(m.ServerHalfCloseFlow))
	}
	if m.ClientSourcePortReuse != 0 {
		n += 1 + sovMetric(uint64(m.ClientSourcePortReuse))
	}
	if m.ClientEstablishReset != 0 {
		n += 1 + sovMetric(uint64(m.ClientEstablishReset))
	}
	if m.ServerReset != 0 {
		n += 1 + sovMetric(uint64(m.ServerReset))
	}
	if m.ServerQueueLack != 0 {
		n += 1 + sovMetric(uint64(m.ServerQueueLack))
	}
	if m.ServerEstablishReset != 0 {
		n += 1 + sovMetric(uint64(m.ServerEstablishReset))
	}
	if m.TcpTimeout != 0 {
		n += 1 + sovMetric(uint64(m.TcpTimeout))
	}
	if m.L7ClientError != 0 {
		n += 1 + sovMetric(uint64(m.L7ClientError))
	}
	if m.L7ServerError != 0 {
		n += 1 + sovMetric(uint64(m.L7ServerError))
	}
	if m.L7Timeout != 0 {
		n += 1 + sovMetric(uint64(m.L7Timeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowLoad) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Load != 0 {
		n += 1 + sovMetric(uint64(m.Load))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageMeter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PacketTx != 0 {
		n += 1 + sovMetric(uint64(m.PacketTx))
	}
	if m.PacketRx != 0 {
		n += 1 + sovMetric(uint64(m.PacketRx))
	}
	if m.ByteTx != 0 {
		n += 1 + sovMetric(uint64(m.ByteTx))
	}
	if m.ByteRx != 0 {
		n += 1 + sovMetric(uint64(m.ByteRx))
	}
	if m.L3ByteTx != 0 {
		n += 1 + sovMetric(uint64(m.L3ByteTx))
	}
	if m.L3ByteRx != 0 {
		n += 1 + sovMetric(uint64(m.L3ByteRx))
	}
	if m.L4ByteTx != 0 {
		n += 1 + sovMetric(uint64(m.L4ByteTx))
	}
	if m.L4ByteRx != 0 {
		n += 1 + sovMetric(uint64(m.L4ByteRx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppMeter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Traffic != nil {
		l = m.Traffic.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.Latency != nil {
		l = m.Latency.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.Anomaly != nil {
		l = m.Anomaly.Size()
		n += 1 + l + sovMetric(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppTraffic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != 0 {
		n += 1 + sovMetric(uint64(m.Request))
	}
	if m.Response != 0 {
		n += 1 + sovMetric(uint64(m.Response))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppLatency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RrtMax != 0 {
		n += 1 + sovMetric(uint64(m.RrtMax))
	}
	if m.RrtSum != 0 {
		n += 1 + sovMetric(uint64(m.RrtSum))
	}
	if m.RrtCount != 0 {
		n += 1 + sovMetric(uint64(m.RrtCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppAnomaly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientError != 0 {
		n += 1 + sovMetric(uint64(m.ClientError))
	}
	if m.ServerError != 0 {
		n += 1 + sovMetric(uint64(m.ServerError))
	}
	if m.Timeout != 0 {
		n += 1 + sovMetric(uint64(m.Timeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetric(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetric(x uint64) (n int) {
	return sovMetric(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MiniField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiniField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiniField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = append(m.Ip[:0], dAtA[iNdEx:postIndex]...)
			if m.Ip == nil {
				m.Ip = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip1 = append(m.Ip1[:0], dAtA[iNdEx:postIndex]...)
			if m.Ip1 == nil {
				m.Ip1 = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalThreadId", wireType)
			}
			m.GlobalThreadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalThreadId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIpv6", wireType)
			}
			m.IsIpv6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsIpv6 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3EpcId", wireType)
			}
			m.L3EpcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3EpcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3EpcId1", wireType)
			}
			m.L3EpcId1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3EpcId1 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			m.Mac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mac |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac1", wireType)
			}
			m.Mac1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mac1 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapSide", wireType)
			}
			m.TapSide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TapSide |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclGid", wireType)
			}
			m.AclGid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AclGid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtapId", wireType)
			}
			m.VtapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VtapId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapPort", wireType)
			}
			m.TapPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TapPort |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapType", wireType)
			}
			m.TapType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TapType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7Protocol", wireType)
			}
			m.L7Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagType", wireType)
			}
			m.TagType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			m.TagValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagValue |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiniTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiniTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiniTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Field == nil {
				m.Field = &MiniField{}
			}
			if err := m.Field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Meter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Meter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Meter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeterId", wireType)
			}
			m.MeterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MeterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flow == nil {
				m.Flow = &FlowMeter{}
			}
			if err := m.Flow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Usage == nil {
				m.Usage = &UsageMeter{}
			}
			if err := m.Usage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &AppMeter{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &MiniTag{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meter == nil {
				m.Meter = &Meter{}
			}
			if err := m.Meter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMeter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMeter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMeter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traffic == nil {
				m.Traffic = &Traffic{}
			}
			if err := m.Traffic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Latency == nil {
				m.Latency = &Latency{}
			}
			if err := m.Latency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Performance == nil {
				m.Performance = &Performance{}
			}
			if err := m.Performance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anomaly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anomaly == nil {
				m.Anomaly = &Anomaly{}
			}
			if err := m.Anomaly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowLoad", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowLoad == nil {
				m.FlowLoad = &FlowLoad{}
			}
			if err := m.FlowLoad.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Traffic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Traffic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Traffic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketTx", wireType)
			}
			m.PacketTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketRx", wireType)
			}
			m.PacketRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteTx", wireType)
			}
			m.ByteTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteRx", wireType)
			}
			m.ByteRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3ByteTx", wireType)
			}
			m.L3ByteTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3ByteTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3ByteRx", wireType)
			}
			m.L3ByteRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3ByteRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4ByteTx", wireType)
			}
			m.L4ByteTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4ByteTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4ByteRx", wireType)
			}
			m.L4ByteRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4ByteRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFlow", wireType)
			}
			m.NewFlow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewFlow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedFlow", wireType)
			}
			m.ClosedFlow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClosedFlow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7Request", wireType)
			}
			m.L7Request = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7Request |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7Response", wireType)
			}
			m.L7Response = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7Response |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Syn", wireType)
			}
			m.Syn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Syn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synack", wireType)
			}
			m.Synack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Synack |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Latency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Latency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Latency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttMax", wireType)
			}
			m.RttMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttClientMax", wireType)
			}
			m.RttClientMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttClientMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttServerMax", wireType)
			}
			m.RttServerMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttServerMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrtMax", wireType)
			}
			m.SrtMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrtMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtMax", wireType)
			}
			m.ArtMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrtMax", wireType)
			}
			m.RrtMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrtMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttSum", wireType)
			}
			m.RttSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttClientSum", wireType)
			}
			m.RttClientSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttClientSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttServerSum", wireType)
			}
			m.RttServerSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttServerSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrtSum", wireType)
			}
			m.SrtSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrtSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtSum", wireType)
			}
			m.ArtSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrtSum", wireType)
			}
			m.RrtSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrtSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttCount", wireType)
			}
			m.RttCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttClientCount", wireType)
			}
			m.RttClientCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttClientCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttServerCount", wireType)
			}
			m.RttServerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttServerCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrtCount", wireType)
			}
			m.SrtCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrtCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtCount", wireType)
			}
			m.ArtCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrtCount", wireType)
			}
			m.RrtCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrtCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CitMax", wireType)
			}
			m.CitMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CitMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CitSum", wireType)
			}
			m.CitSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CitSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CitCount", wireType)
			}
			m.CitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CitCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Performance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Performance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Performance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransTx", wireType)
			}
			m.RetransTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransRx", wireType)
			}
			m.RetransRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroWinTx", wireType)
			}
			m.ZeroWinTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZeroWinTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroWinRx", wireType)
			}
			m.ZeroWinRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZeroWinRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransSyn", wireType)
			}
			m.RetransSyn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransSyn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransSynack", wireType)
			}
			m.RetransSynack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransSynack |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Anomaly) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Anomaly: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Anomaly: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRstFlow", wireType)
			}
			m.ClientRstFlow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientRstFlow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerRstFlow", wireType)
			}
			m.ServerRstFlow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerRstFlow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSynRepeat", wireType)
			}
			m.ClientSynRepeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientSynRepeat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSynackRepeat", wireType)
			}
			m.ServerSynackRepeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerSynackRepeat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientHalfCloseFlow", wireType)
			}
			m.ClientHalfCloseFlow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientHalfCloseFlow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerHalfCloseFlow", wireType)
			}
			m.ServerHalfCloseFlow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerHalfCloseFlow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSourcePortReuse", wireType)
			}
			m.ClientSourcePortReuse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientSourcePortReuse |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientEstablishReset", wireType)
			}
			m.ClientEstablishReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientEstablishReset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerReset", wireType)
			}
			m.ServerReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerReset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerQueueLack", wireType)
			}
			m.ServerQueueLack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerQueueLack |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerEstablishReset", wireType)
			}
			m.ServerEstablishReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerEstablishReset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTimeout", wireType)
			}
			m.TcpTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7ClientError", wireType)
			}
			m.L7ClientError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7ClientError |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7ServerError", wireType)
			}
			m.L7ServerError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7ServerError |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7Timeout", wireType)
			}
			m.L7Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7Timeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowLoad) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowLoad: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowLoad: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load", wireType)
			}
			m.Load = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Load |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageMeter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageMeter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageMeter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketTx", wireType)
			}
			m.PacketTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketRx", wireType)
			}
			m.PacketRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteTx", wireType)
			}
			m.ByteTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteRx", wireType)
			}
			m.ByteRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3ByteTx", wireType)
			}
			m.L3ByteTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3ByteTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3ByteRx", wireType)
			}
			m.L3ByteRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3ByteRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4ByteTx", wireType)
			}
			m.L4ByteTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4ByteTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4ByteRx", wireType)
			}
			m.L4ByteRx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4ByteRx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppMeter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppMeter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppMeter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traffic == nil {
				m.Traffic = &AppTraffic{}
			}
			if err := m.Traffic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Latency == nil {
				m.Latency = &AppLatency{}
			}
			if err := m.Latency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anomaly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anomaly == nil {
				m.Anomaly = &AppAnomaly{}
			}
			if err := m.Anomaly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppTraffic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppTraffic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppTraffic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			m.Request = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Request |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			m.Response = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Response |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppLatency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppLatency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppLatency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrtMax", wireType)
			}
			m.RrtMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrtMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrtSum", wireType)
			}
			m.RrtSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrtSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrtCount", wireType)
			}
			m.RrtCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrtCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppAnomaly) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppAnomaly: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppAnomaly: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientError", wireType)
			}
			m.ClientError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientError |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerError", wireType)
			}
			m.ServerError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerError |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetric(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetric
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetric
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetric
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetric
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetric        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetric          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetric = fmt.Errorf("proto: unexpected end of group")
)
