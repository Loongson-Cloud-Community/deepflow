// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flow_log.proto

package pb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TaggedFlow struct {
	Flow                 *Flow    `protobuf:"bytes,1,opt,name=flow,proto3" json:"flow,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaggedFlow) Reset()         { *m = TaggedFlow{} }
func (m *TaggedFlow) String() string { return proto.CompactTextString(m) }
func (*TaggedFlow) ProtoMessage()    {}
func (*TaggedFlow) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{0}
}
func (m *TaggedFlow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaggedFlow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaggedFlow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaggedFlow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaggedFlow.Merge(m, src)
}
func (m *TaggedFlow) XXX_Size() int {
	return m.Size()
}
func (m *TaggedFlow) XXX_DiscardUnknown() {
	xxx_messageInfo_TaggedFlow.DiscardUnknown(m)
}

var xxx_messageInfo_TaggedFlow proto.InternalMessageInfo

func (m *TaggedFlow) GetFlow() *Flow {
	if m != nil {
		return m.Flow
	}
	return nil
}

type Flow struct {
	FlowKey         *FlowKey         `protobuf:"bytes,1,opt,name=flow_key,json=flowKey,proto3" json:"flow_key,omitempty"`
	MetricsPeerSrc  *FlowMetricsPeer `protobuf:"bytes,2,opt,name=metrics_peer_src,json=metricsPeerSrc,proto3" json:"metrics_peer_src,omitempty"`
	MetricsPeerDst  *FlowMetricsPeer `protobuf:"bytes,3,opt,name=metrics_peer_dst,json=metricsPeerDst,proto3" json:"metrics_peer_dst,omitempty"`
	Tunnel          *TunnelField     `protobuf:"bytes,4,opt,name=Tunnel,proto3" json:"Tunnel,omitempty"`
	FlowId          uint64           `protobuf:"varint,5,opt,name=flow_id,json=flowId,proto3" json:"flow_id,omitempty"`
	StartTime       uint64           `protobuf:"varint,6,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime         uint64           `protobuf:"varint,7,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	Duration        uint64           `protobuf:"varint,8,opt,name=duration,proto3" json:"duration,omitempty"`
	Vlan            uint32           `protobuf:"varint,10,opt,name=vlan,proto3" json:"vlan,omitempty"`
	EthType         uint32           `protobuf:"varint,11,opt,name=eth_type,json=ethType,proto3" json:"eth_type,omitempty"`
	HasPerfStats    uint32           `protobuf:"varint,12,opt,name=has_perf_stats,json=hasPerfStats,proto3" json:"has_perf_stats,omitempty"`
	PerfStats       *FlowPerfStats   `protobuf:"bytes,13,opt,name=perf_stats,json=perfStats,proto3" json:"perf_stats,omitempty"`
	CloseType       uint32           `protobuf:"varint,14,opt,name=close_type,json=closeType,proto3" json:"close_type,omitempty"`
	FlowSource      uint32           `protobuf:"varint,15,opt,name=flow_source,json=flowSource,proto3" json:"flow_source,omitempty"`
	IsActiveService uint32           `protobuf:"varint,16,opt,name=is_active_service,json=isActiveService,proto3" json:"is_active_service,omitempty"`
	QueueHash       uint32           `protobuf:"varint,17,opt,name=queue_hash,json=queueHash,proto3" json:"queue_hash,omitempty"`
	IsNewFlow       uint32           `protobuf:"varint,18,opt,name=is_new_flow,json=isNewFlow,proto3" json:"is_new_flow,omitempty"`
	TapSide         uint32           `protobuf:"varint,19,opt,name=tap_side,json=tapSide,proto3" json:"tap_side,omitempty"`
	// TCP Seq
	SynSeq               uint32   `protobuf:"varint,20,opt,name=syn_seq,json=synSeq,proto3" json:"syn_seq,omitempty"`
	SynackSeq            uint32   `protobuf:"varint,21,opt,name=synack_seq,json=synackSeq,proto3" json:"synack_seq,omitempty"`
	LastKeepaliveSeq     uint32   `protobuf:"varint,22,opt,name=last_keepalive_seq,json=lastKeepaliveSeq,proto3" json:"last_keepalive_seq,omitempty"`
	LastKeepaliveAck     uint32   `protobuf:"varint,23,opt,name=last_keepalive_ack,json=lastKeepaliveAck,proto3" json:"last_keepalive_ack,omitempty"`
	AclGids              []uint32 `protobuf:"varint,24,rep,packed,name=acl_gids,json=aclGids,proto3" json:"acl_gids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Flow) Reset()         { *m = Flow{} }
func (m *Flow) String() string { return proto.CompactTextString(m) }
func (*Flow) ProtoMessage()    {}
func (*Flow) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{1}
}
func (m *Flow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Flow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flow.Merge(m, src)
}
func (m *Flow) XXX_Size() int {
	return m.Size()
}
func (m *Flow) XXX_DiscardUnknown() {
	xxx_messageInfo_Flow.DiscardUnknown(m)
}

var xxx_messageInfo_Flow proto.InternalMessageInfo

func (m *Flow) GetFlowKey() *FlowKey {
	if m != nil {
		return m.FlowKey
	}
	return nil
}

func (m *Flow) GetMetricsPeerSrc() *FlowMetricsPeer {
	if m != nil {
		return m.MetricsPeerSrc
	}
	return nil
}

func (m *Flow) GetMetricsPeerDst() *FlowMetricsPeer {
	if m != nil {
		return m.MetricsPeerDst
	}
	return nil
}

func (m *Flow) GetTunnel() *TunnelField {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

func (m *Flow) GetFlowId() uint64 {
	if m != nil {
		return m.FlowId
	}
	return 0
}

func (m *Flow) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Flow) GetEndTime() uint64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *Flow) GetDuration() uint64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Flow) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *Flow) GetEthType() uint32 {
	if m != nil {
		return m.EthType
	}
	return 0
}

func (m *Flow) GetHasPerfStats() uint32 {
	if m != nil {
		return m.HasPerfStats
	}
	return 0
}

func (m *Flow) GetPerfStats() *FlowPerfStats {
	if m != nil {
		return m.PerfStats
	}
	return nil
}

func (m *Flow) GetCloseType() uint32 {
	if m != nil {
		return m.CloseType
	}
	return 0
}

func (m *Flow) GetFlowSource() uint32 {
	if m != nil {
		return m.FlowSource
	}
	return 0
}

func (m *Flow) GetIsActiveService() uint32 {
	if m != nil {
		return m.IsActiveService
	}
	return 0
}

func (m *Flow) GetQueueHash() uint32 {
	if m != nil {
		return m.QueueHash
	}
	return 0
}

func (m *Flow) GetIsNewFlow() uint32 {
	if m != nil {
		return m.IsNewFlow
	}
	return 0
}

func (m *Flow) GetTapSide() uint32 {
	if m != nil {
		return m.TapSide
	}
	return 0
}

func (m *Flow) GetSynSeq() uint32 {
	if m != nil {
		return m.SynSeq
	}
	return 0
}

func (m *Flow) GetSynackSeq() uint32 {
	if m != nil {
		return m.SynackSeq
	}
	return 0
}

func (m *Flow) GetLastKeepaliveSeq() uint32 {
	if m != nil {
		return m.LastKeepaliveSeq
	}
	return 0
}

func (m *Flow) GetLastKeepaliveAck() uint32 {
	if m != nil {
		return m.LastKeepaliveAck
	}
	return 0
}

func (m *Flow) GetAclGids() []uint32 {
	if m != nil {
		return m.AclGids
	}
	return nil
}

type FlowKey struct {
	VtapId               uint32   `protobuf:"varint,1,opt,name=vtap_id,json=vtapId,proto3" json:"vtap_id,omitempty"`
	TapType              uint32   `protobuf:"varint,2,opt,name=tap_type,json=tapType,proto3" json:"tap_type,omitempty"`
	TapPort              uint64   `protobuf:"varint,3,opt,name=tap_port,json=tapPort,proto3" json:"tap_port,omitempty"`
	MacSrc               uint64   `protobuf:"varint,4,opt,name=mac_src,json=macSrc,proto3" json:"mac_src,omitempty"`
	MacDst               uint64   `protobuf:"varint,5,opt,name=mac_dst,json=macDst,proto3" json:"mac_dst,omitempty"`
	IpSrc                uint32   `protobuf:"varint,6,opt,name=ip_src,json=ipSrc,proto3" json:"ip_src,omitempty"`
	IpDst                uint32   `protobuf:"varint,7,opt,name=ip_dst,json=ipDst,proto3" json:"ip_dst,omitempty"`
	Ip6Src               []byte   `protobuf:"bytes,8,opt,name=ip6_src,json=ip6Src,proto3" json:"ip6_src,omitempty"`
	Ip6Dst               []byte   `protobuf:"bytes,9,opt,name=ip6_dst,json=ip6Dst,proto3" json:"ip6_dst,omitempty"`
	PortSrc              uint32   `protobuf:"varint,10,opt,name=port_src,json=portSrc,proto3" json:"port_src,omitempty"`
	PortDst              uint32   `protobuf:"varint,11,opt,name=port_dst,json=portDst,proto3" json:"port_dst,omitempty"`
	Proto                uint32   `protobuf:"varint,12,opt,name=proto,proto3" json:"proto,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowKey) Reset()         { *m = FlowKey{} }
func (m *FlowKey) String() string { return proto.CompactTextString(m) }
func (*FlowKey) ProtoMessage()    {}
func (*FlowKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{2}
}
func (m *FlowKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowKey.Merge(m, src)
}
func (m *FlowKey) XXX_Size() int {
	return m.Size()
}
func (m *FlowKey) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowKey.DiscardUnknown(m)
}

var xxx_messageInfo_FlowKey proto.InternalMessageInfo

func (m *FlowKey) GetVtapId() uint32 {
	if m != nil {
		return m.VtapId
	}
	return 0
}

func (m *FlowKey) GetTapType() uint32 {
	if m != nil {
		return m.TapType
	}
	return 0
}

func (m *FlowKey) GetTapPort() uint64 {
	if m != nil {
		return m.TapPort
	}
	return 0
}

func (m *FlowKey) GetMacSrc() uint64 {
	if m != nil {
		return m.MacSrc
	}
	return 0
}

func (m *FlowKey) GetMacDst() uint64 {
	if m != nil {
		return m.MacDst
	}
	return 0
}

func (m *FlowKey) GetIpSrc() uint32 {
	if m != nil {
		return m.IpSrc
	}
	return 0
}

func (m *FlowKey) GetIpDst() uint32 {
	if m != nil {
		return m.IpDst
	}
	return 0
}

func (m *FlowKey) GetIp6Src() []byte {
	if m != nil {
		return m.Ip6Src
	}
	return nil
}

func (m *FlowKey) GetIp6Dst() []byte {
	if m != nil {
		return m.Ip6Dst
	}
	return nil
}

func (m *FlowKey) GetPortSrc() uint32 {
	if m != nil {
		return m.PortSrc
	}
	return 0
}

func (m *FlowKey) GetPortDst() uint32 {
	if m != nil {
		return m.PortDst
	}
	return 0
}

func (m *FlowKey) GetProto() uint32 {
	if m != nil {
		return m.Proto
	}
	return 0
}

type FlowMetricsPeer struct {
	ByteCount            uint64   `protobuf:"varint,1,opt,name=byte_count,json=byteCount,proto3" json:"byte_count,omitempty"`
	L3ByteCount          uint64   `protobuf:"varint,2,opt,name=l3_byte_count,json=l3ByteCount,proto3" json:"l3_byte_count,omitempty"`
	L4ByteCount          uint64   `protobuf:"varint,3,opt,name=l4_byte_count,json=l4ByteCount,proto3" json:"l4_byte_count,omitempty"`
	PacketCount          uint64   `protobuf:"varint,4,opt,name=packet_count,json=packetCount,proto3" json:"packet_count,omitempty"`
	TotalByteCount       uint64   `protobuf:"varint,5,opt,name=total_byte_count,json=totalByteCount,proto3" json:"total_byte_count,omitempty"`
	TotalPacketCount     uint64   `protobuf:"varint,6,opt,name=total_packet_count,json=totalPacketCount,proto3" json:"total_packet_count,omitempty"`
	First                uint64   `protobuf:"varint,7,opt,name=first,proto3" json:"first,omitempty"`
	Last                 uint64   `protobuf:"varint,8,opt,name=last,proto3" json:"last,omitempty"`
	TcpFlags             uint32   `protobuf:"varint,9,opt,name=tcp_flags,json=tcpFlags,proto3" json:"tcp_flags,omitempty"`
	L3EpcId              int32    `protobuf:"varint,10,opt,name=l3_epc_id,json=l3EpcId,proto3" json:"l3_epc_id,omitempty"`
	IsL2End              uint32   `protobuf:"varint,11,opt,name=is_l2_end,json=isL2End,proto3" json:"is_l2_end,omitempty"`
	IsL3End              uint32   `protobuf:"varint,12,opt,name=is_l3_end,json=isL3End,proto3" json:"is_l3_end,omitempty"`
	IsActiveHost         uint32   `protobuf:"varint,13,opt,name=is_active_host,json=isActiveHost,proto3" json:"is_active_host,omitempty"`
	IsDevice             uint32   `protobuf:"varint,14,opt,name=is_device,json=isDevice,proto3" json:"is_device,omitempty"`
	IsVipInterface       uint32   `protobuf:"varint,15,opt,name=is_vip_interface,json=isVipInterface,proto3" json:"is_vip_interface,omitempty"`
	IsVip                uint32   `protobuf:"varint,16,opt,name=is_vip,json=isVip,proto3" json:"is_vip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowMetricsPeer) Reset()         { *m = FlowMetricsPeer{} }
func (m *FlowMetricsPeer) String() string { return proto.CompactTextString(m) }
func (*FlowMetricsPeer) ProtoMessage()    {}
func (*FlowMetricsPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{3}
}
func (m *FlowMetricsPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowMetricsPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowMetricsPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowMetricsPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowMetricsPeer.Merge(m, src)
}
func (m *FlowMetricsPeer) XXX_Size() int {
	return m.Size()
}
func (m *FlowMetricsPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowMetricsPeer.DiscardUnknown(m)
}

var xxx_messageInfo_FlowMetricsPeer proto.InternalMessageInfo

func (m *FlowMetricsPeer) GetByteCount() uint64 {
	if m != nil {
		return m.ByteCount
	}
	return 0
}

func (m *FlowMetricsPeer) GetL3ByteCount() uint64 {
	if m != nil {
		return m.L3ByteCount
	}
	return 0
}

func (m *FlowMetricsPeer) GetL4ByteCount() uint64 {
	if m != nil {
		return m.L4ByteCount
	}
	return 0
}

func (m *FlowMetricsPeer) GetPacketCount() uint64 {
	if m != nil {
		return m.PacketCount
	}
	return 0
}

func (m *FlowMetricsPeer) GetTotalByteCount() uint64 {
	if m != nil {
		return m.TotalByteCount
	}
	return 0
}

func (m *FlowMetricsPeer) GetTotalPacketCount() uint64 {
	if m != nil {
		return m.TotalPacketCount
	}
	return 0
}

func (m *FlowMetricsPeer) GetFirst() uint64 {
	if m != nil {
		return m.First
	}
	return 0
}

func (m *FlowMetricsPeer) GetLast() uint64 {
	if m != nil {
		return m.Last
	}
	return 0
}

func (m *FlowMetricsPeer) GetTcpFlags() uint32 {
	if m != nil {
		return m.TcpFlags
	}
	return 0
}

func (m *FlowMetricsPeer) GetL3EpcId() int32 {
	if m != nil {
		return m.L3EpcId
	}
	return 0
}

func (m *FlowMetricsPeer) GetIsL2End() uint32 {
	if m != nil {
		return m.IsL2End
	}
	return 0
}

func (m *FlowMetricsPeer) GetIsL3End() uint32 {
	if m != nil {
		return m.IsL3End
	}
	return 0
}

func (m *FlowMetricsPeer) GetIsActiveHost() uint32 {
	if m != nil {
		return m.IsActiveHost
	}
	return 0
}

func (m *FlowMetricsPeer) GetIsDevice() uint32 {
	if m != nil {
		return m.IsDevice
	}
	return 0
}

func (m *FlowMetricsPeer) GetIsVipInterface() uint32 {
	if m != nil {
		return m.IsVipInterface
	}
	return 0
}

func (m *FlowMetricsPeer) GetIsVip() uint32 {
	if m != nil {
		return m.IsVip
	}
	return 0
}

type TunnelField struct {
	TxIp0                uint32   `protobuf:"varint,1,opt,name=tx_ip0,json=txIp0,proto3" json:"tx_ip0,omitempty"`
	TxIp1                uint32   `protobuf:"varint,2,opt,name=tx_ip1,json=txIp1,proto3" json:"tx_ip1,omitempty"`
	RxIp0                uint32   `protobuf:"varint,3,opt,name=rx_ip0,json=rxIp0,proto3" json:"rx_ip0,omitempty"`
	RxIp1                uint32   `protobuf:"varint,4,opt,name=rx_ip1,json=rxIp1,proto3" json:"rx_ip1,omitempty"`
	TxMac0               uint32   `protobuf:"varint,5,opt,name=tx_mac0,json=txMac0,proto3" json:"tx_mac0,omitempty"`
	TxMac1               uint32   `protobuf:"varint,6,opt,name=tx_mac1,json=txMac1,proto3" json:"tx_mac1,omitempty"`
	RxMac0               uint32   `protobuf:"varint,7,opt,name=rx_mac0,json=rxMac0,proto3" json:"rx_mac0,omitempty"`
	RxMac1               uint32   `protobuf:"varint,8,opt,name=rx_mac1,json=rxMac1,proto3" json:"rx_mac1,omitempty"`
	TxId                 uint32   `protobuf:"varint,9,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	RxId                 uint32   `protobuf:"varint,10,opt,name=rx_id,json=rxId,proto3" json:"rx_id,omitempty"`
	TunnelType           uint32   `protobuf:"varint,11,opt,name=tunnel_type,json=tunnelType,proto3" json:"tunnel_type,omitempty"`
	Tier                 uint32   `protobuf:"varint,12,opt,name=tier,proto3" json:"tier,omitempty"`
	IsIpv6               uint32   `protobuf:"varint,13,opt,name=is_ipv6,json=isIpv6,proto3" json:"is_ipv6,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TunnelField) Reset()         { *m = TunnelField{} }
func (m *TunnelField) String() string { return proto.CompactTextString(m) }
func (*TunnelField) ProtoMessage()    {}
func (*TunnelField) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{4}
}
func (m *TunnelField) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelField.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelField.Merge(m, src)
}
func (m *TunnelField) XXX_Size() int {
	return m.Size()
}
func (m *TunnelField) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelField.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelField proto.InternalMessageInfo

func (m *TunnelField) GetTxIp0() uint32 {
	if m != nil {
		return m.TxIp0
	}
	return 0
}

func (m *TunnelField) GetTxIp1() uint32 {
	if m != nil {
		return m.TxIp1
	}
	return 0
}

func (m *TunnelField) GetRxIp0() uint32 {
	if m != nil {
		return m.RxIp0
	}
	return 0
}

func (m *TunnelField) GetRxIp1() uint32 {
	if m != nil {
		return m.RxIp1
	}
	return 0
}

func (m *TunnelField) GetTxMac0() uint32 {
	if m != nil {
		return m.TxMac0
	}
	return 0
}

func (m *TunnelField) GetTxMac1() uint32 {
	if m != nil {
		return m.TxMac1
	}
	return 0
}

func (m *TunnelField) GetRxMac0() uint32 {
	if m != nil {
		return m.RxMac0
	}
	return 0
}

func (m *TunnelField) GetRxMac1() uint32 {
	if m != nil {
		return m.RxMac1
	}
	return 0
}

func (m *TunnelField) GetTxId() uint32 {
	if m != nil {
		return m.TxId
	}
	return 0
}

func (m *TunnelField) GetRxId() uint32 {
	if m != nil {
		return m.RxId
	}
	return 0
}

func (m *TunnelField) GetTunnelType() uint32 {
	if m != nil {
		return m.TunnelType
	}
	return 0
}

func (m *TunnelField) GetTier() uint32 {
	if m != nil {
		return m.Tier
	}
	return 0
}

func (m *TunnelField) GetIsIpv6() uint32 {
	if m != nil {
		return m.IsIpv6
	}
	return 0
}

type FlowPerfStats struct {
	Tcp                  *TCPPerfStats `protobuf:"bytes,1,opt,name=tcp,proto3" json:"tcp,omitempty"`
	L7                   *L7PerfStats  `protobuf:"bytes,2,opt,name=l7,proto3" json:"l7,omitempty"`
	L4Protocol           uint32        `protobuf:"varint,3,opt,name=l4_protocol,json=l4Protocol,proto3" json:"l4_protocol,omitempty"`
	L7Protocol           uint32        `protobuf:"varint,4,opt,name=l7_protocol,json=l7Protocol,proto3" json:"l7_protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FlowPerfStats) Reset()         { *m = FlowPerfStats{} }
func (m *FlowPerfStats) String() string { return proto.CompactTextString(m) }
func (*FlowPerfStats) ProtoMessage()    {}
func (*FlowPerfStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{5}
}
func (m *FlowPerfStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowPerfStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowPerfStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowPerfStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowPerfStats.Merge(m, src)
}
func (m *FlowPerfStats) XXX_Size() int {
	return m.Size()
}
func (m *FlowPerfStats) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowPerfStats.DiscardUnknown(m)
}

var xxx_messageInfo_FlowPerfStats proto.InternalMessageInfo

func (m *FlowPerfStats) GetTcp() *TCPPerfStats {
	if m != nil {
		return m.Tcp
	}
	return nil
}

func (m *FlowPerfStats) GetL7() *L7PerfStats {
	if m != nil {
		return m.L7
	}
	return nil
}

func (m *FlowPerfStats) GetL4Protocol() uint32 {
	if m != nil {
		return m.L4Protocol
	}
	return 0
}

func (m *FlowPerfStats) GetL7Protocol() uint32 {
	if m != nil {
		return m.L7Protocol
	}
	return 0
}

type TCPPerfStats struct {
	RttClientMax         uint32             `protobuf:"varint,1,opt,name=rtt_client_max,json=rttClientMax,proto3" json:"rtt_client_max,omitempty"`
	RttServerMax         uint32             `protobuf:"varint,2,opt,name=rtt_server_max,json=rttServerMax,proto3" json:"rtt_server_max,omitempty"`
	SrtMax               uint32             `protobuf:"varint,3,opt,name=srt_max,json=srtMax,proto3" json:"srt_max,omitempty"`
	ArtMax               uint32             `protobuf:"varint,4,opt,name=art_max,json=artMax,proto3" json:"art_max,omitempty"`
	Rtt                  uint32             `protobuf:"varint,5,opt,name=rtt,proto3" json:"rtt,omitempty"`
	RttClientSum         uint32             `protobuf:"varint,6,opt,name=rtt_client_sum,json=rttClientSum,proto3" json:"rtt_client_sum,omitempty"`
	RttServerSum         uint32             `protobuf:"varint,7,opt,name=rtt_server_sum,json=rttServerSum,proto3" json:"rtt_server_sum,omitempty"`
	SrtSum               uint32             `protobuf:"varint,8,opt,name=srt_sum,json=srtSum,proto3" json:"srt_sum,omitempty"`
	ArtSum               uint32             `protobuf:"varint,9,opt,name=art_sum,json=artSum,proto3" json:"art_sum,omitempty"`
	RttClientCount       uint32             `protobuf:"varint,10,opt,name=rtt_client_count,json=rttClientCount,proto3" json:"rtt_client_count,omitempty"`
	RttServerCount       uint32             `protobuf:"varint,11,opt,name=rtt_server_count,json=rttServerCount,proto3" json:"rtt_server_count,omitempty"`
	SrtCount             uint32             `protobuf:"varint,12,opt,name=srt_count,json=srtCount,proto3" json:"srt_count,omitempty"`
	ArtCount             uint32             `protobuf:"varint,13,opt,name=art_count,json=artCount,proto3" json:"art_count,omitempty"`
	CountsPeerTx         *TcpPerfCountsPeer `protobuf:"bytes,14,opt,name=counts_peer_tx,json=countsPeerTx,proto3" json:"counts_peer_tx,omitempty"`
	CountsPeerRx         *TcpPerfCountsPeer `protobuf:"bytes,15,opt,name=counts_peer_rx,json=countsPeerRx,proto3" json:"counts_peer_rx,omitempty"`
	TotalRetransCount    uint32             `protobuf:"varint,16,opt,name=total_retrans_count,json=totalRetransCount,proto3" json:"total_retrans_count,omitempty"`
	SynCount             uint32             `protobuf:"varint,17,opt,name=syn_count,json=synCount,proto3" json:"syn_count,omitempty"`
	SynackCount          uint32             `protobuf:"varint,18,opt,name=synack_count,json=synackCount,proto3" json:"synack_count,omitempty"`
	CitMax               uint32             `protobuf:"varint,19,opt,name=cit_max,json=citMax,proto3" json:"cit_max,omitempty"`
	CitSum               uint32             `protobuf:"varint,20,opt,name=cit_sum,json=citSum,proto3" json:"cit_sum,omitempty"`
	CitCount             uint32             `protobuf:"varint,21,opt,name=cit_count,json=citCount,proto3" json:"cit_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TCPPerfStats) Reset()         { *m = TCPPerfStats{} }
func (m *TCPPerfStats) String() string { return proto.CompactTextString(m) }
func (*TCPPerfStats) ProtoMessage()    {}
func (*TCPPerfStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{6}
}
func (m *TCPPerfStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPPerfStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TCPPerfStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TCPPerfStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPPerfStats.Merge(m, src)
}
func (m *TCPPerfStats) XXX_Size() int {
	return m.Size()
}
func (m *TCPPerfStats) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPPerfStats.DiscardUnknown(m)
}

var xxx_messageInfo_TCPPerfStats proto.InternalMessageInfo

func (m *TCPPerfStats) GetRttClientMax() uint32 {
	if m != nil {
		return m.RttClientMax
	}
	return 0
}

func (m *TCPPerfStats) GetRttServerMax() uint32 {
	if m != nil {
		return m.RttServerMax
	}
	return 0
}

func (m *TCPPerfStats) GetSrtMax() uint32 {
	if m != nil {
		return m.SrtMax
	}
	return 0
}

func (m *TCPPerfStats) GetArtMax() uint32 {
	if m != nil {
		return m.ArtMax
	}
	return 0
}

func (m *TCPPerfStats) GetRtt() uint32 {
	if m != nil {
		return m.Rtt
	}
	return 0
}

func (m *TCPPerfStats) GetRttClientSum() uint32 {
	if m != nil {
		return m.RttClientSum
	}
	return 0
}

func (m *TCPPerfStats) GetRttServerSum() uint32 {
	if m != nil {
		return m.RttServerSum
	}
	return 0
}

func (m *TCPPerfStats) GetSrtSum() uint32 {
	if m != nil {
		return m.SrtSum
	}
	return 0
}

func (m *TCPPerfStats) GetArtSum() uint32 {
	if m != nil {
		return m.ArtSum
	}
	return 0
}

func (m *TCPPerfStats) GetRttClientCount() uint32 {
	if m != nil {
		return m.RttClientCount
	}
	return 0
}

func (m *TCPPerfStats) GetRttServerCount() uint32 {
	if m != nil {
		return m.RttServerCount
	}
	return 0
}

func (m *TCPPerfStats) GetSrtCount() uint32 {
	if m != nil {
		return m.SrtCount
	}
	return 0
}

func (m *TCPPerfStats) GetArtCount() uint32 {
	if m != nil {
		return m.ArtCount
	}
	return 0
}

func (m *TCPPerfStats) GetCountsPeerTx() *TcpPerfCountsPeer {
	if m != nil {
		return m.CountsPeerTx
	}
	return nil
}

func (m *TCPPerfStats) GetCountsPeerRx() *TcpPerfCountsPeer {
	if m != nil {
		return m.CountsPeerRx
	}
	return nil
}

func (m *TCPPerfStats) GetTotalRetransCount() uint32 {
	if m != nil {
		return m.TotalRetransCount
	}
	return 0
}

func (m *TCPPerfStats) GetSynCount() uint32 {
	if m != nil {
		return m.SynCount
	}
	return 0
}

func (m *TCPPerfStats) GetSynackCount() uint32 {
	if m != nil {
		return m.SynackCount
	}
	return 0
}

func (m *TCPPerfStats) GetCitMax() uint32 {
	if m != nil {
		return m.CitMax
	}
	return 0
}

func (m *TCPPerfStats) GetCitSum() uint32 {
	if m != nil {
		return m.CitSum
	}
	return 0
}

func (m *TCPPerfStats) GetCitCount() uint32 {
	if m != nil {
		return m.CitCount
	}
	return 0
}

type TcpPerfCountsPeer struct {
	RetransCount         uint32   `protobuf:"varint,1,opt,name=retrans_count,json=retransCount,proto3" json:"retrans_count,omitempty"`
	ZeroWinCount         uint32   `protobuf:"varint,2,opt,name=zero_win_count,json=zeroWinCount,proto3" json:"zero_win_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TcpPerfCountsPeer) Reset()         { *m = TcpPerfCountsPeer{} }
func (m *TcpPerfCountsPeer) String() string { return proto.CompactTextString(m) }
func (*TcpPerfCountsPeer) ProtoMessage()    {}
func (*TcpPerfCountsPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{7}
}
func (m *TcpPerfCountsPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpPerfCountsPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpPerfCountsPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpPerfCountsPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpPerfCountsPeer.Merge(m, src)
}
func (m *TcpPerfCountsPeer) XXX_Size() int {
	return m.Size()
}
func (m *TcpPerfCountsPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpPerfCountsPeer.DiscardUnknown(m)
}

var xxx_messageInfo_TcpPerfCountsPeer proto.InternalMessageInfo

func (m *TcpPerfCountsPeer) GetRetransCount() uint32 {
	if m != nil {
		return m.RetransCount
	}
	return 0
}

func (m *TcpPerfCountsPeer) GetZeroWinCount() uint32 {
	if m != nil {
		return m.ZeroWinCount
	}
	return 0
}

type L7PerfStats struct {
	RequestCount         uint32   `protobuf:"varint,1,opt,name=request_count,json=requestCount,proto3" json:"request_count,omitempty"`
	ResponseCount        uint32   `protobuf:"varint,2,opt,name=response_count,json=responseCount,proto3" json:"response_count,omitempty"`
	ErrClientCount       uint32   `protobuf:"varint,3,opt,name=err_client_count,json=errClientCount,proto3" json:"err_client_count,omitempty"`
	ErrServerCount       uint32   `protobuf:"varint,4,opt,name=err_server_count,json=errServerCount,proto3" json:"err_server_count,omitempty"`
	ErrTimeout           uint32   `protobuf:"varint,5,opt,name=err_timeout,json=errTimeout,proto3" json:"err_timeout,omitempty"`
	RrtCount             uint32   `protobuf:"varint,6,opt,name=rrt_count,json=rrtCount,proto3" json:"rrt_count,omitempty"`
	RrtSum               uint64   `protobuf:"varint,7,opt,name=rrt_sum,json=rrtSum,proto3" json:"rrt_sum,omitempty"`
	RrtMax               uint32   `protobuf:"varint,8,opt,name=rrt_max,json=rrtMax,proto3" json:"rrt_max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L7PerfStats) Reset()         { *m = L7PerfStats{} }
func (m *L7PerfStats) String() string { return proto.CompactTextString(m) }
func (*L7PerfStats) ProtoMessage()    {}
func (*L7PerfStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{8}
}
func (m *L7PerfStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L7PerfStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L7PerfStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L7PerfStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L7PerfStats.Merge(m, src)
}
func (m *L7PerfStats) XXX_Size() int {
	return m.Size()
}
func (m *L7PerfStats) XXX_DiscardUnknown() {
	xxx_messageInfo_L7PerfStats.DiscardUnknown(m)
}

var xxx_messageInfo_L7PerfStats proto.InternalMessageInfo

func (m *L7PerfStats) GetRequestCount() uint32 {
	if m != nil {
		return m.RequestCount
	}
	return 0
}

func (m *L7PerfStats) GetResponseCount() uint32 {
	if m != nil {
		return m.ResponseCount
	}
	return 0
}

func (m *L7PerfStats) GetErrClientCount() uint32 {
	if m != nil {
		return m.ErrClientCount
	}
	return 0
}

func (m *L7PerfStats) GetErrServerCount() uint32 {
	if m != nil {
		return m.ErrServerCount
	}
	return 0
}

func (m *L7PerfStats) GetErrTimeout() uint32 {
	if m != nil {
		return m.ErrTimeout
	}
	return 0
}

func (m *L7PerfStats) GetRrtCount() uint32 {
	if m != nil {
		return m.RrtCount
	}
	return 0
}

func (m *L7PerfStats) GetRrtSum() uint64 {
	if m != nil {
		return m.RrtSum
	}
	return 0
}

func (m *L7PerfStats) GetRrtMax() uint32 {
	if m != nil {
		return m.RrtMax
	}
	return 0
}

type L7Request struct {
	ReqType              string   `protobuf:"bytes,1,opt,name=req_type,json=reqType,proto3" json:"req_type,omitempty"`
	Domain               string   `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	Resource             string   `protobuf:"bytes,3,opt,name=resource,proto3" json:"resource,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L7Request) Reset()         { *m = L7Request{} }
func (m *L7Request) String() string { return proto.CompactTextString(m) }
func (*L7Request) ProtoMessage()    {}
func (*L7Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{9}
}
func (m *L7Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L7Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L7Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L7Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L7Request.Merge(m, src)
}
func (m *L7Request) XXX_Size() int {
	return m.Size()
}
func (m *L7Request) XXX_DiscardUnknown() {
	xxx_messageInfo_L7Request.DiscardUnknown(m)
}

var xxx_messageInfo_L7Request proto.InternalMessageInfo

func (m *L7Request) GetReqType() string {
	if m != nil {
		return m.ReqType
	}
	return ""
}

func (m *L7Request) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *L7Request) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

type L7Response struct {
	Status               uint32   `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	Code                 int32    `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Exception            string   `protobuf:"bytes,3,opt,name=exception,proto3" json:"exception,omitempty"`
	Result               string   `protobuf:"bytes,4,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L7Response) Reset()         { *m = L7Response{} }
func (m *L7Response) String() string { return proto.CompactTextString(m) }
func (*L7Response) ProtoMessage()    {}
func (*L7Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{10}
}
func (m *L7Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L7Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L7Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L7Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L7Response.Merge(m, src)
}
func (m *L7Response) XXX_Size() int {
	return m.Size()
}
func (m *L7Response) XXX_DiscardUnknown() {
	xxx_messageInfo_L7Response.DiscardUnknown(m)
}

var xxx_messageInfo_L7Response proto.InternalMessageInfo

func (m *L7Response) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *L7Response) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *L7Response) GetException() string {
	if m != nil {
		return m.Exception
	}
	return ""
}

func (m *L7Response) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

type TraceInfo struct {
	TraceId              string   `protobuf:"bytes,1,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	SpanId               string   `protobuf:"bytes,2,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
	ParentSpanId         string   `protobuf:"bytes,3,opt,name=parent_span_id,json=parentSpanId,proto3" json:"parent_span_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TraceInfo) Reset()         { *m = TraceInfo{} }
func (m *TraceInfo) String() string { return proto.CompactTextString(m) }
func (*TraceInfo) ProtoMessage()    {}
func (*TraceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{11}
}
func (m *TraceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceInfo.Merge(m, src)
}
func (m *TraceInfo) XXX_Size() int {
	return m.Size()
}
func (m *TraceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TraceInfo proto.InternalMessageInfo

func (m *TraceInfo) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	return ""
}

func (m *TraceInfo) GetSpanId() string {
	if m != nil {
		return m.SpanId
	}
	return ""
}

func (m *TraceInfo) GetParentSpanId() string {
	if m != nil {
		return m.ParentSpanId
	}
	return ""
}

type ExtendedInfo struct {
	ServiceName          string   `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	ClientIp             string   `protobuf:"bytes,2,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	RequestId            uint32   `protobuf:"varint,3,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	XRequestId           string   `protobuf:"bytes,4,opt,name=x_request_id,json=xRequestId,proto3" json:"x_request_id,omitempty"`
	RowEffect            uint32   `protobuf:"varint,5,opt,name=row_effect,json=rowEffect,proto3" json:"row_effect,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExtendedInfo) Reset()         { *m = ExtendedInfo{} }
func (m *ExtendedInfo) String() string { return proto.CompactTextString(m) }
func (*ExtendedInfo) ProtoMessage()    {}
func (*ExtendedInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{12}
}
func (m *ExtendedInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtendedInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtendedInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtendedInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtendedInfo.Merge(m, src)
}
func (m *ExtendedInfo) XXX_Size() int {
	return m.Size()
}
func (m *ExtendedInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtendedInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ExtendedInfo proto.InternalMessageInfo

func (m *ExtendedInfo) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *ExtendedInfo) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

func (m *ExtendedInfo) GetRequestId() uint32 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *ExtendedInfo) GetXRequestId() string {
	if m != nil {
		return m.XRequestId
	}
	return ""
}

func (m *ExtendedInfo) GetRowEffect() uint32 {
	if m != nil {
		return m.RowEffect
	}
	return 0
}

type AppProtoLogsData struct {
	Base *AppProtoLogsBaseInfo `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	// 后面使用统一适配结构,
	// 不再为每个协议单独定义结构,下面这些结构不应该再使用,后面会去掉
	Http                 *HttpInfo     `protobuf:"bytes,2,opt,name=http,proto3" json:"http,omitempty"`
	Dns                  *DnsInfo      `protobuf:"bytes,3,opt,name=dns,proto3" json:"dns,omitempty"`
	Dubbo                *DubboInfo    `protobuf:"bytes,4,opt,name=dubbo,proto3" json:"dubbo,omitempty"`
	Kafka                *KafkaInfo    `protobuf:"bytes,5,opt,name=kafka,proto3" json:"kafka,omitempty"`
	Mysql                *MysqlInfo    `protobuf:"bytes,6,opt,name=mysql,proto3" json:"mysql,omitempty"`
	Redis                *RedisInfo    `protobuf:"bytes,7,opt,name=redis,proto3" json:"redis,omitempty"`
	Mqtt                 *MqttInfo     `protobuf:"bytes,8,opt,name=mqtt,proto3" json:"mqtt,omitempty"`
	ReqLen               int32         `protobuf:"varint,9,opt,name=req_len,json=reqLen,proto3" json:"req_len,omitempty"`
	RespLen              int32         `protobuf:"varint,10,opt,name=resp_len,json=respLen,proto3" json:"resp_len,omitempty"`
	Req                  *L7Request    `protobuf:"bytes,11,opt,name=req,proto3" json:"req,omitempty"`
	Resp                 *L7Response   `protobuf:"bytes,12,opt,name=resp,proto3" json:"resp,omitempty"`
	Version              string        `protobuf:"bytes,13,opt,name=version,proto3" json:"version,omitempty"`
	TraceInfo            *TraceInfo    `protobuf:"bytes,14,opt,name=trace_info,json=traceInfo,proto3" json:"trace_info,omitempty"`
	ExtInfo              *ExtendedInfo `protobuf:"bytes,15,opt,name=ext_info,json=extInfo,proto3" json:"ext_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AppProtoLogsData) Reset()         { *m = AppProtoLogsData{} }
func (m *AppProtoLogsData) String() string { return proto.CompactTextString(m) }
func (*AppProtoLogsData) ProtoMessage()    {}
func (*AppProtoLogsData) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{13}
}
func (m *AppProtoLogsData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppProtoLogsData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppProtoLogsData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppProtoLogsData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppProtoLogsData.Merge(m, src)
}
func (m *AppProtoLogsData) XXX_Size() int {
	return m.Size()
}
func (m *AppProtoLogsData) XXX_DiscardUnknown() {
	xxx_messageInfo_AppProtoLogsData.DiscardUnknown(m)
}

var xxx_messageInfo_AppProtoLogsData proto.InternalMessageInfo

func (m *AppProtoLogsData) GetBase() *AppProtoLogsBaseInfo {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *AppProtoLogsData) GetHttp() *HttpInfo {
	if m != nil {
		return m.Http
	}
	return nil
}

func (m *AppProtoLogsData) GetDns() *DnsInfo {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *AppProtoLogsData) GetDubbo() *DubboInfo {
	if m != nil {
		return m.Dubbo
	}
	return nil
}

func (m *AppProtoLogsData) GetKafka() *KafkaInfo {
	if m != nil {
		return m.Kafka
	}
	return nil
}

func (m *AppProtoLogsData) GetMysql() *MysqlInfo {
	if m != nil {
		return m.Mysql
	}
	return nil
}

func (m *AppProtoLogsData) GetRedis() *RedisInfo {
	if m != nil {
		return m.Redis
	}
	return nil
}

func (m *AppProtoLogsData) GetMqtt() *MqttInfo {
	if m != nil {
		return m.Mqtt
	}
	return nil
}

func (m *AppProtoLogsData) GetReqLen() int32 {
	if m != nil {
		return m.ReqLen
	}
	return 0
}

func (m *AppProtoLogsData) GetRespLen() int32 {
	if m != nil {
		return m.RespLen
	}
	return 0
}

func (m *AppProtoLogsData) GetReq() *L7Request {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *AppProtoLogsData) GetResp() *L7Response {
	if m != nil {
		return m.Resp
	}
	return nil
}

func (m *AppProtoLogsData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *AppProtoLogsData) GetTraceInfo() *TraceInfo {
	if m != nil {
		return m.TraceInfo
	}
	return nil
}

func (m *AppProtoLogsData) GetExtInfo() *ExtendedInfo {
	if m != nil {
		return m.ExtInfo
	}
	return nil
}

type AppProtoLogsBaseInfo struct {
	StartTime              uint64        `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime                uint64        `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	FlowId                 uint64        `protobuf:"varint,3,opt,name=flow_id,json=flowId,proto3" json:"flow_id,omitempty"`
	TapPort                uint64        `protobuf:"varint,4,opt,name=tap_port,json=tapPort,proto3" json:"tap_port,omitempty"`
	VtapId                 uint32        `protobuf:"varint,5,opt,name=vtap_id,json=vtapId,proto3" json:"vtap_id,omitempty"`
	TapType                uint32        `protobuf:"varint,6,opt,name=tap_type,json=tapType,proto3" json:"tap_type,omitempty"`
	IsIpv6                 uint32        `protobuf:"varint,7,opt,name=is_ipv6,json=isIpv6,proto3" json:"is_ipv6,omitempty"`
	TapSide                uint32        `protobuf:"varint,8,opt,name=tap_side,json=tapSide,proto3" json:"tap_side,omitempty"`
	Head                   *AppProtoHead `protobuf:"bytes,9,opt,name=head,proto3" json:"head,omitempty"`
	MacSrc                 uint64        `protobuf:"varint,10,opt,name=mac_src,json=macSrc,proto3" json:"mac_src,omitempty"`
	MacDst                 uint64        `protobuf:"varint,11,opt,name=mac_dst,json=macDst,proto3" json:"mac_dst,omitempty"`
	IpSrc                  uint32        `protobuf:"varint,12,opt,name=ip_src,json=ipSrc,proto3" json:"ip_src,omitempty"`
	IpDst                  uint32        `protobuf:"varint,13,opt,name=ip_dst,json=ipDst,proto3" json:"ip_dst,omitempty"`
	Ip6Src                 []byte        `protobuf:"bytes,14,opt,name=ip6_src,json=ip6Src,proto3" json:"ip6_src,omitempty"`
	Ip6Dst                 []byte        `protobuf:"bytes,15,opt,name=ip6_dst,json=ip6Dst,proto3" json:"ip6_dst,omitempty"`
	L3EpcIdSrc             int32         `protobuf:"varint,16,opt,name=l3_epc_id_src,json=l3EpcIdSrc,proto3" json:"l3_epc_id_src,omitempty"`
	L3EpcIdDst             int32         `protobuf:"varint,17,opt,name=l3_epc_id_dst,json=l3EpcIdDst,proto3" json:"l3_epc_id_dst,omitempty"`
	PortSrc                uint32        `protobuf:"varint,18,opt,name=port_src,json=portSrc,proto3" json:"port_src,omitempty"`
	PortDst                uint32        `protobuf:"varint,19,opt,name=port_dst,json=portDst,proto3" json:"port_dst,omitempty"`
	Protocol               uint32        `protobuf:"varint,20,opt,name=protocol,proto3" json:"protocol,omitempty"`
	IsVipInterfaceSrc      uint32        `protobuf:"varint,21,opt,name=is_vip_interface_src,json=isVipInterfaceSrc,proto3" json:"is_vip_interface_src,omitempty"`
	IsVipInterfaceDst      uint32        `protobuf:"varint,22,opt,name=is_vip_interface_dst,json=isVipInterfaceDst,proto3" json:"is_vip_interface_dst,omitempty"`
	ReqTcpSeq              uint32        `protobuf:"varint,23,opt,name=req_tcp_seq,json=reqTcpSeq,proto3" json:"req_tcp_seq,omitempty"`
	RespTcpSeq             uint32        `protobuf:"varint,24,opt,name=resp_tcp_seq,json=respTcpSeq,proto3" json:"resp_tcp_seq,omitempty"`
	ProcessId_0            uint32        `protobuf:"varint,25,opt,name=process_id_0,json=processId0,proto3" json:"process_id_0,omitempty"`
	ProcessId_1            uint32        `protobuf:"varint,26,opt,name=process_id_1,json=processId1,proto3" json:"process_id_1,omitempty"`
	ProcessKname_0         string        `protobuf:"bytes,27,opt,name=process_kname_0,json=processKname0,proto3" json:"process_kname_0,omitempty"`
	ProcessKname_1         string        `protobuf:"bytes,28,opt,name=process_kname_1,json=processKname1,proto3" json:"process_kname_1,omitempty"`
	SyscallTraceIdRequest  uint64        `protobuf:"varint,29,opt,name=syscall_trace_id_request,json=syscallTraceIdRequest,proto3" json:"syscall_trace_id_request,omitempty"`
	SyscallTraceIdResponse uint64        `protobuf:"varint,30,opt,name=syscall_trace_id_response,json=syscallTraceIdResponse,proto3" json:"syscall_trace_id_response,omitempty"`
	SyscallTraceIdThread_0 uint32        `protobuf:"varint,31,opt,name=syscall_trace_id_thread_0,json=syscallTraceIdThread0,proto3" json:"syscall_trace_id_thread_0,omitempty"`
	SyscallTraceIdThread_1 uint32        `protobuf:"varint,32,opt,name=syscall_trace_id_thread_1,json=syscallTraceIdThread1,proto3" json:"syscall_trace_id_thread_1,omitempty"`
	SyscallCapSeq_0        uint32        `protobuf:"varint,33,opt,name=syscall_cap_seq_0,json=syscallCapSeq0,proto3" json:"syscall_cap_seq_0,omitempty"`
	SyscallCapSeq_1        uint32        `protobuf:"varint,34,opt,name=syscall_cap_seq_1,json=syscallCapSeq1,proto3" json:"syscall_cap_seq_1,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}      `json:"-"`
	XXX_unrecognized       []byte        `json:"-"`
	XXX_sizecache          int32         `json:"-"`
}

func (m *AppProtoLogsBaseInfo) Reset()         { *m = AppProtoLogsBaseInfo{} }
func (m *AppProtoLogsBaseInfo) String() string { return proto.CompactTextString(m) }
func (*AppProtoLogsBaseInfo) ProtoMessage()    {}
func (*AppProtoLogsBaseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{14}
}
func (m *AppProtoLogsBaseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppProtoLogsBaseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppProtoLogsBaseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppProtoLogsBaseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppProtoLogsBaseInfo.Merge(m, src)
}
func (m *AppProtoLogsBaseInfo) XXX_Size() int {
	return m.Size()
}
func (m *AppProtoLogsBaseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AppProtoLogsBaseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AppProtoLogsBaseInfo proto.InternalMessageInfo

func (m *AppProtoLogsBaseInfo) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetEndTime() uint64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetFlowId() uint64 {
	if m != nil {
		return m.FlowId
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetTapPort() uint64 {
	if m != nil {
		return m.TapPort
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetVtapId() uint32 {
	if m != nil {
		return m.VtapId
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetTapType() uint32 {
	if m != nil {
		return m.TapType
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetIsIpv6() uint32 {
	if m != nil {
		return m.IsIpv6
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetTapSide() uint32 {
	if m != nil {
		return m.TapSide
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetHead() *AppProtoHead {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *AppProtoLogsBaseInfo) GetMacSrc() uint64 {
	if m != nil {
		return m.MacSrc
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetMacDst() uint64 {
	if m != nil {
		return m.MacDst
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetIpSrc() uint32 {
	if m != nil {
		return m.IpSrc
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetIpDst() uint32 {
	if m != nil {
		return m.IpDst
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetIp6Src() []byte {
	if m != nil {
		return m.Ip6Src
	}
	return nil
}

func (m *AppProtoLogsBaseInfo) GetIp6Dst() []byte {
	if m != nil {
		return m.Ip6Dst
	}
	return nil
}

func (m *AppProtoLogsBaseInfo) GetL3EpcIdSrc() int32 {
	if m != nil {
		return m.L3EpcIdSrc
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetL3EpcIdDst() int32 {
	if m != nil {
		return m.L3EpcIdDst
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetPortSrc() uint32 {
	if m != nil {
		return m.PortSrc
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetPortDst() uint32 {
	if m != nil {
		return m.PortDst
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetProtocol() uint32 {
	if m != nil {
		return m.Protocol
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetIsVipInterfaceSrc() uint32 {
	if m != nil {
		return m.IsVipInterfaceSrc
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetIsVipInterfaceDst() uint32 {
	if m != nil {
		return m.IsVipInterfaceDst
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetReqTcpSeq() uint32 {
	if m != nil {
		return m.ReqTcpSeq
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetRespTcpSeq() uint32 {
	if m != nil {
		return m.RespTcpSeq
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetProcessId_0() uint32 {
	if m != nil {
		return m.ProcessId_0
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetProcessId_1() uint32 {
	if m != nil {
		return m.ProcessId_1
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetProcessKname_0() string {
	if m != nil {
		return m.ProcessKname_0
	}
	return ""
}

func (m *AppProtoLogsBaseInfo) GetProcessKname_1() string {
	if m != nil {
		return m.ProcessKname_1
	}
	return ""
}

func (m *AppProtoLogsBaseInfo) GetSyscallTraceIdRequest() uint64 {
	if m != nil {
		return m.SyscallTraceIdRequest
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetSyscallTraceIdResponse() uint64 {
	if m != nil {
		return m.SyscallTraceIdResponse
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetSyscallTraceIdThread_0() uint32 {
	if m != nil {
		return m.SyscallTraceIdThread_0
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetSyscallTraceIdThread_1() uint32 {
	if m != nil {
		return m.SyscallTraceIdThread_1
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetSyscallCapSeq_0() uint32 {
	if m != nil {
		return m.SyscallCapSeq_0
	}
	return 0
}

func (m *AppProtoLogsBaseInfo) GetSyscallCapSeq_1() uint32 {
	if m != nil {
		return m.SyscallCapSeq_1
	}
	return 0
}

type AppProtoHead struct {
	Proto   uint32 `protobuf:"varint,1,opt,name=proto,proto3" json:"proto,omitempty"`
	MsgType uint32 `protobuf:"varint,2,opt,name=msg_type,json=msgType,proto3" json:"msg_type,omitempty"`
	// 这两个字段不再使用,响应码和响应状态放到L7Response
	Status               uint32   `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
	Code                 uint32   `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
	Rrt                  uint64   `protobuf:"varint,5,opt,name=rrt,proto3" json:"rrt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppProtoHead) Reset()         { *m = AppProtoHead{} }
func (m *AppProtoHead) String() string { return proto.CompactTextString(m) }
func (*AppProtoHead) ProtoMessage()    {}
func (*AppProtoHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{15}
}
func (m *AppProtoHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppProtoHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppProtoHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppProtoHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppProtoHead.Merge(m, src)
}
func (m *AppProtoHead) XXX_Size() int {
	return m.Size()
}
func (m *AppProtoHead) XXX_DiscardUnknown() {
	xxx_messageInfo_AppProtoHead.DiscardUnknown(m)
}

var xxx_messageInfo_AppProtoHead proto.InternalMessageInfo

func (m *AppProtoHead) GetProto() uint32 {
	if m != nil {
		return m.Proto
	}
	return 0
}

func (m *AppProtoHead) GetMsgType() uint32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *AppProtoHead) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *AppProtoHead) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *AppProtoHead) GetRrt() uint64 {
	if m != nil {
		return m.Rrt
	}
	return 0
}

type HttpInfo struct {
	StreamId             uint32   `protobuf:"varint,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	Version              string   `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Method               string   `protobuf:"bytes,4,opt,name=method,proto3" json:"method,omitempty"`
	Path                 string   `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	Host                 string   `protobuf:"bytes,6,opt,name=host,proto3" json:"host,omitempty"`
	ClientIp             string   `protobuf:"bytes,7,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	TraceId              string   `protobuf:"bytes,8,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	SpanId               string   `protobuf:"bytes,9,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
	ReqContentLength     int64    `protobuf:"varint,10,opt,name=req_content_length,json=reqContentLength,proto3" json:"req_content_length,omitempty"`
	RespContentLength    int64    `protobuf:"varint,11,opt,name=resp_content_length,json=respContentLength,proto3" json:"resp_content_length,omitempty"`
	XRequestId           string   `protobuf:"bytes,12,opt,name=x_request_id,json=xRequestId,proto3" json:"x_request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HttpInfo) Reset()         { *m = HttpInfo{} }
func (m *HttpInfo) String() string { return proto.CompactTextString(m) }
func (*HttpInfo) ProtoMessage()    {}
func (*HttpInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{16}
}
func (m *HttpInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpInfo.Merge(m, src)
}
func (m *HttpInfo) XXX_Size() int {
	return m.Size()
}
func (m *HttpInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HttpInfo proto.InternalMessageInfo

func (m *HttpInfo) GetStreamId() uint32 {
	if m != nil {
		return m.StreamId
	}
	return 0
}

func (m *HttpInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *HttpInfo) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *HttpInfo) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HttpInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *HttpInfo) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

func (m *HttpInfo) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	return ""
}

func (m *HttpInfo) GetSpanId() string {
	if m != nil {
		return m.SpanId
	}
	return ""
}

func (m *HttpInfo) GetReqContentLength() int64 {
	if m != nil {
		return m.ReqContentLength
	}
	return 0
}

func (m *HttpInfo) GetRespContentLength() int64 {
	if m != nil {
		return m.RespContentLength
	}
	return 0
}

func (m *HttpInfo) GetXRequestId() string {
	if m != nil {
		return m.XRequestId
	}
	return ""
}

type DnsInfo struct {
	TransId              uint32   `protobuf:"varint,1,opt,name=trans_id,json=transId,proto3" json:"trans_id,omitempty"`
	QueryType            uint32   `protobuf:"varint,2,opt,name=query_type,json=queryType,proto3" json:"query_type,omitempty"`
	QueryName            string   `protobuf:"bytes,3,opt,name=query_name,json=queryName,proto3" json:"query_name,omitempty"`
	Answers              string   `protobuf:"bytes,4,opt,name=answers,proto3" json:"answers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DnsInfo) Reset()         { *m = DnsInfo{} }
func (m *DnsInfo) String() string { return proto.CompactTextString(m) }
func (*DnsInfo) ProtoMessage()    {}
func (*DnsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{17}
}
func (m *DnsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsInfo.Merge(m, src)
}
func (m *DnsInfo) XXX_Size() int {
	return m.Size()
}
func (m *DnsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DnsInfo proto.InternalMessageInfo

func (m *DnsInfo) GetTransId() uint32 {
	if m != nil {
		return m.TransId
	}
	return 0
}

func (m *DnsInfo) GetQueryType() uint32 {
	if m != nil {
		return m.QueryType
	}
	return 0
}

func (m *DnsInfo) GetQueryName() string {
	if m != nil {
		return m.QueryName
	}
	return ""
}

func (m *DnsInfo) GetAnswers() string {
	if m != nil {
		return m.Answers
	}
	return ""
}

type DubboInfo struct {
	SerialId             uint32   `protobuf:"varint,1,opt,name=serial_id,json=serialId,proto3" json:"serial_id,omitempty"`
	Type                 uint32   `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Id                   uint32   `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	Version              string   `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
	ServiceName          string   `protobuf:"bytes,6,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	ServiceVersion       string   `protobuf:"bytes,7,opt,name=service_version,json=serviceVersion,proto3" json:"service_version,omitempty"`
	MethodName           string   `protobuf:"bytes,8,opt,name=method_name,json=methodName,proto3" json:"method_name,omitempty"`
	ReqBodyLen           int32    `protobuf:"varint,9,opt,name=req_body_len,json=reqBodyLen,proto3" json:"req_body_len,omitempty"`
	RespBodyLen          int32    `protobuf:"varint,10,opt,name=resp_body_len,json=respBodyLen,proto3" json:"resp_body_len,omitempty"`
	TraceId              string   `protobuf:"bytes,11,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DubboInfo) Reset()         { *m = DubboInfo{} }
func (m *DubboInfo) String() string { return proto.CompactTextString(m) }
func (*DubboInfo) ProtoMessage()    {}
func (*DubboInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{18}
}
func (m *DubboInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DubboInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DubboInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DubboInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DubboInfo.Merge(m, src)
}
func (m *DubboInfo) XXX_Size() int {
	return m.Size()
}
func (m *DubboInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DubboInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DubboInfo proto.InternalMessageInfo

func (m *DubboInfo) GetSerialId() uint32 {
	if m != nil {
		return m.SerialId
	}
	return 0
}

func (m *DubboInfo) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DubboInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DubboInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DubboInfo) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *DubboInfo) GetServiceVersion() string {
	if m != nil {
		return m.ServiceVersion
	}
	return ""
}

func (m *DubboInfo) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

func (m *DubboInfo) GetReqBodyLen() int32 {
	if m != nil {
		return m.ReqBodyLen
	}
	return 0
}

func (m *DubboInfo) GetRespBodyLen() int32 {
	if m != nil {
		return m.RespBodyLen
	}
	return 0
}

func (m *DubboInfo) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	return ""
}

type KafkaInfo struct {
	CorrelationId        uint32   `protobuf:"varint,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
	ReqMsgSize           int32    `protobuf:"varint,2,opt,name=req_msg_size,json=reqMsgSize,proto3" json:"req_msg_size,omitempty"`
	ApiVersion           uint32   `protobuf:"varint,3,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	ApiKey               uint32   `protobuf:"varint,4,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	ClientId             string   `protobuf:"bytes,5,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	RespMsgSize          int32    `protobuf:"varint,6,opt,name=resp_msg_size,json=respMsgSize,proto3" json:"resp_msg_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KafkaInfo) Reset()         { *m = KafkaInfo{} }
func (m *KafkaInfo) String() string { return proto.CompactTextString(m) }
func (*KafkaInfo) ProtoMessage()    {}
func (*KafkaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{19}
}
func (m *KafkaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KafkaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KafkaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KafkaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KafkaInfo.Merge(m, src)
}
func (m *KafkaInfo) XXX_Size() int {
	return m.Size()
}
func (m *KafkaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KafkaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KafkaInfo proto.InternalMessageInfo

func (m *KafkaInfo) GetCorrelationId() uint32 {
	if m != nil {
		return m.CorrelationId
	}
	return 0
}

func (m *KafkaInfo) GetReqMsgSize() int32 {
	if m != nil {
		return m.ReqMsgSize
	}
	return 0
}

func (m *KafkaInfo) GetApiVersion() uint32 {
	if m != nil {
		return m.ApiVersion
	}
	return 0
}

func (m *KafkaInfo) GetApiKey() uint32 {
	if m != nil {
		return m.ApiKey
	}
	return 0
}

func (m *KafkaInfo) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *KafkaInfo) GetRespMsgSize() int32 {
	if m != nil {
		return m.RespMsgSize
	}
	return 0
}

type MysqlInfo struct {
	ProtocolVersion      uint32   `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	ServerVersion        string   `protobuf:"bytes,2,opt,name=server_version,json=serverVersion,proto3" json:"server_version,omitempty"`
	ServerThreadId       uint32   `protobuf:"varint,3,opt,name=server_thread_id,json=serverThreadId,proto3" json:"server_thread_id,omitempty"`
	Command              uint32   `protobuf:"varint,4,opt,name=command,proto3" json:"command,omitempty"`
	Context              string   `protobuf:"bytes,5,opt,name=context,proto3" json:"context,omitempty"`
	ResponseCode         uint32   `protobuf:"varint,6,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	AffectedRows         uint64   `protobuf:"varint,7,opt,name=affected_rows,json=affectedRows,proto3" json:"affected_rows,omitempty"`
	ErrorCode            uint32   `protobuf:"varint,8,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ErrorMessage         string   `protobuf:"bytes,9,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MysqlInfo) Reset()         { *m = MysqlInfo{} }
func (m *MysqlInfo) String() string { return proto.CompactTextString(m) }
func (*MysqlInfo) ProtoMessage()    {}
func (*MysqlInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{20}
}
func (m *MysqlInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MysqlInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MysqlInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MysqlInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MysqlInfo.Merge(m, src)
}
func (m *MysqlInfo) XXX_Size() int {
	return m.Size()
}
func (m *MysqlInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MysqlInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MysqlInfo proto.InternalMessageInfo

func (m *MysqlInfo) GetProtocolVersion() uint32 {
	if m != nil {
		return m.ProtocolVersion
	}
	return 0
}

func (m *MysqlInfo) GetServerVersion() string {
	if m != nil {
		return m.ServerVersion
	}
	return ""
}

func (m *MysqlInfo) GetServerThreadId() uint32 {
	if m != nil {
		return m.ServerThreadId
	}
	return 0
}

func (m *MysqlInfo) GetCommand() uint32 {
	if m != nil {
		return m.Command
	}
	return 0
}

func (m *MysqlInfo) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *MysqlInfo) GetResponseCode() uint32 {
	if m != nil {
		return m.ResponseCode
	}
	return 0
}

func (m *MysqlInfo) GetAffectedRows() uint64 {
	if m != nil {
		return m.AffectedRows
	}
	return 0
}

func (m *MysqlInfo) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *MysqlInfo) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type RedisInfo struct {
	Request              []byte   `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	RequestType          []byte   `protobuf:"bytes,2,opt,name=request_type,json=requestType,proto3" json:"request_type,omitempty"`
	Response             []byte   `protobuf:"bytes,3,opt,name=response,proto3" json:"response,omitempty"`
	Status               []byte   `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	Error                []byte   `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RedisInfo) Reset()         { *m = RedisInfo{} }
func (m *RedisInfo) String() string { return proto.CompactTextString(m) }
func (*RedisInfo) ProtoMessage()    {}
func (*RedisInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{21}
}
func (m *RedisInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedisInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedisInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedisInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedisInfo.Merge(m, src)
}
func (m *RedisInfo) XXX_Size() int {
	return m.Size()
}
func (m *RedisInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RedisInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RedisInfo proto.InternalMessageInfo

func (m *RedisInfo) GetRequest() []byte {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *RedisInfo) GetRequestType() []byte {
	if m != nil {
		return m.RequestType
	}
	return nil
}

func (m *RedisInfo) GetResponse() []byte {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *RedisInfo) GetStatus() []byte {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *RedisInfo) GetError() []byte {
	if m != nil {
		return m.Error
	}
	return nil
}

type MqttInfo struct {
	MqttType             string       `protobuf:"bytes,1,opt,name=mqtt_type,json=mqttType,proto3" json:"mqtt_type,omitempty"`
	ReqMsgSize           int32        `protobuf:"varint,2,opt,name=req_msg_size,json=reqMsgSize,proto3" json:"req_msg_size,omitempty"`
	ProtoVersion         uint32       `protobuf:"varint,3,opt,name=proto_version,json=protoVersion,proto3" json:"proto_version,omitempty"`
	ClientId             string       `protobuf:"bytes,4,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	RespMsgSize          int32        `protobuf:"varint,5,opt,name=resp_msg_size,json=respMsgSize,proto3" json:"resp_msg_size,omitempty"`
	Topics               []*MqttTopic `protobuf:"bytes,6,rep,name=topics,proto3" json:"topics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MqttInfo) Reset()         { *m = MqttInfo{} }
func (m *MqttInfo) String() string { return proto.CompactTextString(m) }
func (*MqttInfo) ProtoMessage()    {}
func (*MqttInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{22}
}
func (m *MqttInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MqttInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MqttInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MqttInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MqttInfo.Merge(m, src)
}
func (m *MqttInfo) XXX_Size() int {
	return m.Size()
}
func (m *MqttInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MqttInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MqttInfo proto.InternalMessageInfo

func (m *MqttInfo) GetMqttType() string {
	if m != nil {
		return m.MqttType
	}
	return ""
}

func (m *MqttInfo) GetReqMsgSize() int32 {
	if m != nil {
		return m.ReqMsgSize
	}
	return 0
}

func (m *MqttInfo) GetProtoVersion() uint32 {
	if m != nil {
		return m.ProtoVersion
	}
	return 0
}

func (m *MqttInfo) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *MqttInfo) GetRespMsgSize() int32 {
	if m != nil {
		return m.RespMsgSize
	}
	return 0
}

func (m *MqttInfo) GetTopics() []*MqttTopic {
	if m != nil {
		return m.Topics
	}
	return nil
}

type MqttTopic struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Qos                  int32    `protobuf:"varint,2,opt,name=qos,proto3" json:"qos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MqttTopic) Reset()         { *m = MqttTopic{} }
func (m *MqttTopic) String() string { return proto.CompactTextString(m) }
func (*MqttTopic) ProtoMessage()    {}
func (*MqttTopic) Descriptor() ([]byte, []int) {
	return fileDescriptor_776aad6e6f20da90, []int{23}
}
func (m *MqttTopic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MqttTopic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MqttTopic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MqttTopic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MqttTopic.Merge(m, src)
}
func (m *MqttTopic) XXX_Size() int {
	return m.Size()
}
func (m *MqttTopic) XXX_DiscardUnknown() {
	xxx_messageInfo_MqttTopic.DiscardUnknown(m)
}

var xxx_messageInfo_MqttTopic proto.InternalMessageInfo

func (m *MqttTopic) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MqttTopic) GetQos() int32 {
	if m != nil {
		return m.Qos
	}
	return 0
}

func init() {
	proto.RegisterType((*TaggedFlow)(nil), "flow_log.TaggedFlow")
	proto.RegisterType((*Flow)(nil), "flow_log.Flow")
	proto.RegisterType((*FlowKey)(nil), "flow_log.FlowKey")
	proto.RegisterType((*FlowMetricsPeer)(nil), "flow_log.FlowMetricsPeer")
	proto.RegisterType((*TunnelField)(nil), "flow_log.TunnelField")
	proto.RegisterType((*FlowPerfStats)(nil), "flow_log.FlowPerfStats")
	proto.RegisterType((*TCPPerfStats)(nil), "flow_log.TCPPerfStats")
	proto.RegisterType((*TcpPerfCountsPeer)(nil), "flow_log.TcpPerfCountsPeer")
	proto.RegisterType((*L7PerfStats)(nil), "flow_log.L7PerfStats")
	proto.RegisterType((*L7Request)(nil), "flow_log.L7Request")
	proto.RegisterType((*L7Response)(nil), "flow_log.L7Response")
	proto.RegisterType((*TraceInfo)(nil), "flow_log.TraceInfo")
	proto.RegisterType((*ExtendedInfo)(nil), "flow_log.ExtendedInfo")
	proto.RegisterType((*AppProtoLogsData)(nil), "flow_log.AppProtoLogsData")
	proto.RegisterType((*AppProtoLogsBaseInfo)(nil), "flow_log.AppProtoLogsBaseInfo")
	proto.RegisterType((*AppProtoHead)(nil), "flow_log.AppProtoHead")
	proto.RegisterType((*HttpInfo)(nil), "flow_log.HttpInfo")
	proto.RegisterType((*DnsInfo)(nil), "flow_log.DnsInfo")
	proto.RegisterType((*DubboInfo)(nil), "flow_log.DubboInfo")
	proto.RegisterType((*KafkaInfo)(nil), "flow_log.KafkaInfo")
	proto.RegisterType((*MysqlInfo)(nil), "flow_log.MysqlInfo")
	proto.RegisterType((*RedisInfo)(nil), "flow_log.RedisInfo")
	proto.RegisterType((*MqttInfo)(nil), "flow_log.MqttInfo")
	proto.RegisterType((*MqttTopic)(nil), "flow_log.MqttTopic")
}

func init() { proto.RegisterFile("flow_log.proto", fileDescriptor_776aad6e6f20da90) }

var fileDescriptor_776aad6e6f20da90 = []byte{
	// 3034 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x59, 0x4b, 0x6f, 0xdc, 0x56,
	0x96, 0x86, 0xea, 0x5d, 0xa7, 0x1e, 0x92, 0x68, 0xd9, 0xa6, 0xed, 0xc4, 0x76, 0x2a, 0x71, 0x46,
	0xc9, 0x38, 0x8e, 0x64, 0x1b, 0xf6, 0xcc, 0xd2, 0xaf, 0x8c, 0x0b, 0xb6, 0x03, 0x83, 0x12, 0x32,
	0x40, 0x16, 0x43, 0x5c, 0x91, 0x57, 0x2a, 0x42, 0x2c, 0x92, 0x75, 0xef, 0x2d, 0xa9, 0x2a, 0x98,
	0xf9, 0x13, 0xd9, 0xcf, 0x66, 0x7e, 0xc0, 0xac, 0x06, 0x83, 0xfe, 0x03, 0x0d, 0x74, 0xaf, 0xba,
	0xd1, 0xeb, 0x46, 0xa3, 0x91, 0x7d, 0xa3, 0xff, 0x42, 0xe3, 0x9c, 0x73, 0xc9, 0x22, 0xcb, 0x52,
	0xd2, 0xbd, 0xab, 0xfb, 0x9d, 0xef, 0x9e, 0xfb, 0x3a, 0x4f, 0x16, 0x0c, 0x8f, 0xe3, 0xf4, 0xdc,
	0x8f, 0xd3, 0x93, 0x07, 0x99, 0x4a, 0x4d, 0xea, 0x74, 0xf2, 0xf1, 0xcd, 0xaf, 0x4e, 0x22, 0x33,
	0x99, 0x1f, 0x3d, 0x08, 0xd2, 0xe9, 0xd7, 0x27, 0xe9, 0x49, 0xfa, 0x35, 0x11, 0x8e, 0xe6, 0xc7,
	0x34, 0xa2, 0x01, 0xfd, 0xe2, 0x89, 0xa3, 0x3d, 0x80, 0x43, 0x71, 0x72, 0x22, 0xc3, 0x6f, 0xe2,
	0xf4, 0xdc, 0x19, 0x41, 0x03, 0x15, 0xb9, 0x1b, 0x77, 0x37, 0x76, 0x7b, 0x0f, 0x87, 0x0f, 0x8a,
	0x55, 0x50, 0xea, 0x91, 0x6c, 0xf4, 0xa7, 0x16, 0x34, 0x88, 0x7c, 0x1f, 0x78, 0xd5, 0x53, 0xb9,
	0xb4, 0x13, 0xb6, 0xab, 0x13, 0xde, 0xc8, 0xa5, 0xd7, 0x3e, 0xe6, 0x1f, 0xce, 0x0b, 0xd8, 0x9a,
	0x4a, 0xa3, 0xa2, 0x40, 0xfb, 0x99, 0x94, 0xca, 0xd7, 0x2a, 0x70, 0x6b, 0x34, 0xeb, 0x46, 0x75,
	0xd6, 0x3b, 0x66, 0xbd, 0x97, 0x52, 0x79, 0xc3, 0xe9, 0x6a, 0x70, 0xa0, 0x82, 0x0f, 0x94, 0x84,
	0xda, 0xb8, 0xf5, 0x7f, 0x44, 0xc9, 0x4b, 0x6d, 0x9c, 0xaf, 0xa0, 0x75, 0x38, 0x4f, 0x12, 0x19,
	0xbb, 0x0d, 0x9a, 0x7a, 0x75, 0x35, 0x95, 0xf1, 0x6f, 0x22, 0x19, 0x87, 0x9e, 0x25, 0x39, 0xd7,
	0x81, 0xce, 0xe0, 0x47, 0xa1, 0xdb, 0xbc, 0xbb, 0xb1, 0xdb, 0xf0, 0x5a, 0x38, 0x1c, 0x87, 0xce,
	0xc7, 0x00, 0xda, 0x08, 0x65, 0x7c, 0x13, 0x4d, 0xa5, 0xdb, 0x22, 0x59, 0x97, 0x90, 0xc3, 0x68,
	0x2a, 0x9d, 0x1b, 0xd0, 0x91, 0x49, 0xc8, 0xc2, 0x36, 0x09, 0xdb, 0x32, 0x09, 0x49, 0x74, 0x13,
	0x3a, 0xe1, 0x5c, 0x09, 0x13, 0xa5, 0x89, 0xdb, 0x21, 0x51, 0x31, 0x76, 0x1c, 0x68, 0x9c, 0xc5,
	0x22, 0x71, 0xe1, 0xee, 0xc6, 0xee, 0xc0, 0xa3, 0xdf, 0xa4, 0xca, 0x4c, 0x7c, 0xb3, 0xcc, 0xa4,
	0xdb, 0x23, 0xbc, 0x2d, 0xcd, 0xe4, 0x70, 0x99, 0x49, 0xe7, 0x33, 0x18, 0x4e, 0x04, 0xde, 0x86,
	0x3a, 0xf6, 0xb5, 0x11, 0x46, 0xbb, 0x7d, 0x22, 0xf4, 0x27, 0x42, 0xbf, 0x97, 0xea, 0xf8, 0x00,
	0x31, 0xe7, 0x09, 0x40, 0x89, 0x31, 0xa0, 0x63, 0x5f, 0xaf, 0xde, 0x58, 0x41, 0xf6, 0xba, 0x59,
	0x31, 0xef, 0x63, 0x80, 0x20, 0x4e, 0xb5, 0xe4, 0xa5, 0x87, 0xa4, 0xb9, 0x4b, 0x08, 0x2d, 0x7e,
	0x07, 0x7a, 0xa4, 0x43, 0xa7, 0x73, 0x15, 0x48, 0x77, 0x93, 0xe4, 0x80, 0xd0, 0x01, 0x21, 0xce,
	0x97, 0xb0, 0x1d, 0x69, 0x5f, 0x04, 0x26, 0x3a, 0x93, 0xbe, 0x96, 0xea, 0x2c, 0x0a, 0xa4, 0xbb,
	0x45, 0xb4, 0xcd, 0x48, 0x3f, 0x23, 0xfc, 0x80, 0x61, 0x5c, 0x6b, 0x36, 0x97, 0x73, 0xe9, 0x4f,
	0x84, 0x9e, 0xb8, 0xdb, 0xbc, 0x16, 0x21, 0xaf, 0x85, 0x9e, 0x38, 0xb7, 0xa1, 0x17, 0x69, 0x3f,
	0x91, 0xe7, 0x3e, 0x59, 0xa8, 0xc3, 0xf2, 0x48, 0x7f, 0x2b, 0xcf, 0xc9, 0x1a, 0x6f, 0x40, 0xc7,
	0x88, 0xcc, 0xd7, 0x51, 0x28, 0xdd, 0x2b, 0x7c, 0x47, 0x46, 0x64, 0x07, 0x51, 0x28, 0xf1, 0x05,
	0xf5, 0x32, 0xf1, 0xb5, 0x9c, 0xb9, 0x3b, 0x24, 0x69, 0xe9, 0x65, 0x72, 0x20, 0x67, 0xf4, 0x82,
	0xcb, 0x44, 0x04, 0xa7, 0x24, 0xbb, 0xca, 0x2a, 0x19, 0x41, 0xf1, 0x7d, 0x70, 0x62, 0xa1, 0x8d,
	0x7f, 0x2a, 0x65, 0x26, 0x62, 0x3e, 0xc2, 0xcc, 0xbd, 0x46, 0xb4, 0x2d, 0x94, 0xbc, 0xc9, 0x05,
	0x17, 0xb3, 0x45, 0x70, 0xea, 0x5e, 0xbf, 0x80, 0xfd, 0x2c, 0x38, 0xc5, 0xed, 0x8a, 0x20, 0xf6,
	0x4f, 0xa2, 0x50, 0xbb, 0xee, 0xdd, 0x3a, 0x6e, 0x57, 0x04, 0xf1, 0xbf, 0x45, 0xa1, 0x1e, 0xfd,
	0x7f, 0x0d, 0xda, 0xd6, 0x7d, 0x70, 0xeb, 0x67, 0x78, 0xac, 0x28, 0x24, 0x17, 0x1b, 0x78, 0x2d,
	0x1c, 0x8e, 0xc3, 0xfc, 0xb8, 0xf4, 0x2e, 0xb5, 0xe2, 0xb8, 0xf4, 0x2a, 0x56, 0x94, 0xa5, 0x8a,
	0x9d, 0xa3, 0x41, 0xa2, 0xf7, 0xa9, 0x32, 0xa8, 0x6e, 0x2a, 0x02, 0xf2, 0xbd, 0x06, 0xdb, 0xf2,
	0x54, 0x04, 0xe8, 0x58, 0x56, 0x80, 0xfe, 0xd4, 0x2c, 0x04, 0xe8, 0x2c, 0x57, 0xa1, 0x15, 0x65,
	0x34, 0xa1, 0x45, 0xab, 0x34, 0xa3, 0x0c, 0xf9, 0x0c, 0x23, 0xbd, 0x9d, 0xc3, 0xc8, 0xbe, 0x0e,
	0xed, 0x28, 0x7b, 0x42, 0x74, 0xb4, 0xeb, 0xbe, 0xd7, 0x8a, 0xb2, 0x27, 0x56, 0x3f, 0x0a, 0x70,
	0x42, 0xb7, 0x10, 0xe0, 0x8c, 0x1b, 0xd0, 0xc1, 0x8d, 0xd2, 0x14, 0x36, 0xf9, 0x36, 0x8e, 0x71,
	0x4e, 0x2e, 0xc2, 0x49, 0xbd, 0x95, 0x08, 0x67, 0xed, 0x40, 0x93, 0xc2, 0x97, 0x35, 0x76, 0x1e,
	0x8c, 0x7e, 0x6c, 0xc0, 0xe6, 0x9a, 0xf3, 0xe3, 0x13, 0x1f, 0x2d, 0x8d, 0xf4, 0x83, 0x74, 0x9e,
	0x18, 0xba, 0xc3, 0x86, 0xd7, 0x45, 0xe4, 0x05, 0x02, 0xce, 0x08, 0x06, 0xf1, 0x23, 0xbf, 0xc4,
	0xa8, 0x11, 0xa3, 0x17, 0x3f, 0x7a, 0x5e, 0xe1, 0x3c, 0x2e, 0x73, 0xea, 0x96, 0xf3, 0x78, 0xc5,
	0xf9, 0x04, 0xfa, 0x99, 0x08, 0x4e, 0xa5, 0xb1, 0x14, 0xbe, 0xdd, 0x1e, 0x63, 0x4c, 0xd9, 0x85,
	0x2d, 0x93, 0x1a, 0x11, 0x97, 0x35, 0xf1, 0x5d, 0x0f, 0x09, 0x5f, 0x29, 0xbb, 0x0f, 0x0e, 0x33,
	0x2b, 0x2a, 0x39, 0xc0, 0xb0, 0x8e, 0xf7, 0x25, 0xbd, 0x3b, 0xd0, 0x3c, 0x8e, 0x94, 0x7d, 0x89,
	0x86, 0xc7, 0x03, 0x0c, 0x23, 0x68, 0x73, 0x36, 0xbc, 0xd0, 0x6f, 0xe7, 0x16, 0x74, 0x4d, 0x90,
	0xf9, 0xc7, 0xb1, 0x38, 0xd1, 0xf4, 0x0c, 0x03, 0xaf, 0x63, 0x82, 0xec, 0x1b, 0x1c, 0x3b, 0x37,
	0xa1, 0x1b, 0x3f, 0xf2, 0x65, 0x16, 0xa0, 0xad, 0xe1, 0x4b, 0x34, 0xbd, 0x76, 0xfc, 0xe8, 0x55,
	0x16, 0x8c, 0x43, 0x94, 0x45, 0xda, 0x8f, 0x1f, 0xfa, 0x32, 0x09, 0xf3, 0xa7, 0x88, 0xf4, 0xdb,
	0x87, 0xaf, 0x92, 0x42, 0xf6, 0x88, 0x64, 0xfd, 0x42, 0xf6, 0x08, 0x65, 0x9f, 0xc1, 0x70, 0xe5,
	0xfe, 0x93, 0x54, 0x1b, 0x0a, 0x3d, 0x03, 0xaf, 0x9f, 0xfb, 0xfe, 0xeb, 0x94, 0xb7, 0x15, 0x69,
	0x3f, 0x94, 0x14, 0x1c, 0x38, 0xc6, 0x74, 0x22, 0xfd, 0x92, 0xc6, 0x78, 0x6b, 0x91, 0xf6, 0xcf,
	0xa2, 0xcc, 0x8f, 0x12, 0x23, 0xd5, 0xb1, 0x28, 0xe2, 0xcc, 0x30, 0xd2, 0xdf, 0x45, 0xd9, 0x38,
	0x47, 0xc9, 0x24, 0x89, 0x69, 0x03, 0x4c, 0x93, 0xe4, 0xa3, 0x5f, 0xd7, 0xa0, 0x57, 0x0a, 0xeb,
	0x48, 0x33, 0x0b, 0x3f, 0xca, 0xf6, 0xac, 0x43, 0x35, 0xcd, 0x62, 0x9c, 0xed, 0x15, 0xf0, 0xbe,
	0xf5, 0x26, 0x82, 0xf7, 0x11, 0x56, 0xcc, 0xae, 0x33, 0xac, 0x72, 0xb6, 0x62, 0x76, 0x63, 0x05,
	0xef, 0xa3, 0x95, 0x9b, 0x85, 0x3f, 0x15, 0xc1, 0x1e, 0xbd, 0xec, 0xc0, 0x6b, 0x99, 0xc5, 0x3b,
	0x11, 0xec, 0xad, 0x04, 0xfb, 0xd6, 0x8d, 0x58, 0x40, 0x33, 0x94, 0x9d, 0xc1, 0x8e, 0xd4, 0x52,
	0xc5, 0x0c, 0x65, 0x67, 0x74, 0x4a, 0x82, 0x7d, 0xe7, 0x0a, 0x34, 0x71, 0xa3, 0xa1, 0x7d, 0xc0,
	0x86, 0x59, 0x8c, 0x43, 0x04, 0xd5, 0x22, 0x7f, 0xb8, 0x81, 0xd7, 0x50, 0x08, 0xde, 0x81, 0x9e,
	0xa1, 0x83, 0x97, 0x13, 0x07, 0x30, 0x44, 0x81, 0xc2, 0x81, 0x86, 0x89, 0xa4, 0xb2, 0xaf, 0x46,
	0xbf, 0xc9, 0x51, 0xb5, 0x1f, 0x65, 0x67, 0x4f, 0xec, 0x5b, 0xb5, 0x22, 0x3d, 0xce, 0xce, 0x9e,
	0x8c, 0xfe, 0x67, 0x03, 0x06, 0x95, 0x3c, 0xe1, 0xec, 0x42, 0xdd, 0x04, 0x99, 0x4d, 0xfd, 0xd7,
	0x4a, 0x49, 0xf4, 0xc5, 0xfb, 0x55, 0x32, 0x41, 0x8a, 0x73, 0x0f, 0x6a, 0xf1, 0x53, 0x9b, 0xed,
	0x4b, 0xd9, 0xf6, 0xed, 0xd3, 0x15, 0xaf, 0x16, 0x3f, 0xc5, 0x0d, 0xc7, 0x8f, 0x7d, 0xf2, 0xe5,
	0x20, 0x8d, 0xed, 0x8d, 0x43, 0xfc, 0xf8, 0xbd, 0x45, 0x88, 0xf0, 0x74, 0x45, 0x68, 0x58, 0xc2,
	0xd3, 0x9c, 0x30, 0xfa, 0x6b, 0x13, 0xfa, 0xe5, 0xe5, 0xd1, 0x02, 0x95, 0x31, 0x7e, 0x10, 0x47,
	0x32, 0x31, 0xfe, 0x54, 0x2c, 0xec, 0xab, 0xf7, 0x95, 0x31, 0x2f, 0x08, 0x7c, 0x27, 0x16, 0x39,
	0x0b, 0x13, 0x94, 0x54, 0xc4, 0xaa, 0x15, 0xac, 0x03, 0x02, 0x91, 0x85, 0x69, 0x44, 0xb1, 0x92,
	0xba, 0x4d, 0x23, 0xca, 0x58, 0x81, 0xb0, 0x02, 0xde, 0x52, 0x4b, 0xb0, 0x60, 0x0b, 0xea, 0xca,
	0x18, 0x6b, 0x0b, 0xf8, 0x73, 0x6d, 0x3f, 0x7a, 0x3e, 0xb5, 0xf6, 0xb0, 0xda, 0xcf, 0xc1, 0x7c,
	0xba, 0xb6, 0x1f, 0x64, 0xb5, 0xd7, 0xf6, 0x83, 0x2c, 0xbb, 0x1f, 0x14, 0x77, 0x8a, 0xfd, 0x58,
	0x81, 0xb0, 0x82, 0x6e, 0xb1, 0x1f, 0x14, 0xec, 0xc2, 0x56, 0x69, 0x75, 0x0e, 0x2b, 0x6c, 0x31,
	0xc3, 0x62, 0xfd, 0x22, 0x58, 0x95, 0x76, 0xc0, 0xcc, 0x5e, 0xc1, 0xe4, 0x3d, 0x30, 0xf3, 0x16,
	0x74, 0x71, 0x17, 0x4c, 0x61, 0x4b, 0xea, 0x68, 0x65, 0x0a, 0xa1, 0x28, 0x84, 0x6c, 0x4f, 0x1d,
	0x91, 0x0b, 0x9f, 0xc1, 0x90, 0x04, 0xb6, 0x96, 0x33, 0x0b, 0x72, 0xfe, 0xde, 0xc3, 0x5b, 0x25,
	0x53, 0x0a, 0x32, 0x7c, 0x4b, 0xe2, 0x73, 0x31, 0xd7, 0x0f, 0x8a, 0xdf, 0x87, 0x8b, 0x75, 0x15,
	0x6a, 0x41, 0xb1, 0xe1, 0xef, 0x57, 0xe1, 0x2d, 0x9c, 0x07, 0x70, 0x85, 0x83, 0xad, 0x92, 0x46,
	0x89, 0x44, 0xdb, 0xcd, 0x72, 0x0c, 0xd9, 0x26, 0x91, 0xc7, 0x92, 0xd5, 0x79, 0x97, 0x89, 0x65,
	0x6d, 0xdb, 0xf3, 0x2e, 0x93, 0x22, 0x0d, 0xd8, 0x82, 0x82, 0xe5, 0x5c, 0xa5, 0xf4, 0x18, 0x63,
	0xca, 0x75, 0x68, 0x07, 0x11, 0x1b, 0x0b, 0x97, 0x29, 0xad, 0x20, 0xca, 0xad, 0x08, 0x05, 0xf8,
	0x6a, 0x3b, 0x85, 0x00, 0x5f, 0xed, 0x16, 0x74, 0x51, 0xc0, 0x1a, 0xb9, 0x48, 0xe9, 0x04, 0x11,
	0x5f, 0xe2, 0xe8, 0x3f, 0x60, 0xfb, 0x83, 0x13, 0x3a, 0x9f, 0xc2, 0xa0, 0x7a, 0x9a, 0xdc, 0xe8,
	0xcb, 0x07, 0xf9, 0x0c, 0x86, 0x3f, 0x48, 0x95, 0xfa, 0xe7, 0x51, 0x52, 0xca, 0x7d, 0x03, 0xaf,
	0x8f, 0xe8, 0xbf, 0x47, 0x7c, 0xa2, 0xd1, 0x7f, 0xd7, 0xa0, 0x57, 0xf2, 0x53, 0x56, 0x3d, 0x9b,
	0x4b, 0x6d, 0xd6, 0x55, 0x13, 0xc8, 0xaa, 0xef, 0xc1, 0x50, 0x49, 0x9d, 0xa5, 0x89, 0x96, 0x15,
	0xd5, 0x83, 0x1c, 0x2d, 0x8c, 0x4c, 0x2a, 0x55, 0x35, 0x47, 0xf6, 0xac, 0xa1, 0x54, 0x6a, 0xcd,
	0x1c, 0x91, 0x59, 0x31, 0xc7, 0x46, 0xc1, 0x2c, 0x9b, 0xe3, 0x1d, 0xe8, 0x21, 0x13, 0xab, 0xee,
	0x74, 0x9e, 0xbb, 0x1e, 0x48, 0xa5, 0x0e, 0x19, 0xc1, 0xdb, 0x54, 0xaa, 0x9c, 0x53, 0x07, 0x5e,
	0x47, 0xe5, 0x26, 0x89, 0x51, 0xd7, 0x7a, 0x0e, 0x67, 0xd3, 0x96, 0x2a, 0x5c, 0x4a, 0x59, 0x17,
	0xcf, 0xc3, 0x31, 0xb9, 0xf8, 0xe8, 0x7b, 0xe8, 0xbe, 0x7d, 0xea, 0xf1, 0xe1, 0xb1, 0x62, 0x51,
	0x72, 0xc6, 0xe1, 0x16, 0xef, 0xa5, 0xeb, 0xb5, 0x95, 0x9c, 0x51, 0xac, 0xbd, 0x06, 0xad, 0x30,
	0x9d, 0x8a, 0x28, 0xa1, 0xab, 0xe8, 0x7a, 0x76, 0x84, 0xad, 0x80, 0x92, 0xb6, 0x7e, 0xae, 0x93,
	0xa4, 0x18, 0x8f, 0x12, 0x00, 0xd4, 0xcd, 0x57, 0x86, 0x1a, 0xb0, 0x7c, 0x9f, 0xeb, 0xbc, 0x12,
	0xe4, 0x11, 0x46, 0xf1, 0x20, 0x0d, 0xb9, 0x0a, 0x6c, 0x7a, 0xf4, 0xdb, 0xf9, 0x08, 0xba, 0x72,
	0x11, 0xc8, 0x8c, 0x3a, 0x0c, 0x56, 0xbb, 0x02, 0x50, 0x93, 0x92, 0x7a, 0x1e, 0xf3, 0x1d, 0x76,
	0x3d, 0x3b, 0x1a, 0x49, 0xe8, 0x1e, 0x2a, 0x11, 0xc8, 0x71, 0x72, 0x9c, 0x52, 0x15, 0x89, 0x83,
	0xbc, 0xf4, 0xec, 0x7a, 0x6d, 0x1a, 0x8f, 0x43, 0x0a, 0x3c, 0x99, 0x48, 0x50, 0x62, 0x0f, 0x83,
	0xc3, 0x31, 0xe5, 0xfb, 0x4c, 0x28, 0x8a, 0x6c, 0x56, 0xce, 0x6b, 0xf7, 0x19, 0x3d, 0x20, 0xd6,
	0xe8, 0x7f, 0x37, 0xa0, 0xff, 0x6a, 0x61, 0x64, 0x12, 0xca, 0x90, 0x96, 0x42, 0xaf, 0xe1, 0x26,
	0xc0, 0x4f, 0xc4, 0x34, 0xbf, 0xba, 0x9e, 0xc5, 0xbe, 0x15, 0x53, 0x49, 0x3e, 0xc0, 0x66, 0x12,
	0x65, 0x76, 0xd1, 0x0e, 0x03, 0xe3, 0x0c, 0x6b, 0xbc, 0xdc, 0x26, 0xed, 0x92, 0x03, 0xaf, 0x6b,
	0x91, 0x71, 0xe8, 0xdc, 0x85, 0xfe, 0xc2, 0x2f, 0x11, 0xf8, 0xd0, 0xb0, 0xf0, 0x0a, 0x06, 0x2a,
	0x48, 0xcf, 0x7d, 0x79, 0x7c, 0x2c, 0x83, 0xdc, 0x66, 0xba, 0x2a, 0x3d, 0x7f, 0x45, 0xc0, 0xe8,
	0x2f, 0x0d, 0xd8, 0x7a, 0x96, 0x65, 0x94, 0x65, 0xde, 0xa6, 0x27, 0xfa, 0xa5, 0x30, 0xc2, 0x79,
	0x08, 0x8d, 0x23, 0xa1, 0xa5, 0x4d, 0x7f, 0xb7, 0x57, 0x01, 0xa7, 0xcc, 0x7c, 0x2e, 0x34, 0xdd,
	0xa6, 0x47, 0x5c, 0xe7, 0x73, 0x68, 0x4c, 0x8c, 0xc9, 0x6c, 0x26, 0x74, 0x56, 0x73, 0x5e, 0x1b,
	0x93, 0x31, 0x0f, 0xe5, 0xce, 0xa7, 0x50, 0x0f, 0x13, 0x6d, 0x3b, 0xdb, 0x52, 0x53, 0xfd, 0x32,
	0xd1, 0xc4, 0x42, 0xa9, 0xf3, 0x05, 0x34, 0xc3, 0xf9, 0xd1, 0x51, 0x6a, 0xbb, 0xd8, 0x2b, 0x25,
	0x1a, 0xc2, 0x44, 0x64, 0x06, 0x52, 0x4f, 0xc5, 0xf1, 0xa9, 0xa0, 0xa3, 0x55, 0xa8, 0x6f, 0x10,
	0x66, 0x2a, 0x31, 0x90, 0x3a, 0x5d, 0xea, 0x59, 0x4c, 0xae, 0x51, 0xa1, 0xbe, 0x43, 0x98, 0xa9,
	0xc4, 0x40, 0xaa, 0x92, 0x61, 0xa4, 0xc9, 0x55, 0x2a, 0x54, 0x0f, 0x61, 0xa6, 0x12, 0x03, 0x0f,
	0x3e, 0x9d, 0x19, 0xae, 0x46, 0x2b, 0x07, 0x7f, 0x37, 0x33, 0x86, 0x0f, 0x8e, 0x72, 0x72, 0x33,
	0x39, 0xf3, 0x63, 0x99, 0x50, 0xe6, 0x6a, 0xa2, 0x69, 0xce, 0xde, 0xca, 0x84, 0x3d, 0x4b, 0x67,
	0x24, 0xb1, 0xc5, 0x29, 0x8e, 0x51, 0x74, 0x0f, 0xea, 0x4a, 0xce, 0x28, 0x3b, 0x55, 0x36, 0x51,
	0xb8, 0xa5, 0x87, 0x72, 0x67, 0x17, 0x1a, 0x38, 0x83, 0x52, 0x54, 0xef, 0xe1, 0x4e, 0x95, 0xc7,
	0x2e, 0xe6, 0x11, 0xc3, 0x71, 0xa1, 0x7d, 0x26, 0x95, 0x46, 0xd7, 0x19, 0xb0, 0xe1, 0xdb, 0xa1,
	0xf3, 0x10, 0xc0, 0xfa, 0x44, 0x72, 0x9c, 0xda, 0x6c, 0x55, 0x5a, 0xb1, 0x70, 0x1e, 0xaf, 0x6b,
	0x0a, 0x3f, 0xda, 0x87, 0x8e, 0x5c, 0x18, 0x9e, 0xb1, 0xb9, 0x5e, 0x2a, 0x95, 0xdd, 0xc0, 0x6b,
	0xcb, 0x05, 0xdd, 0xc5, 0xe8, 0x57, 0x5d, 0xd8, 0xb9, 0xc8, 0x8a, 0xd6, 0xbe, 0x38, 0x6c, 0xfc,
	0xdc, 0x17, 0x87, 0x5a, 0xf5, 0x8b, 0x43, 0xe9, 0x23, 0x46, 0xbd, 0xf2, 0x11, 0xa3, 0xdc, 0x2c,
	0x36, 0x3e, 0x68, 0x16, 0xf3, 0xde, 0xb3, 0x79, 0x69, 0xef, 0xd9, 0xaa, 0xf6, 0x9e, 0xa5, 0xf2,
	0xb1, 0x5d, 0x2e, 0x1f, 0x2b, 0xed, 0x79, 0xa7, 0xda, 0x9e, 0x7f, 0x09, 0x8d, 0x89, 0x14, 0x5c,
	0xd0, 0x56, 0x6e, 0x27, 0xbf, 0x83, 0xd7, 0x52, 0x84, 0x1e, 0x71, 0xca, 0x0d, 0x2c, 0x5c, 0xd6,
	0xc0, 0xf6, 0x2e, 0x69, 0x60, 0xfb, 0x17, 0x37, 0xb0, 0x83, 0x4b, 0x1a, 0xd8, 0xe1, 0x65, 0x0d,
	0xec, 0x66, 0xa5, 0x81, 0xfd, 0x84, 0x3a, 0x48, 0xee, 0x9b, 0x68, 0xde, 0x16, 0x99, 0x27, 0xd8,
	0xde, 0x09, 0xe7, 0x56, 0x28, 0xa8, 0x61, 0xbb, 0x42, 0x59, 0x6f, 0x83, 0x9d, 0xcb, 0xdb, 0xe0,
	0x2b, 0xd5, 0x36, 0xf8, 0x26, 0x74, 0x8a, 0x62, 0x98, 0x6b, 0x86, 0x62, 0xec, 0x7c, 0x0d, 0x3b,
	0xeb, 0x8d, 0x13, 0x69, 0xe7, 0x02, 0x62, 0xbb, 0xda, 0x3c, 0xe1, 0x3a, 0x17, 0x4d, 0xc0, 0x35,
	0xaf, 0x5d, 0x34, 0x01, 0x57, 0xbf, 0x0d, 0x3d, 0xca, 0x76, 0x41, 0x46, 0xdf, 0x45, 0xae, 0x17,
	0x71, 0xf7, 0x30, 0xc8, 0x0e, 0xe4, 0x0c, 0xe3, 0x2e, 0xf9, 0x6c, 0x4e, 0x70, 0x39, 0x17, 0x23,
	0xb6, 0x62, 0x64, 0x2a, 0x0d, 0xa4, 0xd6, 0x78, 0x33, 0x7b, 0xee, 0x0d, 0x66, 0x58, 0x6c, 0x1c,
	0xee, 0xad, 0x31, 0xf6, 0xdd, 0x9b, 0x6b, 0x8c, 0x7d, 0xe7, 0x73, 0xd8, 0xcc, 0x19, 0xa7, 0x98,
	0x3d, 0xfc, 0x3d, 0xf7, 0x16, 0x79, 0xed, 0xc0, 0xc2, 0x6f, 0x10, 0xdd, 0xfb, 0x90, 0xb7, 0xef,
	0x7e, 0xf4, 0x21, 0x6f, 0xdf, 0x79, 0x0a, 0xae, 0x5e, 0xea, 0x40, 0xc4, 0xb1, 0x9f, 0xe7, 0xbf,
	0x3c, 0x79, 0xb8, 0x1f, 0x93, 0x65, 0x5d, 0xb5, 0x72, 0x76, 0xf7, 0x30, 0x4f, 0xfe, 0xff, 0x0a,
	0x37, 0x2e, 0x98, 0xc8, 0x91, 0xc5, 0xbd, 0x4d, 0x33, 0xaf, 0xad, 0xcf, 0xb4, 0xa9, 0xfd, 0x5f,
	0x2e, 0x98, 0x6a, 0x26, 0x4a, 0x0a, 0xbc, 0x94, 0x3b, 0x74, 0xe4, 0xb5, 0x45, 0x0f, 0x49, 0xba,
	0xf7, 0x73, 0x33, 0xf7, 0xdd, 0xbb, 0x97, 0xcf, 0xdc, 0x77, 0xbe, 0x80, 0xed, 0x7c, 0x66, 0x20,
	0xe8, 0x81, 0xfc, 0x3d, 0xf7, 0x13, 0xae, 0xa9, 0xac, 0xe0, 0x85, 0xc0, 0x57, 0xda, 0xbb, 0x88,
	0xba, 0xef, 0x8e, 0x2e, 0xa0, 0xee, 0x8f, 0xfe, 0x0b, 0xfa, 0x65, 0xaf, 0x5d, 0x7d, 0xa8, 0xd9,
	0x28, 0x7d, 0xa8, 0x41, 0x93, 0x9e, 0xea, 0x93, 0xca, 0xc7, 0xab, 0xa9, 0x3e, 0xc9, 0xeb, 0x24,
	0x5b, 0xe5, 0xd4, 0x2f, 0xac, 0x72, 0xb8, 0xea, 0xe3, 0x2a, 0x07, 0xdb, 0x2b, 0x95, 0x7f, 0x44,
	0xc1, 0x9f, 0xa3, 0x3f, 0xd4, 0xa0, 0x93, 0xe7, 0x52, 0xaa, 0xd4, 0x8d, 0x92, 0x62, 0xba, 0xfa,
	0x7a, 0xd6, 0x61, 0x60, 0x1c, 0x96, 0x83, 0x7c, 0xbd, 0x1a, 0xe4, 0xaf, 0x41, 0x6b, 0x2a, 0xcd,
	0x24, 0xcd, 0x0b, 0x05, 0x3b, 0xc2, 0x1d, 0x64, 0xc2, 0x4c, 0x68, 0xb9, 0xae, 0x47, 0xbf, 0x11,
	0xa3, 0xcf, 0x1a, 0x2d, 0xc6, 0x26, 0xf6, 0x73, 0xc6, 0xaa, 0x54, 0x69, 0xaf, 0x95, 0x2a, 0xe5,
	0xaa, 0xaa, 0x73, 0x69, 0x55, 0xd5, 0xad, 0x54, 0x55, 0xf7, 0xc1, 0x41, 0x3f, 0x0b, 0xd2, 0xc4,
	0xa0, 0xd6, 0x58, 0x26, 0x27, 0x66, 0x42, 0xe1, 0xaf, 0xee, 0x6d, 0x29, 0x39, 0x7b, 0xc1, 0x82,
	0xb7, 0x84, 0x63, 0x3f, 0x43, 0x5e, 0xb7, 0x46, 0xef, 0x11, 0x7d, 0x1b, 0x45, 0x55, 0xfe, 0x7a,
	0x75, 0xd4, 0x5f, 0xaf, 0x8e, 0x46, 0xff, 0x09, 0x6d, 0x5b, 0x78, 0xd8, 0xed, 0x27, 0x7a, 0x75,
	0xa3, 0x6d, 0x1a, 0x73, 0x0d, 0x35, 0x9b, 0x4b, 0xb5, 0x2c, 0xbf, 0x6a, 0x97, 0x10, 0x7a, 0xd7,
	0x42, 0x4c, 0x15, 0x9e, 0x2d, 0x49, 0x09, 0xa1, 0xfa, 0xce, 0x85, 0xb6, 0x48, 0xf4, 0xb9, 0x54,
	0xda, 0xde, 0x7a, 0x3e, 0x1c, 0xfd, 0x5f, 0x0d, 0xba, 0x45, 0x41, 0x43, 0x6f, 0x2a, 0x55, 0x24,
	0xe2, 0xf2, 0x9b, 0x12, 0x30, 0xa6, 0x17, 0x2a, 0x2d, 0x4e, 0xbf, 0x9d, 0x21, 0xd4, 0x6c, 0xc9,
	0x37, 0xf0, 0x6a, 0x51, 0xe5, 0xdd, 0x9b, 0xd5, 0x77, 0x5f, 0xaf, 0x42, 0x5b, 0x1f, 0x56, 0xa1,
	0xff, 0x04, 0x9b, 0x39, 0x25, 0x57, 0xc2, 0x0f, 0x3c, 0xb4, 0xf0, 0x77, 0x56, 0xd7, 0x1d, 0xe8,
	0xb1, 0xd5, 0xb0, 0x2a, 0x7e, 0x69, 0x60, 0x88, 0x34, 0x51, 0x6c, 0x9c, 0xf9, 0x47, 0x69, 0xb8,
	0x2c, 0x55, 0x3b, 0x58, 0xc6, 0x3e, 0x4f, 0xc3, 0x25, 0x96, 0x35, 0x23, 0xa0, 0x6e, 0x69, 0x45,
	0xe1, 0xb2, 0xa7, 0x87, 0x60, 0xce, 0x29, 0x5b, 0x53, 0xaf, 0x62, 0x4d, 0xa3, 0xdf, 0x6d, 0x40,
	0xb7, 0x28, 0xee, 0xb0, 0x21, 0x0b, 0x52, 0xa5, 0x64, 0x4c, 0xff, 0x31, 0xac, 0xee, 0x6e, 0x50,
	0x42, 0xb9, 0x52, 0xc6, 0x5d, 0xa1, 0x6f, 0xea, 0xe8, 0x87, 0xbc, 0xa5, 0xc0, 0x5d, 0xbd, 0xd3,
	0x27, 0x07, 0xd1, 0x0f, 0xf4, 0xc5, 0x5f, 0x64, 0x91, 0x5f, 0x76, 0x9d, 0x81, 0x07, 0x22, 0x8b,
	0xf2, 0x93, 0x5f, 0x87, 0x36, 0x12, 0x4e, 0xe5, 0xb2, 0xf8, 0x16, 0x92, 0x45, 0x6f, 0xe4, 0xb2,
	0xec, 0x16, 0xa1, 0xbd, 0xfa, 0xdc, 0x2d, 0xc2, 0xe2, 0xb0, 0xc5, 0xca, 0xad, 0xd5, 0x61, 0xed,
	0xd2, 0xa3, 0xdf, 0xd6, 0xa0, 0x5b, 0xd4, 0xa0, 0xce, 0x17, 0xb0, 0x95, 0xa7, 0xba, 0x62, 0x37,
	0x7c, 0xa6, 0xcd, 0x1c, 0xcf, 0xb7, 0x74, 0x0f, 0x86, 0xb6, 0x71, 0xcc, 0x89, 0xdc, 0x40, 0x0c,
	0x18, 0xcd, 0x69, 0xbb, 0xb0, 0x65, 0x69, 0x36, 0x80, 0x16, 0xbd, 0x84, 0x9d, 0xce, 0x91, 0x93,
	0x63, 0x47, 0x90, 0x4e, 0xa7, 0x22, 0xc9, 0x0d, 0x2b, 0x1f, 0xb2, 0x24, 0x31, 0x72, 0x61, 0x72,
	0xeb, 0xb2, 0x43, 0xee, 0x9b, 0x8b, 0x96, 0x38, 0x94, 0xc5, 0x77, 0x9f, 0xa2, 0x23, 0x0e, 0x25,
	0x92, 0x04, 0xb5, 0x1c, 0x32, 0xf4, 0x55, 0x7a, 0xae, 0x6d, 0x13, 0xda, 0xcf, 0x41, 0x2f, 0x3d,
	0xa7, 0xff, 0x64, 0xa4, 0x52, 0xa9, 0x62, 0x35, 0x5c, 0x4b, 0x75, 0x09, 0xc9, 0x75, 0xb0, 0x78,
	0x2a, 0xb5, 0x16, 0x27, 0xd2, 0x06, 0x93, 0x3e, 0x81, 0xef, 0x18, 0x1b, 0xfd, 0xb8, 0x01, 0xdd,
	0xa2, 0x48, 0xc7, 0x5d, 0xe7, 0x19, 0x6e, 0x83, 0x6a, 0x9b, 0x7c, 0x88, 0x3e, 0x91, 0x87, 0x86,
	0xc2, 0xb3, 0xfa, 0xf8, 0x2c, 0x84, 0x91, 0x63, 0x73, 0x03, 0xcb, 0x59, 0xae, 0x4e, 0xe2, 0x62,
	0x5c, 0x0a, 0xe6, 0x0d, 0xae, 0x99, 0x6c, 0x30, 0xdf, 0x81, 0x26, 0x6d, 0x87, 0x2e, 0xa9, 0xef,
	0xf1, 0x60, 0xf4, 0xc7, 0x0d, 0xe8, 0xe4, 0xfd, 0x00, 0x9a, 0x0b, 0x76, 0x04, 0xe5, 0x5e, 0xba,
	0x83, 0x00, 0xad, 0xf9, 0xcb, 0x76, 0xfa, 0x29, 0x0c, 0xc8, 0x0c, 0xd6, 0x2c, 0xb5, 0x4f, 0x60,
	0xfe, 0xe2, 0x15, 0x93, 0x6c, 0xfc, 0x92, 0x49, 0x36, 0x3f, 0x30, 0x49, 0xe7, 0x9f, 0xa1, 0x65,
	0xd2, 0x2c, 0x0a, 0xb4, 0xdb, 0xba, 0x5b, 0x5f, 0xeb, 0x96, 0x70, 0xaf, 0x28, 0xf3, 0x2c, 0x65,
	0xb4, 0x0f, 0xdd, 0x02, 0xc4, 0x50, 0x55, 0x6a, 0x75, 0xe9, 0x37, 0xa6, 0xb3, 0x59, 0xaa, 0xed,
	0x61, 0xf0, 0xe7, 0xf3, 0xad, 0xdf, 0xfc, 0x74, 0x7b, 0xe3, 0xf7, 0x3f, 0xdd, 0xde, 0xf8, 0xf3,
	0x4f, 0xb7, 0x37, 0xbe, 0xaf, 0x65, 0x47, 0x47, 0x2d, 0x3a, 0xc0, 0xa3, 0xbf, 0x05, 0x00, 0x00,
	0xff, 0xff, 0x0f, 0xa0, 0x59, 0xab, 0x00, 0x1e, 0x00, 0x00,
}

func (m *TaggedFlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaggedFlow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaggedFlow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flow != nil {
		{
			size, err := m.Flow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Flow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AclGids) > 0 {
		dAtA3 := make([]byte, len(m.AclGids)*10)
		var j2 int
		for _, num := range m.AclGids {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintFlowLog(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.LastKeepaliveAck != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.LastKeepaliveAck))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.LastKeepaliveSeq != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.LastKeepaliveSeq))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.SynackSeq != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SynackSeq))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.SynSeq != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SynSeq))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.TapSide != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TapSide))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.IsNewFlow != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsNewFlow))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.QueueHash != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.QueueHash))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.IsActiveService != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsActiveService))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.FlowSource != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.FlowSource))
		i--
		dAtA[i] = 0x78
	}
	if m.CloseType != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.CloseType))
		i--
		dAtA[i] = 0x70
	}
	if m.PerfStats != nil {
		{
			size, err := m.PerfStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.HasPerfStats != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.HasPerfStats))
		i--
		dAtA[i] = 0x60
	}
	if m.EthType != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.EthType))
		i--
		dAtA[i] = 0x58
	}
	if m.Vlan != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Vlan))
		i--
		dAtA[i] = 0x50
	}
	if m.Duration != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x40
	}
	if m.EndTime != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x38
	}
	if m.StartTime != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x30
	}
	if m.FlowId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.FlowId))
		i--
		dAtA[i] = 0x28
	}
	if m.Tunnel != nil {
		{
			size, err := m.Tunnel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MetricsPeerDst != nil {
		{
			size, err := m.MetricsPeerDst.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MetricsPeerSrc != nil {
		{
			size, err := m.MetricsPeerSrc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FlowKey != nil {
		{
			size, err := m.FlowKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlowKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Proto != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Proto))
		i--
		dAtA[i] = 0x60
	}
	if m.PortDst != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.PortDst))
		i--
		dAtA[i] = 0x58
	}
	if m.PortSrc != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.PortSrc))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Ip6Dst) > 0 {
		i -= len(m.Ip6Dst)
		copy(dAtA[i:], m.Ip6Dst)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Ip6Dst)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Ip6Src) > 0 {
		i -= len(m.Ip6Src)
		copy(dAtA[i:], m.Ip6Src)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Ip6Src)))
		i--
		dAtA[i] = 0x42
	}
	if m.IpDst != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IpDst))
		i--
		dAtA[i] = 0x38
	}
	if m.IpSrc != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IpSrc))
		i--
		dAtA[i] = 0x30
	}
	if m.MacDst != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.MacDst))
		i--
		dAtA[i] = 0x28
	}
	if m.MacSrc != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.MacSrc))
		i--
		dAtA[i] = 0x20
	}
	if m.TapPort != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TapPort))
		i--
		dAtA[i] = 0x18
	}
	if m.TapType != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TapType))
		i--
		dAtA[i] = 0x10
	}
	if m.VtapId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.VtapId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowMetricsPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMetricsPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowMetricsPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsVip != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsVip))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.IsVipInterface != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsVipInterface))
		i--
		dAtA[i] = 0x78
	}
	if m.IsDevice != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsDevice))
		i--
		dAtA[i] = 0x70
	}
	if m.IsActiveHost != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsActiveHost))
		i--
		dAtA[i] = 0x68
	}
	if m.IsL3End != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsL3End))
		i--
		dAtA[i] = 0x60
	}
	if m.IsL2End != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsL2End))
		i--
		dAtA[i] = 0x58
	}
	if m.L3EpcId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.L3EpcId))
		i--
		dAtA[i] = 0x50
	}
	if m.TcpFlags != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TcpFlags))
		i--
		dAtA[i] = 0x48
	}
	if m.Last != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Last))
		i--
		dAtA[i] = 0x40
	}
	if m.First != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.First))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalPacketCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TotalPacketCount))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalByteCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TotalByteCount))
		i--
		dAtA[i] = 0x28
	}
	if m.PacketCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.PacketCount))
		i--
		dAtA[i] = 0x20
	}
	if m.L4ByteCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.L4ByteCount))
		i--
		dAtA[i] = 0x18
	}
	if m.L3ByteCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.L3ByteCount))
		i--
		dAtA[i] = 0x10
	}
	if m.ByteCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ByteCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TunnelField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelField) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelField) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsIpv6 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsIpv6))
		i--
		dAtA[i] = 0x68
	}
	if m.Tier != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Tier))
		i--
		dAtA[i] = 0x60
	}
	if m.TunnelType != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x58
	}
	if m.RxId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RxId))
		i--
		dAtA[i] = 0x50
	}
	if m.TxId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TxId))
		i--
		dAtA[i] = 0x48
	}
	if m.RxMac1 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RxMac1))
		i--
		dAtA[i] = 0x40
	}
	if m.RxMac0 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RxMac0))
		i--
		dAtA[i] = 0x38
	}
	if m.TxMac1 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TxMac1))
		i--
		dAtA[i] = 0x30
	}
	if m.TxMac0 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TxMac0))
		i--
		dAtA[i] = 0x28
	}
	if m.RxIp1 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RxIp1))
		i--
		dAtA[i] = 0x20
	}
	if m.RxIp0 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RxIp0))
		i--
		dAtA[i] = 0x18
	}
	if m.TxIp1 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TxIp1))
		i--
		dAtA[i] = 0x10
	}
	if m.TxIp0 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TxIp0))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowPerfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowPerfStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowPerfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.L7Protocol != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.L7Protocol))
		i--
		dAtA[i] = 0x20
	}
	if m.L4Protocol != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.L4Protocol))
		i--
		dAtA[i] = 0x18
	}
	if m.L7 != nil {
		{
			size, err := m.L7.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Tcp != nil {
		{
			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TCPPerfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPPerfStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCPPerfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CitCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.CitCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CitSum != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.CitSum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.CitMax != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.CitMax))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SynackCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SynackCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.SynCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SynCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.TotalRetransCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TotalRetransCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CountsPeerRx != nil {
		{
			size, err := m.CountsPeerRx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.CountsPeerTx != nil {
		{
			size, err := m.CountsPeerTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ArtCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ArtCount))
		i--
		dAtA[i] = 0x68
	}
	if m.SrtCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SrtCount))
		i--
		dAtA[i] = 0x60
	}
	if m.RttServerCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RttServerCount))
		i--
		dAtA[i] = 0x58
	}
	if m.RttClientCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RttClientCount))
		i--
		dAtA[i] = 0x50
	}
	if m.ArtSum != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ArtSum))
		i--
		dAtA[i] = 0x48
	}
	if m.SrtSum != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SrtSum))
		i--
		dAtA[i] = 0x40
	}
	if m.RttServerSum != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RttServerSum))
		i--
		dAtA[i] = 0x38
	}
	if m.RttClientSum != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RttClientSum))
		i--
		dAtA[i] = 0x30
	}
	if m.Rtt != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Rtt))
		i--
		dAtA[i] = 0x28
	}
	if m.ArtMax != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ArtMax))
		i--
		dAtA[i] = 0x20
	}
	if m.SrtMax != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SrtMax))
		i--
		dAtA[i] = 0x18
	}
	if m.RttServerMax != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RttServerMax))
		i--
		dAtA[i] = 0x10
	}
	if m.RttClientMax != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RttClientMax))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TcpPerfCountsPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpPerfCountsPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpPerfCountsPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ZeroWinCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ZeroWinCount))
		i--
		dAtA[i] = 0x10
	}
	if m.RetransCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RetransCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L7PerfStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L7PerfStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L7PerfStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RrtMax != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RrtMax))
		i--
		dAtA[i] = 0x40
	}
	if m.RrtSum != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RrtSum))
		i--
		dAtA[i] = 0x38
	}
	if m.RrtCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RrtCount))
		i--
		dAtA[i] = 0x30
	}
	if m.ErrTimeout != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ErrTimeout))
		i--
		dAtA[i] = 0x28
	}
	if m.ErrServerCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ErrServerCount))
		i--
		dAtA[i] = 0x20
	}
	if m.ErrClientCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ErrClientCount))
		i--
		dAtA[i] = 0x18
	}
	if m.ResponseCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ResponseCount))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestCount != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RequestCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L7Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L7Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L7Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Resource) > 0 {
		i -= len(m.Resource)
		copy(dAtA[i:], m.Resource)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Resource)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ReqType) > 0 {
		i -= len(m.ReqType)
		copy(dAtA[i:], m.ReqType)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ReqType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L7Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L7Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L7Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Exception) > 0 {
		i -= len(m.Exception)
		copy(dAtA[i:], m.Exception)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Exception)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TraceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParentSpanId) > 0 {
		i -= len(m.ParentSpanId)
		copy(dAtA[i:], m.ParentSpanId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ParentSpanId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SpanId) > 0 {
		i -= len(m.SpanId)
		copy(dAtA[i:], m.SpanId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.SpanId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceId) > 0 {
		i -= len(m.TraceId)
		copy(dAtA[i:], m.TraceId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.TraceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtendedInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtendedInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtendedInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RowEffect != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RowEffect))
		i--
		dAtA[i] = 0x28
	}
	if len(m.XRequestId) > 0 {
		i -= len(m.XRequestId)
		copy(dAtA[i:], m.XRequestId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.XRequestId)))
		i--
		dAtA[i] = 0x22
	}
	if m.RequestId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClientIp) > 0 {
		i -= len(m.ClientIp)
		copy(dAtA[i:], m.ClientIp)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ClientIp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppProtoLogsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppProtoLogsData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppProtoLogsData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExtInfo != nil {
		{
			size, err := m.ExtInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.TraceInfo != nil {
		{
			size, err := m.TraceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Resp != nil {
		{
			size, err := m.Resp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Req != nil {
		{
			size, err := m.Req.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.RespLen != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RespLen))
		i--
		dAtA[i] = 0x50
	}
	if m.ReqLen != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ReqLen))
		i--
		dAtA[i] = 0x48
	}
	if m.Mqtt != nil {
		{
			size, err := m.Mqtt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Redis != nil {
		{
			size, err := m.Redis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Mysql != nil {
		{
			size, err := m.Mysql.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Kafka != nil {
		{
			size, err := m.Kafka.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Dubbo != nil {
		{
			size, err := m.Dubbo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Dns != nil {
		{
			size, err := m.Dns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppProtoLogsBaseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppProtoLogsBaseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppProtoLogsBaseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SyscallCapSeq_1 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SyscallCapSeq_1))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.SyscallCapSeq_0 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SyscallCapSeq_0))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.SyscallTraceIdThread_1 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SyscallTraceIdThread_1))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.SyscallTraceIdThread_0 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SyscallTraceIdThread_0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.SyscallTraceIdResponse != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SyscallTraceIdResponse))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.SyscallTraceIdRequest != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SyscallTraceIdRequest))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if len(m.ProcessKname_1) > 0 {
		i -= len(m.ProcessKname_1)
		copy(dAtA[i:], m.ProcessKname_1)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ProcessKname_1)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.ProcessKname_0) > 0 {
		i -= len(m.ProcessKname_0)
		copy(dAtA[i:], m.ProcessKname_0)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ProcessKname_0)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.ProcessId_1 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ProcessId_1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.ProcessId_0 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ProcessId_0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.RespTcpSeq != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RespTcpSeq))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.ReqTcpSeq != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ReqTcpSeq))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.IsVipInterfaceDst != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsVipInterfaceDst))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.IsVipInterfaceSrc != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsVipInterfaceSrc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Protocol != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.PortDst != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.PortDst))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.PortSrc != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.PortSrc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.L3EpcIdDst != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.L3EpcIdDst))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.L3EpcIdSrc != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.L3EpcIdSrc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Ip6Dst) > 0 {
		i -= len(m.Ip6Dst)
		copy(dAtA[i:], m.Ip6Dst)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Ip6Dst)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Ip6Src) > 0 {
		i -= len(m.Ip6Src)
		copy(dAtA[i:], m.Ip6Src)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Ip6Src)))
		i--
		dAtA[i] = 0x72
	}
	if m.IpDst != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IpDst))
		i--
		dAtA[i] = 0x68
	}
	if m.IpSrc != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IpSrc))
		i--
		dAtA[i] = 0x60
	}
	if m.MacDst != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.MacDst))
		i--
		dAtA[i] = 0x58
	}
	if m.MacSrc != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.MacSrc))
		i--
		dAtA[i] = 0x50
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlowLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.TapSide != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TapSide))
		i--
		dAtA[i] = 0x40
	}
	if m.IsIpv6 != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.IsIpv6))
		i--
		dAtA[i] = 0x38
	}
	if m.TapType != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TapType))
		i--
		dAtA[i] = 0x30
	}
	if m.VtapId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.VtapId))
		i--
		dAtA[i] = 0x28
	}
	if m.TapPort != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TapPort))
		i--
		dAtA[i] = 0x20
	}
	if m.FlowId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.FlowId))
		i--
		dAtA[i] = 0x18
	}
	if m.EndTime != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x10
	}
	if m.StartTime != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppProtoHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppProtoHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppProtoHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rrt != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Rrt))
		i--
		dAtA[i] = 0x28
	}
	if m.Code != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.MsgType != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x10
	}
	if m.Proto != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Proto))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HttpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.XRequestId) > 0 {
		i -= len(m.XRequestId)
		copy(dAtA[i:], m.XRequestId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.XRequestId)))
		i--
		dAtA[i] = 0x62
	}
	if m.RespContentLength != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RespContentLength))
		i--
		dAtA[i] = 0x58
	}
	if m.ReqContentLength != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ReqContentLength))
		i--
		dAtA[i] = 0x50
	}
	if len(m.SpanId) > 0 {
		i -= len(m.SpanId)
		copy(dAtA[i:], m.SpanId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.SpanId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.TraceId) > 0 {
		i -= len(m.TraceId)
		copy(dAtA[i:], m.TraceId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.TraceId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ClientIp) > 0 {
		i -= len(m.ClientIp)
		copy(dAtA[i:], m.ClientIp)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ClientIp)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if m.StreamId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.StreamId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DnsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Answers) > 0 {
		i -= len(m.Answers)
		copy(dAtA[i:], m.Answers)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Answers)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.QueryName) > 0 {
		i -= len(m.QueryName)
		copy(dAtA[i:], m.QueryName)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.QueryName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.QueryType != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.QueryType))
		i--
		dAtA[i] = 0x10
	}
	if m.TransId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.TransId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DubboInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DubboInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DubboInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TraceId) > 0 {
		i -= len(m.TraceId)
		copy(dAtA[i:], m.TraceId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.TraceId)))
		i--
		dAtA[i] = 0x5a
	}
	if m.RespBodyLen != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RespBodyLen))
		i--
		dAtA[i] = 0x50
	}
	if m.ReqBodyLen != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ReqBodyLen))
		i--
		dAtA[i] = 0x48
	}
	if len(m.MethodName) > 0 {
		i -= len(m.MethodName)
		copy(dAtA[i:], m.MethodName)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.MethodName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ServiceVersion) > 0 {
		i -= len(m.ServiceVersion)
		copy(dAtA[i:], m.ServiceVersion)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ServiceVersion)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Id != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.SerialId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.SerialId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KafkaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KafkaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KafkaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RespMsgSize != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RespMsgSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ApiKey != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ApiKey))
		i--
		dAtA[i] = 0x20
	}
	if m.ApiVersion != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ApiVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.ReqMsgSize != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ReqMsgSize))
		i--
		dAtA[i] = 0x10
	}
	if m.CorrelationId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.CorrelationId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MysqlInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MysqlInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MysqlInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x40
	}
	if m.AffectedRows != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.AffectedRows))
		i--
		dAtA[i] = 0x38
	}
	if m.ResponseCode != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ResponseCode))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Command != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Command))
		i--
		dAtA[i] = 0x20
	}
	if m.ServerThreadId != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ServerThreadId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServerVersion) > 0 {
		i -= len(m.ServerVersion)
		copy(dAtA[i:], m.ServerVersion)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ServerVersion)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProtocolVersion != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ProtocolVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RedisInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedisInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedisInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Response) > 0 {
		i -= len(m.Response)
		copy(dAtA[i:], m.Response)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Response)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RequestType) > 0 {
		i -= len(m.RequestType)
		copy(dAtA[i:], m.RequestType)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.RequestType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Request) > 0 {
		i -= len(m.Request)
		copy(dAtA[i:], m.Request)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Request)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MqttInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MqttInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MqttInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Topics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlowLog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.RespMsgSize != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.RespMsgSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x22
	}
	if m.ProtoVersion != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ProtoVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.ReqMsgSize != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.ReqMsgSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MqttType) > 0 {
		i -= len(m.MqttType)
		copy(dAtA[i:], m.MqttType)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.MqttType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MqttTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MqttTopic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MqttTopic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Qos != 0 {
		i = encodeVarintFlowLog(dAtA, i, uint64(m.Qos))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlowLog(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlowLog(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlowLog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TaggedFlow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flow != nil {
		l = m.Flow.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Flow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowKey != nil {
		l = m.FlowKey.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.MetricsPeerSrc != nil {
		l = m.MetricsPeerSrc.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.MetricsPeerDst != nil {
		l = m.MetricsPeerDst.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Tunnel != nil {
		l = m.Tunnel.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.FlowId != 0 {
		n += 1 + sovFlowLog(uint64(m.FlowId))
	}
	if m.StartTime != 0 {
		n += 1 + sovFlowLog(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovFlowLog(uint64(m.EndTime))
	}
	if m.Duration != 0 {
		n += 1 + sovFlowLog(uint64(m.Duration))
	}
	if m.Vlan != 0 {
		n += 1 + sovFlowLog(uint64(m.Vlan))
	}
	if m.EthType != 0 {
		n += 1 + sovFlowLog(uint64(m.EthType))
	}
	if m.HasPerfStats != 0 {
		n += 1 + sovFlowLog(uint64(m.HasPerfStats))
	}
	if m.PerfStats != nil {
		l = m.PerfStats.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.CloseType != 0 {
		n += 1 + sovFlowLog(uint64(m.CloseType))
	}
	if m.FlowSource != 0 {
		n += 1 + sovFlowLog(uint64(m.FlowSource))
	}
	if m.IsActiveService != 0 {
		n += 2 + sovFlowLog(uint64(m.IsActiveService))
	}
	if m.QueueHash != 0 {
		n += 2 + sovFlowLog(uint64(m.QueueHash))
	}
	if m.IsNewFlow != 0 {
		n += 2 + sovFlowLog(uint64(m.IsNewFlow))
	}
	if m.TapSide != 0 {
		n += 2 + sovFlowLog(uint64(m.TapSide))
	}
	if m.SynSeq != 0 {
		n += 2 + sovFlowLog(uint64(m.SynSeq))
	}
	if m.SynackSeq != 0 {
		n += 2 + sovFlowLog(uint64(m.SynackSeq))
	}
	if m.LastKeepaliveSeq != 0 {
		n += 2 + sovFlowLog(uint64(m.LastKeepaliveSeq))
	}
	if m.LastKeepaliveAck != 0 {
		n += 2 + sovFlowLog(uint64(m.LastKeepaliveAck))
	}
	if len(m.AclGids) > 0 {
		l = 0
		for _, e := range m.AclGids {
			l += sovFlowLog(uint64(e))
		}
		n += 2 + sovFlowLog(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VtapId != 0 {
		n += 1 + sovFlowLog(uint64(m.VtapId))
	}
	if m.TapType != 0 {
		n += 1 + sovFlowLog(uint64(m.TapType))
	}
	if m.TapPort != 0 {
		n += 1 + sovFlowLog(uint64(m.TapPort))
	}
	if m.MacSrc != 0 {
		n += 1 + sovFlowLog(uint64(m.MacSrc))
	}
	if m.MacDst != 0 {
		n += 1 + sovFlowLog(uint64(m.MacDst))
	}
	if m.IpSrc != 0 {
		n += 1 + sovFlowLog(uint64(m.IpSrc))
	}
	if m.IpDst != 0 {
		n += 1 + sovFlowLog(uint64(m.IpDst))
	}
	l = len(m.Ip6Src)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Ip6Dst)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.PortSrc != 0 {
		n += 1 + sovFlowLog(uint64(m.PortSrc))
	}
	if m.PortDst != 0 {
		n += 1 + sovFlowLog(uint64(m.PortDst))
	}
	if m.Proto != 0 {
		n += 1 + sovFlowLog(uint64(m.Proto))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowMetricsPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ByteCount != 0 {
		n += 1 + sovFlowLog(uint64(m.ByteCount))
	}
	if m.L3ByteCount != 0 {
		n += 1 + sovFlowLog(uint64(m.L3ByteCount))
	}
	if m.L4ByteCount != 0 {
		n += 1 + sovFlowLog(uint64(m.L4ByteCount))
	}
	if m.PacketCount != 0 {
		n += 1 + sovFlowLog(uint64(m.PacketCount))
	}
	if m.TotalByteCount != 0 {
		n += 1 + sovFlowLog(uint64(m.TotalByteCount))
	}
	if m.TotalPacketCount != 0 {
		n += 1 + sovFlowLog(uint64(m.TotalPacketCount))
	}
	if m.First != 0 {
		n += 1 + sovFlowLog(uint64(m.First))
	}
	if m.Last != 0 {
		n += 1 + sovFlowLog(uint64(m.Last))
	}
	if m.TcpFlags != 0 {
		n += 1 + sovFlowLog(uint64(m.TcpFlags))
	}
	if m.L3EpcId != 0 {
		n += 1 + sovFlowLog(uint64(m.L3EpcId))
	}
	if m.IsL2End != 0 {
		n += 1 + sovFlowLog(uint64(m.IsL2End))
	}
	if m.IsL3End != 0 {
		n += 1 + sovFlowLog(uint64(m.IsL3End))
	}
	if m.IsActiveHost != 0 {
		n += 1 + sovFlowLog(uint64(m.IsActiveHost))
	}
	if m.IsDevice != 0 {
		n += 1 + sovFlowLog(uint64(m.IsDevice))
	}
	if m.IsVipInterface != 0 {
		n += 1 + sovFlowLog(uint64(m.IsVipInterface))
	}
	if m.IsVip != 0 {
		n += 2 + sovFlowLog(uint64(m.IsVip))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelField) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxIp0 != 0 {
		n += 1 + sovFlowLog(uint64(m.TxIp0))
	}
	if m.TxIp1 != 0 {
		n += 1 + sovFlowLog(uint64(m.TxIp1))
	}
	if m.RxIp0 != 0 {
		n += 1 + sovFlowLog(uint64(m.RxIp0))
	}
	if m.RxIp1 != 0 {
		n += 1 + sovFlowLog(uint64(m.RxIp1))
	}
	if m.TxMac0 != 0 {
		n += 1 + sovFlowLog(uint64(m.TxMac0))
	}
	if m.TxMac1 != 0 {
		n += 1 + sovFlowLog(uint64(m.TxMac1))
	}
	if m.RxMac0 != 0 {
		n += 1 + sovFlowLog(uint64(m.RxMac0))
	}
	if m.RxMac1 != 0 {
		n += 1 + sovFlowLog(uint64(m.RxMac1))
	}
	if m.TxId != 0 {
		n += 1 + sovFlowLog(uint64(m.TxId))
	}
	if m.RxId != 0 {
		n += 1 + sovFlowLog(uint64(m.RxId))
	}
	if m.TunnelType != 0 {
		n += 1 + sovFlowLog(uint64(m.TunnelType))
	}
	if m.Tier != 0 {
		n += 1 + sovFlowLog(uint64(m.Tier))
	}
	if m.IsIpv6 != 0 {
		n += 1 + sovFlowLog(uint64(m.IsIpv6))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlowPerfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.L7 != nil {
		l = m.L7.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.L4Protocol != 0 {
		n += 1 + sovFlowLog(uint64(m.L4Protocol))
	}
	if m.L7Protocol != 0 {
		n += 1 + sovFlowLog(uint64(m.L7Protocol))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TCPPerfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RttClientMax != 0 {
		n += 1 + sovFlowLog(uint64(m.RttClientMax))
	}
	if m.RttServerMax != 0 {
		n += 1 + sovFlowLog(uint64(m.RttServerMax))
	}
	if m.SrtMax != 0 {
		n += 1 + sovFlowLog(uint64(m.SrtMax))
	}
	if m.ArtMax != 0 {
		n += 1 + sovFlowLog(uint64(m.ArtMax))
	}
	if m.Rtt != 0 {
		n += 1 + sovFlowLog(uint64(m.Rtt))
	}
	if m.RttClientSum != 0 {
		n += 1 + sovFlowLog(uint64(m.RttClientSum))
	}
	if m.RttServerSum != 0 {
		n += 1 + sovFlowLog(uint64(m.RttServerSum))
	}
	if m.SrtSum != 0 {
		n += 1 + sovFlowLog(uint64(m.SrtSum))
	}
	if m.ArtSum != 0 {
		n += 1 + sovFlowLog(uint64(m.ArtSum))
	}
	if m.RttClientCount != 0 {
		n += 1 + sovFlowLog(uint64(m.RttClientCount))
	}
	if m.RttServerCount != 0 {
		n += 1 + sovFlowLog(uint64(m.RttServerCount))
	}
	if m.SrtCount != 0 {
		n += 1 + sovFlowLog(uint64(m.SrtCount))
	}
	if m.ArtCount != 0 {
		n += 1 + sovFlowLog(uint64(m.ArtCount))
	}
	if m.CountsPeerTx != nil {
		l = m.CountsPeerTx.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.CountsPeerRx != nil {
		l = m.CountsPeerRx.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.TotalRetransCount != 0 {
		n += 2 + sovFlowLog(uint64(m.TotalRetransCount))
	}
	if m.SynCount != 0 {
		n += 2 + sovFlowLog(uint64(m.SynCount))
	}
	if m.SynackCount != 0 {
		n += 2 + sovFlowLog(uint64(m.SynackCount))
	}
	if m.CitMax != 0 {
		n += 2 + sovFlowLog(uint64(m.CitMax))
	}
	if m.CitSum != 0 {
		n += 2 + sovFlowLog(uint64(m.CitSum))
	}
	if m.CitCount != 0 {
		n += 2 + sovFlowLog(uint64(m.CitCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TcpPerfCountsPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetransCount != 0 {
		n += 1 + sovFlowLog(uint64(m.RetransCount))
	}
	if m.ZeroWinCount != 0 {
		n += 1 + sovFlowLog(uint64(m.ZeroWinCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L7PerfStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestCount != 0 {
		n += 1 + sovFlowLog(uint64(m.RequestCount))
	}
	if m.ResponseCount != 0 {
		n += 1 + sovFlowLog(uint64(m.ResponseCount))
	}
	if m.ErrClientCount != 0 {
		n += 1 + sovFlowLog(uint64(m.ErrClientCount))
	}
	if m.ErrServerCount != 0 {
		n += 1 + sovFlowLog(uint64(m.ErrServerCount))
	}
	if m.ErrTimeout != 0 {
		n += 1 + sovFlowLog(uint64(m.ErrTimeout))
	}
	if m.RrtCount != 0 {
		n += 1 + sovFlowLog(uint64(m.RrtCount))
	}
	if m.RrtSum != 0 {
		n += 1 + sovFlowLog(uint64(m.RrtSum))
	}
	if m.RrtMax != 0 {
		n += 1 + sovFlowLog(uint64(m.RrtMax))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L7Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReqType)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *L7Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovFlowLog(uint64(m.Status))
	}
	if m.Code != 0 {
		n += 1 + sovFlowLog(uint64(m.Code))
	}
	l = len(m.Exception)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TraceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.SpanId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.ParentSpanId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExtendedInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovFlowLog(uint64(m.RequestId))
	}
	l = len(m.XRequestId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.RowEffect != 0 {
		n += 1 + sovFlowLog(uint64(m.RowEffect))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppProtoLogsData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Dns != nil {
		l = m.Dns.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Dubbo != nil {
		l = m.Dubbo.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Kafka != nil {
		l = m.Kafka.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Mysql != nil {
		l = m.Mysql.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Redis != nil {
		l = m.Redis.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Mqtt != nil {
		l = m.Mqtt.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.ReqLen != 0 {
		n += 1 + sovFlowLog(uint64(m.ReqLen))
	}
	if m.RespLen != 0 {
		n += 1 + sovFlowLog(uint64(m.RespLen))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Resp != nil {
		l = m.Resp.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.TraceInfo != nil {
		l = m.TraceInfo.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.ExtInfo != nil {
		l = m.ExtInfo.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppProtoLogsBaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTime != 0 {
		n += 1 + sovFlowLog(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovFlowLog(uint64(m.EndTime))
	}
	if m.FlowId != 0 {
		n += 1 + sovFlowLog(uint64(m.FlowId))
	}
	if m.TapPort != 0 {
		n += 1 + sovFlowLog(uint64(m.TapPort))
	}
	if m.VtapId != 0 {
		n += 1 + sovFlowLog(uint64(m.VtapId))
	}
	if m.TapType != 0 {
		n += 1 + sovFlowLog(uint64(m.TapType))
	}
	if m.IsIpv6 != 0 {
		n += 1 + sovFlowLog(uint64(m.IsIpv6))
	}
	if m.TapSide != 0 {
		n += 1 + sovFlowLog(uint64(m.TapSide))
	}
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.MacSrc != 0 {
		n += 1 + sovFlowLog(uint64(m.MacSrc))
	}
	if m.MacDst != 0 {
		n += 1 + sovFlowLog(uint64(m.MacDst))
	}
	if m.IpSrc != 0 {
		n += 1 + sovFlowLog(uint64(m.IpSrc))
	}
	if m.IpDst != 0 {
		n += 1 + sovFlowLog(uint64(m.IpDst))
	}
	l = len(m.Ip6Src)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Ip6Dst)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.L3EpcIdSrc != 0 {
		n += 2 + sovFlowLog(uint64(m.L3EpcIdSrc))
	}
	if m.L3EpcIdDst != 0 {
		n += 2 + sovFlowLog(uint64(m.L3EpcIdDst))
	}
	if m.PortSrc != 0 {
		n += 2 + sovFlowLog(uint64(m.PortSrc))
	}
	if m.PortDst != 0 {
		n += 2 + sovFlowLog(uint64(m.PortDst))
	}
	if m.Protocol != 0 {
		n += 2 + sovFlowLog(uint64(m.Protocol))
	}
	if m.IsVipInterfaceSrc != 0 {
		n += 2 + sovFlowLog(uint64(m.IsVipInterfaceSrc))
	}
	if m.IsVipInterfaceDst != 0 {
		n += 2 + sovFlowLog(uint64(m.IsVipInterfaceDst))
	}
	if m.ReqTcpSeq != 0 {
		n += 2 + sovFlowLog(uint64(m.ReqTcpSeq))
	}
	if m.RespTcpSeq != 0 {
		n += 2 + sovFlowLog(uint64(m.RespTcpSeq))
	}
	if m.ProcessId_0 != 0 {
		n += 2 + sovFlowLog(uint64(m.ProcessId_0))
	}
	if m.ProcessId_1 != 0 {
		n += 2 + sovFlowLog(uint64(m.ProcessId_1))
	}
	l = len(m.ProcessKname_0)
	if l > 0 {
		n += 2 + l + sovFlowLog(uint64(l))
	}
	l = len(m.ProcessKname_1)
	if l > 0 {
		n += 2 + l + sovFlowLog(uint64(l))
	}
	if m.SyscallTraceIdRequest != 0 {
		n += 2 + sovFlowLog(uint64(m.SyscallTraceIdRequest))
	}
	if m.SyscallTraceIdResponse != 0 {
		n += 2 + sovFlowLog(uint64(m.SyscallTraceIdResponse))
	}
	if m.SyscallTraceIdThread_0 != 0 {
		n += 2 + sovFlowLog(uint64(m.SyscallTraceIdThread_0))
	}
	if m.SyscallTraceIdThread_1 != 0 {
		n += 2 + sovFlowLog(uint64(m.SyscallTraceIdThread_1))
	}
	if m.SyscallCapSeq_0 != 0 {
		n += 2 + sovFlowLog(uint64(m.SyscallCapSeq_0))
	}
	if m.SyscallCapSeq_1 != 0 {
		n += 2 + sovFlowLog(uint64(m.SyscallCapSeq_1))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppProtoHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proto != 0 {
		n += 1 + sovFlowLog(uint64(m.Proto))
	}
	if m.MsgType != 0 {
		n += 1 + sovFlowLog(uint64(m.MsgType))
	}
	if m.Status != 0 {
		n += 1 + sovFlowLog(uint64(m.Status))
	}
	if m.Code != 0 {
		n += 1 + sovFlowLog(uint64(m.Code))
	}
	if m.Rrt != 0 {
		n += 1 + sovFlowLog(uint64(m.Rrt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamId != 0 {
		n += 1 + sovFlowLog(uint64(m.StreamId))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.TraceId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.SpanId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.ReqContentLength != 0 {
		n += 1 + sovFlowLog(uint64(m.ReqContentLength))
	}
	if m.RespContentLength != 0 {
		n += 1 + sovFlowLog(uint64(m.RespContentLength))
	}
	l = len(m.XRequestId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DnsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransId != 0 {
		n += 1 + sovFlowLog(uint64(m.TransId))
	}
	if m.QueryType != 0 {
		n += 1 + sovFlowLog(uint64(m.QueryType))
	}
	l = len(m.QueryName)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Answers)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DubboInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SerialId != 0 {
		n += 1 + sovFlowLog(uint64(m.SerialId))
	}
	if m.Type != 0 {
		n += 1 + sovFlowLog(uint64(m.Type))
	}
	if m.Id != 0 {
		n += 1 + sovFlowLog(uint64(m.Id))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.ServiceVersion)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.MethodName)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.ReqBodyLen != 0 {
		n += 1 + sovFlowLog(uint64(m.ReqBodyLen))
	}
	if m.RespBodyLen != 0 {
		n += 1 + sovFlowLog(uint64(m.RespBodyLen))
	}
	l = len(m.TraceId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KafkaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CorrelationId != 0 {
		n += 1 + sovFlowLog(uint64(m.CorrelationId))
	}
	if m.ReqMsgSize != 0 {
		n += 1 + sovFlowLog(uint64(m.ReqMsgSize))
	}
	if m.ApiVersion != 0 {
		n += 1 + sovFlowLog(uint64(m.ApiVersion))
	}
	if m.ApiKey != 0 {
		n += 1 + sovFlowLog(uint64(m.ApiKey))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.RespMsgSize != 0 {
		n += 1 + sovFlowLog(uint64(m.RespMsgSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MysqlInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolVersion != 0 {
		n += 1 + sovFlowLog(uint64(m.ProtocolVersion))
	}
	l = len(m.ServerVersion)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.ServerThreadId != 0 {
		n += 1 + sovFlowLog(uint64(m.ServerThreadId))
	}
	if m.Command != 0 {
		n += 1 + sovFlowLog(uint64(m.Command))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.ResponseCode != 0 {
		n += 1 + sovFlowLog(uint64(m.ResponseCode))
	}
	if m.AffectedRows != 0 {
		n += 1 + sovFlowLog(uint64(m.AffectedRows))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovFlowLog(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedisInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Request)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.RequestType)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Response)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MqttInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MqttType)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.ReqMsgSize != 0 {
		n += 1 + sovFlowLog(uint64(m.ReqMsgSize))
	}
	if m.ProtoVersion != 0 {
		n += 1 + sovFlowLog(uint64(m.ProtoVersion))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.RespMsgSize != 0 {
		n += 1 + sovFlowLog(uint64(m.RespMsgSize))
	}
	if len(m.Topics) > 0 {
		for _, e := range m.Topics {
			l = e.Size()
			n += 1 + l + sovFlowLog(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MqttTopic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlowLog(uint64(l))
	}
	if m.Qos != 0 {
		n += 1 + sovFlowLog(uint64(m.Qos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFlowLog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlowLog(x uint64) (n int) {
	return sovFlowLog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TaggedFlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaggedFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaggedFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flow == nil {
				m.Flow = &Flow{}
			}
			if err := m.Flow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlowKey == nil {
				m.FlowKey = &FlowKey{}
			}
			if err := m.FlowKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsPeerSrc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetricsPeerSrc == nil {
				m.MetricsPeerSrc = &FlowMetricsPeer{}
			}
			if err := m.MetricsPeerSrc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsPeerDst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetricsPeerDst == nil {
				m.MetricsPeerDst = &FlowMetricsPeer{}
			}
			if err := m.MetricsPeerDst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel == nil {
				m.Tunnel = &TunnelField{}
			}
			if err := m.Tunnel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowId", wireType)
			}
			m.FlowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlan", wireType)
			}
			m.Vlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vlan |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthType", wireType)
			}
			m.EthType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EthType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasPerfStats", wireType)
			}
			m.HasPerfStats = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasPerfStats |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerfStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PerfStats == nil {
				m.PerfStats = &FlowPerfStats{}
			}
			if err := m.PerfStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseType", wireType)
			}
			m.CloseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowSource", wireType)
			}
			m.FlowSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowSource |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActiveService", wireType)
			}
			m.IsActiveService = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsActiveService |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueHash", wireType)
			}
			m.QueueHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueHash |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNewFlow", wireType)
			}
			m.IsNewFlow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsNewFlow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapSide", wireType)
			}
			m.TapSide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TapSide |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynSeq", wireType)
			}
			m.SynSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SynSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynackSeq", wireType)
			}
			m.SynackSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SynackSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastKeepaliveSeq", wireType)
			}
			m.LastKeepaliveSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastKeepaliveSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastKeepaliveAck", wireType)
			}
			m.LastKeepaliveAck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastKeepaliveAck |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowLog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AclGids = append(m.AclGids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlowLog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlowLog
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlowLog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AclGids) == 0 {
					m.AclGids = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlowLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AclGids = append(m.AclGids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AclGids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtapId", wireType)
			}
			m.VtapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VtapId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapType", wireType)
			}
			m.TapType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TapType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapPort", wireType)
			}
			m.TapPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TapPort |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacSrc", wireType)
			}
			m.MacSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacSrc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacDst", wireType)
			}
			m.MacDst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacDst |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSrc", wireType)
			}
			m.IpSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpSrc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDst", wireType)
			}
			m.IpDst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDst |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip6Src", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip6Src = append(m.Ip6Src[:0], dAtA[iNdEx:postIndex]...)
			if m.Ip6Src == nil {
				m.Ip6Src = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip6Dst", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip6Dst = append(m.Ip6Dst[:0], dAtA[iNdEx:postIndex]...)
			if m.Ip6Dst == nil {
				m.Ip6Dst = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSrc", wireType)
			}
			m.PortSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortSrc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortDst", wireType)
			}
			m.PortDst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortDst |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			m.Proto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proto |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMetricsPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMetricsPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMetricsPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteCount", wireType)
			}
			m.ByteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3ByteCount", wireType)
			}
			m.L3ByteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3ByteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4ByteCount", wireType)
			}
			m.L4ByteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4ByteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketCount", wireType)
			}
			m.PacketCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalByteCount", wireType)
			}
			m.TotalByteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalByteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPacketCount", wireType)
			}
			m.TotalPacketCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPacketCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			m.First = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.First |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			m.Last = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Last |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFlags", wireType)
			}
			m.TcpFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFlags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3EpcId", wireType)
			}
			m.L3EpcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3EpcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsL2End", wireType)
			}
			m.IsL2End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsL2End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsL3End", wireType)
			}
			m.IsL3End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsL3End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActiveHost", wireType)
			}
			m.IsActiveHost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsActiveHost |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDevice", wireType)
			}
			m.IsDevice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsDevice |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVipInterface", wireType)
			}
			m.IsVipInterface = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsVipInterface |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVip", wireType)
			}
			m.IsVip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsVip |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIp0", wireType)
			}
			m.TxIp0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxIp0 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIp1", wireType)
			}
			m.TxIp1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxIp1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxIp0", wireType)
			}
			m.RxIp0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxIp0 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxIp1", wireType)
			}
			m.RxIp1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxIp1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMac0", wireType)
			}
			m.TxMac0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxMac0 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMac1", wireType)
			}
			m.TxMac1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxMac1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxMac0", wireType)
			}
			m.RxMac0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxMac0 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxMac1", wireType)
			}
			m.RxMac1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxMac1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			m.TxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxId", wireType)
			}
			m.RxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIpv6", wireType)
			}
			m.IsIpv6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsIpv6 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowPerfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowPerfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowPerfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tcp == nil {
				m.Tcp = &TCPPerfStats{}
			}
			if err := m.Tcp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L7 == nil {
				m.L7 = &L7PerfStats{}
			}
			if err := m.L7.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Protocol", wireType)
			}
			m.L4Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7Protocol", wireType)
			}
			m.L7Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPPerfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPPerfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPPerfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttClientMax", wireType)
			}
			m.RttClientMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttClientMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttServerMax", wireType)
			}
			m.RttServerMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttServerMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrtMax", wireType)
			}
			m.SrtMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrtMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtMax", wireType)
			}
			m.ArtMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttClientSum", wireType)
			}
			m.RttClientSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttClientSum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttServerSum", wireType)
			}
			m.RttServerSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttServerSum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrtSum", wireType)
			}
			m.SrtSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrtSum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtSum", wireType)
			}
			m.ArtSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtSum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttClientCount", wireType)
			}
			m.RttClientCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttClientCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttServerCount", wireType)
			}
			m.RttServerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RttServerCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrtCount", wireType)
			}
			m.SrtCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrtCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtCount", wireType)
			}
			m.ArtCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountsPeerTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CountsPeerTx == nil {
				m.CountsPeerTx = &TcpPerfCountsPeer{}
			}
			if err := m.CountsPeerTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountsPeerRx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CountsPeerRx == nil {
				m.CountsPeerRx = &TcpPerfCountsPeer{}
			}
			if err := m.CountsPeerRx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRetransCount", wireType)
			}
			m.TotalRetransCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRetransCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynCount", wireType)
			}
			m.SynCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SynCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynackCount", wireType)
			}
			m.SynackCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SynackCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CitMax", wireType)
			}
			m.CitMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CitMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CitSum", wireType)
			}
			m.CitSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CitSum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CitCount", wireType)
			}
			m.CitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CitCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpPerfCountsPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpPerfCountsPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpPerfCountsPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransCount", wireType)
			}
			m.RetransCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroWinCount", wireType)
			}
			m.ZeroWinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZeroWinCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L7PerfStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L7PerfStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L7PerfStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCount", wireType)
			}
			m.RequestCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCount", wireType)
			}
			m.ResponseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrClientCount", wireType)
			}
			m.ErrClientCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrClientCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrServerCount", wireType)
			}
			m.ErrServerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrServerCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrTimeout", wireType)
			}
			m.ErrTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrtCount", wireType)
			}
			m.RrtCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrtCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrtSum", wireType)
			}
			m.RrtSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrtSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RrtMax", wireType)
			}
			m.RrtMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RrtMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L7Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L7Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L7Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L7Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L7Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L7Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exception", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exception = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentSpanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentSpanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtendedInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendedInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendedInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowEffect", wireType)
			}
			m.RowEffect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowEffect |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppProtoLogsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppProtoLogsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppProtoLogsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &AppProtoLogsBaseInfo{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http == nil {
				m.Http = &HttpInfo{}
			}
			if err := m.Http.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dns == nil {
				m.Dns = &DnsInfo{}
			}
			if err := m.Dns.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dubbo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dubbo == nil {
				m.Dubbo = &DubboInfo{}
			}
			if err := m.Dubbo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kafka", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kafka == nil {
				m.Kafka = &KafkaInfo{}
			}
			if err := m.Kafka.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mysql", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mysql == nil {
				m.Mysql = &MysqlInfo{}
			}
			if err := m.Mysql.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Redis == nil {
				m.Redis = &RedisInfo{}
			}
			if err := m.Redis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mqtt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mqtt == nil {
				m.Mqtt = &MqttInfo{}
			}
			if err := m.Mqtt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqLen", wireType)
			}
			m.ReqLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespLen", wireType)
			}
			m.RespLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &L7Request{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resp == nil {
				m.Resp = &L7Response{}
			}
			if err := m.Resp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TraceInfo == nil {
				m.TraceInfo = &TraceInfo{}
			}
			if err := m.TraceInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtInfo == nil {
				m.ExtInfo = &ExtendedInfo{}
			}
			if err := m.ExtInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppProtoLogsBaseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppProtoLogsBaseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppProtoLogsBaseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowId", wireType)
			}
			m.FlowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapPort", wireType)
			}
			m.TapPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TapPort |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtapId", wireType)
			}
			m.VtapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VtapId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapType", wireType)
			}
			m.TapType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TapType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIpv6", wireType)
			}
			m.IsIpv6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsIpv6 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TapSide", wireType)
			}
			m.TapSide = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TapSide |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &AppProtoHead{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacSrc", wireType)
			}
			m.MacSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacSrc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacDst", wireType)
			}
			m.MacDst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacDst |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpSrc", wireType)
			}
			m.IpSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpSrc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDst", wireType)
			}
			m.IpDst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDst |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip6Src", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip6Src = append(m.Ip6Src[:0], dAtA[iNdEx:postIndex]...)
			if m.Ip6Src == nil {
				m.Ip6Src = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip6Dst", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip6Dst = append(m.Ip6Dst[:0], dAtA[iNdEx:postIndex]...)
			if m.Ip6Dst == nil {
				m.Ip6Dst = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3EpcIdSrc", wireType)
			}
			m.L3EpcIdSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3EpcIdSrc |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3EpcIdDst", wireType)
			}
			m.L3EpcIdDst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3EpcIdDst |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortSrc", wireType)
			}
			m.PortSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortSrc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortDst", wireType)
			}
			m.PortDst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortDst |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVipInterfaceSrc", wireType)
			}
			m.IsVipInterfaceSrc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsVipInterfaceSrc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVipInterfaceDst", wireType)
			}
			m.IsVipInterfaceDst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsVipInterfaceDst |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqTcpSeq", wireType)
			}
			m.ReqTcpSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqTcpSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespTcpSeq", wireType)
			}
			m.RespTcpSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespTcpSeq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessId_0", wireType)
			}
			m.ProcessId_0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessId_0 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessId_1", wireType)
			}
			m.ProcessId_1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessId_1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessKname_0", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessKname_0 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessKname_1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessKname_1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscallTraceIdRequest", wireType)
			}
			m.SyscallTraceIdRequest = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyscallTraceIdRequest |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscallTraceIdResponse", wireType)
			}
			m.SyscallTraceIdResponse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyscallTraceIdResponse |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscallTraceIdThread_0", wireType)
			}
			m.SyscallTraceIdThread_0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyscallTraceIdThread_0 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscallTraceIdThread_1", wireType)
			}
			m.SyscallTraceIdThread_1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyscallTraceIdThread_1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscallCapSeq_0", wireType)
			}
			m.SyscallCapSeq_0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyscallCapSeq_0 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyscallCapSeq_1", wireType)
			}
			m.SyscallCapSeq_1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyscallCapSeq_1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppProtoHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppProtoHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppProtoHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			m.Proto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proto |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rrt", wireType)
			}
			m.Rrt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rrt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			m.StreamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqContentLength", wireType)
			}
			m.ReqContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqContentLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespContentLength", wireType)
			}
			m.RespContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespContentLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XRequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XRequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransId", wireType)
			}
			m.TransId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
			}
			m.QueryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Answers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DubboInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DubboInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DubboInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialId", wireType)
			}
			m.SerialId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerialId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqBodyLen", wireType)
			}
			m.ReqBodyLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqBodyLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespBodyLen", wireType)
			}
			m.RespBodyLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespBodyLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KafkaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KafkaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KafkaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrelationId", wireType)
			}
			m.CorrelationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CorrelationId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMsgSize", wireType)
			}
			m.ReqMsgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMsgSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			m.ApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKey", wireType)
			}
			m.ApiKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiKey |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespMsgSize", wireType)
			}
			m.RespMsgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespMsgSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MysqlInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MysqlInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MysqlInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			m.ProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerThreadId", wireType)
			}
			m.ServerThreadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerThreadId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Command |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			m.ResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedRows", wireType)
			}
			m.AffectedRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedRows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedisInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedisInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedisInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request[:0], dAtA[iNdEx:postIndex]...)
			if m.Request == nil {
				m.Request = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestType", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestType = append(m.RequestType[:0], dAtA[iNdEx:postIndex]...)
			if m.RequestType == nil {
				m.RequestType = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response[:0], dAtA[iNdEx:postIndex]...)
			if m.Response == nil {
				m.Response = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status[:0], dAtA[iNdEx:postIndex]...)
			if m.Status == nil {
				m.Status = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = append(m.Error[:0], dAtA[iNdEx:postIndex]...)
			if m.Error == nil {
				m.Error = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MqttInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MqttInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MqttInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MqttType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MqttType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMsgSize", wireType)
			}
			m.ReqMsgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMsgSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoVersion", wireType)
			}
			m.ProtoVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtoVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespMsgSize", wireType)
			}
			m.RespMsgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespMsgSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, &MqttTopic{})
			if err := m.Topics[len(m.Topics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MqttTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MqttTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MqttTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlowLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlowLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qos", wireType)
			}
			m.Qos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlowLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlowLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlowLog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlowLog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlowLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlowLog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlowLog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlowLog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlowLog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlowLog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlowLog = fmt.Errorf("proto: unexpected end of group")
)
